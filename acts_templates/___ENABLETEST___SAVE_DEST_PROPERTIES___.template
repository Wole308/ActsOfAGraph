MY_LOOP211: for(unsigned int n=0; n<NUM_VALID_PEs; n++){ offsets[n] = 0; }
if(stats_buffer___size[0][p_v] < threshold___activedstvids && enable___collectactivedstvids == true){
	#ifdef ___ENABLE___COLLECTACTIVEDSTVIDS___
	if(___ENABLE___COLLECTACTIVEDSTVIDS___BOOL___ == 1){
	max_limit = 0; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ if(max_limit < statsbuffer_idbased___size[n][p_v]){ max_limit = statsbuffer_idbased___size[n][p_v]; }}
	SAVE_DEST_PROPERTIES_LOOP1: for(unsigned int k=0; k<max_limit; k++){	
		SAVE_DEST_PROPERTIES_LOOP1B: for(unsigned int n=0; n<NUM_VALID_PEs; n++){ 
		#pragma HLS UNROLL
			if(k < statsbuffer_idbased___size[n][p_v]){
				offsets[n] = retrieve_stats2buffer(k, p_v, statsbuffer_idbased[n]) * ACTVUPDATESBLOCK_VECSIZE;
				#ifndef FPGA_IMPL
				checkoutofbounds("acts_kernel::ERROR 1167::", k, BLOCKRAM_SIZE, NAp, NAp, NAp);
				checkoutofbounds("acts_kernel::ERROR 1171::", offsets[n], MAX_APPLYPARTITION_VECSIZE, NAp, NAp, NAp);
				#endif 
			}
		}
		update_bramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___SAVE_DEST_PROPERTIES___, 1);
		SAVE_DEST_PROPERTIES_LOOP1C: for(unsigned int t=0; t<ACTVUPDATESBLOCK_VECSIZE; t++){
		#pragma HLS PIPELINE II=1
			for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
			#pragma HLS UNROLL
				if((k < statsbuffer_idbased___size[inst][p_v]) && (offsets[inst] + t < MAX_APPLYPARTITION_VECSIZE)){ 
					retrievevec_vdatabuffer(offsets[inst] + t, datas[inst], vdata_buffer[inst]);
					MY_LOOP215: for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
					#pragma HLS UNROLL
						datas[inst][v].mask = INVALIDMASK; // clear mask
					} 
				}
			}
			MY_LOOP10302: for(unsigned int n=0; n<NUM_VALID_PEs; n++){
			#pragma HLS UNROLL
				offsets2[n] = voffset + offsets[n] + t;
			}
			dinsertmany_vdatadram(voffset, offsets2, t, datas, {% include 'arguments_allchannelsinslr.template' %});
			update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___SAVE_DEST_PROPERTIES___, 1);
		}
	}
	}
	#endif 
} else {
	SAVE_DEST_PROPERTIES_LOOP2: for(unsigned int t=0; t<MAX_APPLYPARTITION_VECSIZE; t++){
	#pragma HLS PIPELINE II=1	
		SAVE_DEST_PROPERTIES_LOOP2B: for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ 
		#pragma HLS UNROLL
			retrieveandresetvec_vdatabuffer(t, datas[inst], vdata_buffer[inst]);
		}
		MY_LOOP10202: for(unsigned int n=0; n<NUM_VALID_PEs; n++){ 
		#pragma HLS UNROLL
			offsets2[n] = voffset + offsets[n] + t; 
		}
		dinsertmany_vdatadram(voffset, offsets2, t, datas, {% include 'arguments_allchannelsinslr.template' %});
		update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___SAVE_DEST_PROPERTIES___, 1);
	}
}
			