#define ___ENABLE___RESETBUFFERSATSTART___ 
#define ___ENABLE___CLEAR_COUNTERS___
#define ___ENABLE___PROCESSEDGES___ 
#define ___ENABLE___READ_FRONTIER_PROPERTIES___
#define ___ENABLE___RESET_BUFFERS___
#define ___ENABLE___ECPROCESSEDGES___II1___ 
// // // // // // // // // // // // // // // // // // #define ___ENABLE___COLLECTACTIVEDSTVIDS___ 
#define ___ENABLE___APPLYUPDATESMODULE___ 
	#define ___ENABLE___READ_DEST_PROPERTIES___ 
	#define ___ENABLE___APPLYUPDATES___II1___
	#define ___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___ 
	#define ___ENABLE___SAVE_DEST_PROPERTIES___ 
#define ___ENABLE___GATHER_FRONTIERINFOS___ 
#define ___ENABLE___REPORT_STATISTICS___

#define ___CODE___RESETBUFFERSATSTART___ 0
// #define ___CODE___NUMBER_OF_EDGEUPDATES_LOADED___ 1
#define ___CODE___PROCESSEDGES___ 1
#define ___CODE___READ_FRONTIER_PROPERTIES___ 2
#define ___CODE___VCPROCESSEDGES___ 3
#define ___CODE___ECPROCESSEDGES___ 4
#define ___CODE___SAVEVCUPDATES___ 5
#define ___CODE___COLLECTACTIVEDSTVIDS___ 6
#define ___CODE___APPLYUPDATESMODULE___ 7
	#define ___CODE___READ_DEST_PROPERTIES___ 8
	#define ___CODE___APPLYUPDATES___ 9
	#define ___CODE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___ 10
	#define ___CODE___SAVE_DEST_PROPERTIES___ 11
#define ___CODE___GATHER_FRONTIERINFOS___ 12
#define ___CODE___NUMBER_OF_EDGEUPDATES_LOADED___ 13
#define ___CODE___NUMBER_OF_EDGEUPDATES_APPLIED___ 14
#define ___CODE___NUMBER_OF_NEW_EDGEUPDATES_ADDED___ 15

#define MAXVALID_APPLYPARTITION_VECSIZE (MAX_APPLYPARTITION_VECSIZE >> POW_VALID_VDATA)

#ifdef FPGA_IMPL
#define MY_IFDEF_NFRONTIER() keyvalue_t nfrontier_buffer[EDGE_PACK_SIZE][MAX_ACTVV_VECSIZE]
#define MY_IFDEF_CFRONTIER_TMP() keyvalue_t cfrontier_buffer_tmp[EDGE_PACK_SIZE][MAXVALID_APPLYPARTITION_VECSIZE]
#define MY_IFDEF_CFRONTIER() keyvalue_t cfrontier_buffer[NUM_VALID_PEs][MAXVALID_APPLYPARTITION_VECSIZE]
#define MY_IFDEF_STATSBUFFERMASKBASED_TMP() unsigned int statsbuffer_maskbased_tmp[EDGE_PACK_SIZE][BLOCKRAM_SIZE]	
#define MY_IFDEF_STATSBUFFERMASKBASED() unsigned int statsbuffer_maskbased[MAX_NUM_APPLYPARTITIONS][BLOCKRAM_SIZE]	
#define MY_IFDEF_STATSBUFFERIDBASED() unsigned int statsbuffer_idbased[MAX_NUM_APPLYPARTITIONS][BLOCKRAM_SIZE]	
#define MY_IFDEF_UPDATESTMPBUFFER() keyvalue_t updates_buffer2[UPDATES_BUFFER_PACK_SIZE][UPDATES_BUFFER_SIZE]	
#define MY_IFDEF_VPTRBUFFER() vtr_t vptr_buffer[VPTR_BUFFER_SIZE]
#define MY_IFDEF_EDGESBUFFER() edge3_type edges_buffer[EDGE_PACK_SIZE][EDGE_BUFFER_SIZE]
#define MY_IFDEF_EDGEUPDATESBUFFER() edge_update_type edgeupdates_buffer[EDGE_PACK_SIZE][EDGE_UPDATES_DRAMBUFFER_SIZE]
#define MY_IFDEF_VDATABUFFER() vprop_t vdata_buffer[EDGE_PACK_SIZE][MAXVALID_APPLYPARTITION_VECSIZE]
#define MY_IFDEF_SAVE_TESTPREPARED_EDGEUPDATES() int save_testprepared_edgeupdates(unsigned int base_offset, map_t count[EDGE_PACK_SIZE][EDGE_PACK_SIZE], edge_update_type edgeupdates_buffer[EDGE_PACK_SIZE][EDGE_UPDATES_DRAMBUFFER_SIZE], HBM_channelAXI_t * HBM_channelA, HBM_channelAXI_t * HBM_channelB, unsigned int globalparams[GLOBALBUFFER_SIZE], unsigned int _NUMCLOCKCYCLES_[2][32])
#define MY_IFDEF_SAVE_PARTIALLYPREPARED_EDGEUPDATES() int save_partiallyprepared_edgeupdates(unsigned int base_offset, map_t count[EDGE_PACK_SIZE][EDGE_PACK_SIZE], edge_update_type edgeupdates_buffer[EDGE_PACK_SIZE][EDGE_UPDATES_DRAMBUFFER_SIZE], HBM_channelAXI_t * HBM_channelA, HBM_channelAXI_t * HBM_channelB, unsigned int globalparams[GLOBALBUFFER_SIZE], unsigned int _NUMCLOCKCYCLES_[2][32])
#define MY_IFDEF_SAVE_FULLYPREPARED_EDGEUPDATES() void save_fullyprepared_edgeupdates(unsigned int base_offset, map_t count[EDGE_PACK_SIZE][EDGE_PACK_SIZE], edge_update_type edgeupdates_buffer[EDGE_PACK_SIZE][EDGE_UPDATES_DRAMBUFFER_SIZE], map_t * edgeupdate_maps, HBM_channelAXI_t * HBM_channelA, HBM_channelAXI_t * HBM_channelB, unsigned int globalparams[GLOBALBUFFER_SIZE], unsigned int _NUMCLOCKCYCLES_[2][32])
#define MY_IFDEF_TOPLEVELFUNC() void top_function({% include '___HBM___PARAMS___.template' %}, HBM_channelAXI_t * HBM_centerA, HBM_channelAXI_t * HBM_centerB, unsigned int module, unsigned int start_pu, unsigned int size_pu, unsigned int start_pv, unsigned int size_pv, unsigned int start_llpset, unsigned int size_llpset, unsigned int start_llpid, unsigned int size_llpid, unsigned int start_gv, unsigned int size_gv, unsigned int finish)
#else
#define MY_IFDEF_NFRONTIER() keyvalue_t * nfrontier_buffer[EDGE_PACK_SIZE]
#define MY_IFDEF_CFRONTIER_TMP() keyvalue_t * cfrontier_buffer_tmp[EDGE_PACK_SIZE]
#define MY_IFDEF_CFRONTIER() keyvalue_t * cfrontier_buffer[NUM_VALID_PEs]
#define MY_IFDEF_STATSBUFFERMASKBASED_TMP() unsigned int * statsbuffer_maskbased_tmp[EDGE_PACK_SIZE]
#define MY_IFDEF_STATSBUFFERMASKBASED() unsigned int * statsbuffer_maskbased[MAX_NUM_APPLYPARTITIONS]
#define MY_IFDEF_STATSBUFFERIDBASED() unsigned int * statsbuffer_idbased[MAX_NUM_APPLYPARTITIONS]
#define MY_IFDEF_UPDATESTMPBUFFER() keyvalue_t * updates_buffer2[UPDATES_BUFFER_PACK_SIZE]
#define MY_IFDEF_VPTRBUFFER() vtr_t * vptr_buffer
#define MY_IFDEF_EDGESBUFFER() edge3_type * edges_buffer[EDGE_PACK_SIZE]
#define MY_IFDEF_EDGEUPDATESBUFFER() edge_update_type * edgeupdates_buffer[EDGE_PACK_SIZE]
#define MY_IFDEF_VDATABUFFER() vprop_t * vdata_buffer[EDGE_PACK_SIZE]
#define MY_IFDEF_SAVE_TESTPREPARED_EDGEUPDATES() int save_testprepared_edgeupdates(unsigned int base_offset, map_t count[EDGE_PACK_SIZE][EDGE_PACK_SIZE], edge_update_type * edgeupdates_buffer[EDGE_PACK_SIZE], HBM_channelAXI_t * HBM_channelA, HBM_channelAXI_t * HBM_channelB, unsigned int globalparams[GLOBALBUFFER_SIZE], unsigned int _NUMCLOCKCYCLES_[2][32])
#define MY_IFDEF_SAVE_PARTIALLYPREPARED_EDGEUPDATES() int save_partiallyprepared_edgeupdates(unsigned int base_offset, map_t count[EDGE_PACK_SIZE][EDGE_PACK_SIZE], edge_update_type * edgeupdates_buffer[EDGE_PACK_SIZE], HBM_channelAXI_t * HBM_channelA, HBM_channelAXI_t * HBM_channelB, unsigned int globalparams[GLOBALBUFFER_SIZE], unsigned int _NUMCLOCKCYCLES_[2][32])
#define MY_IFDEF_SAVE_FULLYPREPARED_EDGEUPDATES() void save_fullyprepared_edgeupdates(unsigned int base_offset, map_t count[EDGE_PACK_SIZE][EDGE_PACK_SIZE], edge_update_type * edgeupdates_buffer[EDGE_PACK_SIZE], map_t * edgeupdate_maps, HBM_channelAXI_t * HBM_channelA, HBM_channelAXI_t * HBM_channelB, unsigned int globalparams[GLOBALBUFFER_SIZE], unsigned int _NUMCLOCKCYCLES_[2][32])
#define MY_IFDEF_TOPLEVELFUNC() void acts_kernel::top_function({% include '___HBM___PARAMS___.template' %}, HBM_channelAXI_t * HBM_centerA, HBM_channelAXI_t * HBM_centerB, unsigned int module, unsigned int start_pu, unsigned int size_pu, unsigned int start_pv, unsigned int size_pv, unsigned int start_llpset, unsigned int size_llpset, unsigned int start_llpid, unsigned int size_llpid, unsigned int start_gv, unsigned int size_gv, unsigned int finish)					
#endif

#define APPLY_CMD 2
#define TRANSPORT_CMD 3

#ifndef FPGA_IMPL
unsigned int * globalparams_debug;
// unsigned int _NUMCLOCKCYCLES_[2][32]; 
#endif 

#ifndef FPGA_IMPL 
acts_kernel::acts_kernel(universalparams_t _universalparams){
	utilityobj = new utility(_universalparams);
	universalparams = _universalparams;
	algorithmobj = new algorithm();
}
acts_kernel::~acts_kernel(){} 
#endif 

{% include '___ENABLE___UTILFUNCS___.template' %}	

{% include '___ENABLE___ACCESSHBM___.template' %}	

{% include '___ENABLE___ACCESSBRAM___.template' %}	

//////////////////////////////////////////////////////////////////

MY_IFDEF_SAVE_PARTIALLYPREPARED_EDGEUPDATES(){
	edge_update_type edge_update_in[NUM_LLP_PER_LLPSET];	
	edge_update_type edge_update_out[NUM_LLP_PER_LLPSET];
	unsigned int offset_p[NUM_LLP_PER_LLPSET];
	unsigned int p_[NUM_LLP_PER_LLPSET];
	unsigned int index = 0;
	unsigned int max[NUM_LLP_PER_LLPSET]; 
	unsigned int index_t = 0;
	for(unsigned int llp_id=0; llp_id<NUM_LLP_PER_LLPSET; llp_id++){ max[llp_id] = 0; for(unsigned int v=0; v<NUM_LLP_PER_LLPSET; v++){ if(max[llp_id] < count[v][llp_id].size){ max[llp_id] = count[v][llp_id].size; }}}
	unsigned int max_ = 0; for(unsigned int v=0; v<NUM_LLP_PER_LLPSET; v++){ if(max_ += max[v]); }
	
	unsigned int llp_id = 0;
	for(unsigned int t=0; t<max_; t++){ // EDGE_UPDATES_DRAMBUFFER_SIZE
	#pragma HLS PIPELINE II=1
		if(index_t >= max[llp_id]){ llp_id += 1; index_t = 0; }
		
		for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 	
		#pragma HLS UNROLL
			unsigned int p_ = ((EDGE_PACK_SIZE + v - llp_id) % EDGE_PACK_SIZE);
			
			if(index_t < count[v][p_].size){ edge_update_in[v] = retrieve_edgeupdatesbuffer(v, count[v][p_].offset + index_t, edgeupdates_buffer); } 
			else { edge_update_in[v].srcvid = p_; edge_update_in[v].dstvid = INVALIDDATA; }				
		}
		
		#ifdef _DEBUGMODE_KERNELPRINTS//4
		if(t==0){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ cout<<"save_partiallyprepared_edgeupdates (before-cyclic-rotate): llp_id: "<<llp_id<<", t:"<<t<<", edge_update_in["<<v<<"].srcvid: "<<edge_update_in[v].srcvid<<" ("<<edge_update_in[v].srcvid % EDGE_PACK_SIZE<<"), edge_update_in["<<v<<"].dstvid: "<<edge_update_in[v].dstvid<<" ("<<edge_update_in[v].dstvid % EDGE_PACK_SIZE<<")"<<endl; }}
		#endif 
		unsigned int rotateby = edge_update_in[0].srcvid % EDGE_PACK_SIZE;
		rearrangeLayoutVx16(rotateby, edge_update_in, edge_update_out); 		
		#ifdef _DEBUGMODE_KERNELPRINTS//4
		if(t==0){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ cout<<"save_partiallyprepared_edgeupdates (after-cyclic-rotate): llp_id: "<<llp_id<<", t:"<<t<<", edge_update_out["<<v<<"].srcvid: "<<edge_update_out[v].srcvid<<" ("<<edge_update_out[v].srcvid % EDGE_PACK_SIZE<<"), edge_update_out["<<v<<"].dstvid: "<<edge_update_out[v].dstvid<<" ("<<edge_update_out[v].dstvid % EDGE_PACK_SIZE<<")"<<endl; }}
		#endif 
		
		for(unsigned int v=0; v<EDGE_PACK_SIZE/2; v++){				
		#pragma HLS UNROLL
			HBM_channelA[base_offset + index].data[2*v] = edge_update_out[v].srcvid;
			HBM_channelA[base_offset + index].data[2*v + 1] = edge_update_out[v].dstvid;
		}
		for(unsigned int v=0; v<EDGE_PACK_SIZE/2; v++){				
		#pragma HLS UNROLL
			HBM_channelB[base_offset + index].data[2*v] = edge_update_out[EDGE_PACK_SIZE/2 + v].srcvid;
			HBM_channelB[base_offset + index].data[2*v + 1] = edge_update_out[EDGE_PACK_SIZE/2 + v].dstvid;
		}
		index += 1;	
		index_t += 1;
		update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___ECPROCESSEDGES___, 1);
	}
	
	#ifdef _DEBUGMODE_KERNELPRINTS//4
	cout<<">>> save_partiallyprepared_edgeupdates (after-cyclic-rotate): index: "<<index<<endl;
	#endif 
	return index;
}

MY_IFDEF_SAVE_FULLYPREPARED_EDGEUPDATES(){
	unsigned int offset_p[EDGE_PACK_SIZE];
	unsigned int p_[EDGE_PACK_SIZE];
	edge_update_type edge_update[EDGE_PACK_SIZE];	
	for(unsigned int llp_id=0; llp_id<EDGE_PACK_SIZE; llp_id++){	
		unsigned int offset = base_offset + edgeupdate_maps[llp_id].offset + edgeupdate_maps[llp_id].size;
		for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ p_[v] =  ((llp_id + v) % EDGE_PACK_SIZE); offset_p[v] = count[v][p_[v]].offset; }
		unsigned int max = 0; for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ if(max < count[v][llp_id].size){ max = count[v][llp_id].size; }}	
		#ifdef _DEBUGMODE_KERNELPRINTS//4
		cout<<"save_fullyprepared_edgeupdates: llp_id: "<<llp_id<<endl; for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ cout<<""<<p_[v]<<", "; } cout<<endl;
		cout<<"save_fullyprepared_edgeupdates: llp_id: "<<llp_id<<endl; for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ cout<<""<<offset_p[v]<<", "; } cout<<endl;
		#endif 
		
		SAVE_FULLYPREPARED_EDGEUPDATES: for(unsigned int t=0; t<EDGE_UPDATES_DRAMBUFFER_SIZE / EDGE_PACK_SIZE; t++){	// max // REMOVEME. // max
		#pragma HLS PIPELINE II=1
			for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 	
			#pragma HLS UNROLL
				if(t < count[v][p_[v]].size){ edge_update[v] = retrieve_edgeupdatesbuffer(v, offset_p[v] + t, edgeupdates_buffer); } // FIXME. SIMPLIFYME.
				else { edge_update[v].srcvid = INVALIDDATA; edge_update[v].dstvid = INVALIDDATA; }
				#ifdef _DEBUGMODE_KERNELPRINTS//4
				if(t==0){ cout<<"save_fullyprepared_edgeupdates: llp_id: "<<llp_id<<", t:"<<t<<", edge_update["<<v<<"].srcvid: "<<edge_update[v].srcvid<<" ("<<edge_update[v].srcvid % EDGE_PACK_SIZE<<"), edge_update["<<v<<"].dstvid: "<<edge_update[v].dstvid<<" ("<<edge_update[v].dstvid % EDGE_PACK_SIZE<<")"<<endl; }
				#endif 
			}
			
			for(unsigned int v=0; v<EDGE_PACK_SIZE/2; v++){				
			#pragma HLS UNROLL
				HBM_channelA[offset + t].data[2*v] = edge_update[v].srcvid;
				HBM_channelA[offset + t].data[2*v + 1] = edge_update[v].dstvid;
			}
			for(unsigned int v=0; v<EDGE_PACK_SIZE/2; v++){				
			#pragma HLS UNROLL
				HBM_channelB[offset + t].data[2*v] = edge_update[EDGE_PACK_SIZE/2 + v].srcvid;
				HBM_channelB[offset + t].data[2*v + 1] = edge_update[EDGE_PACK_SIZE/2 + v].dstvid;
			}
			update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___ECPROCESSEDGES___, 1);
		}		
		edgeupdate_maps[llp_id].size += max;	
	}	
}

#ifdef RRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
// globalparams[GLOBALPARAMSCODE__BASEOFFSET__EDGEUPDATES]
// globalparams[GLOBALPARAMSCODE__BASEOFFSET__EDGEUPDATESPTRS]
// #define _DEBUGMODE_KERNELPRINTS4_PREPAREEDGEUPDATES
void create_actpack(unsigned int destedgeupdates_baseoffset, unsigned int destedgeupdateptrs_baseoffset, unsigned int globalparams[GLOBALBUFFER_SIZE], {% include '___HBM___PARAMS___.template' %}){
	map_t count[NUM_VALID_PEs][EDGE_PACK_SIZE][EDGE_PACK_SIZE]; 
	#pragma HLS ARRAY_PARTITION variable=count complete dim=1
	#pragma HLS ARRAY_PARTITION variable=count complete dim=2
	edge_update_vec_dt edge_update_vecs[NUM_VALID_PEs];
	unsigned int rawedges_maps[NUM_VALID_PEs];
	unsigned int temp_size[NUM_VALID_PEs];
	unsigned int base_offset; 

	for(unsigned int p_u=0; p_u<globalparams[GLOBALPARAMSCODE__PARAM__NUM_UPARTITIONS]; p_u++){ 
		#ifdef _DEBUGMODE_KERNELPRINTS4 
		if(all_vertices_active_in_all_iterations == true){ cout<<"### preparing edge updates in upartition "<<p_u<<": [PEs "; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<n<<", "; } cout<<"]"<<endl; }
		#endif 
		for(unsigned int llp_set=0; llp_set<globalparams[GLOBALPARAMSCODE__PARAM__NUM_APPLYPARTITIONS]; llp_set++){ 
			for(unsigned int c=0; c<2; c++){
				if(c==0){ base_offset = globalparams[GLOBALPARAMSCODE__BASEOFFSET__RAWEDGEUPDATES]; } 
				else { base_offset = globalparams[GLOBALPARAMSCODE__BASEOFFSET__PARTIALLYPROCESSEDEDGEUPDATES]; }
				
				unsigned int index = (p_u * MAX_NUM_LLPSETS) + llp_set;
				{%for n in context['NUM_VALID_PEs_seq']%}
				rawedges_maps[{{n}}] = HBM_channelA{{n}}[globalparams[GLOBALPARAMSCODE__BASEOFFSET__RAWEDGEUPDATESPTRS] + (index / HBM_AXI_PACK_SIZE)].data[(index % HBM_AXI_PACK_SIZE)];
				{%endfor%}
				unsigned int maxnum_rawedges = 0; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ if(maxnum_rawedges < rawedges_maps[n]){ maxnum_rawedges = rawedges_maps[n]; }}
				unsigned int maxnum_preprocedges = 0; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ if(maxnum_preprocedges < temp_size[n]){ maxnum_preprocedges = temp_size[n]; }}
				unsigned int work_size;	if(c==0){ work_size = maxnum_rawedges; } else { work_size = maxnum_preprocedges; }
				#ifdef _DEBUGMODE_CHECKS3
				if(c==1 && work_size > EDGE_UPDATES_DRAMBUFFER_SIZE){ cout<<"ALERT: c("<<c<<")==1 && work_size("<<work_size<<") > EDGE_UPDATES_DRAMBUFFER_SIZE("<<EDGE_UPDATES_DRAMBUFFER_SIZE<<"). EXITING..."<<endl; exit(EXIT_FAILURE); }
				#endif
				
				#ifdef _DEBUGMODE_KERNELPRINTS4_PREPAREEDGEUPDATES
				cout<<">>> acts_kernel::prepare-edge-updates:: c: "<<c<<", p_u: "<<p_u<<", llp_set: "<<llp_set<<", work_size: "<<work_size<<endl; 
				cout<<"acts_kernel::prepare-edge-updates:: rawedges_maps:"<<endl; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<rawedges_maps[n]<<", "; } cout<<endl;
				cout<<"acts_kernel::prepare-edge-updates:: temp_size:"<<endl; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<temp_size[n]<<", "; } cout<<endl;
				#endif 
				
				// reset
				LOOP1734: for(unsigned int t=0; t<EDGE_PACK_SIZE; t++){
				#pragma HLS PIPELINE II=1
					for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
					#pragma HLS UNROLL
						for(unsigned int n=0; n<NUM_VALID_PEs; n++){
						#pragma HLS UNROLL
							count[n][v][t].offset = 0;
							count[n][v][t].size = 0;
						}
					}
				}

				unsigned int offset_eu;
				if(c==0){ offset_eu = (p_u * globalparams[GLOBALPARAMSCODE__PARAM__NUM_APPLYPARTITIONS] * EDGE_UPDATES_DRAMBUFFER_SIZE) + (llp_set * EDGE_UPDATES_DRAMBUFFER_SIZE); } 
				else { offset_eu = 0; }	
				LOOP1354: for(unsigned int n=0; n<NUM_VALID_PEs; n++){ 
				#pragma HLS UNROLL
					offsets_eu[n] = offset_eu; 
				}	

				if(c == 1){
					LOAD_EDGEMAPS_LOOP1: for(unsigned int llp_id=0; llp_id<NUM_LLP_PER_LLPSET; llp_id++){	
						map_t edge_map_vec[NUM_VALID_PEs];
						load_edgemaps((p_u * MAX_NUM_LLP_PER_UPARTITION) + (llp_set * NUM_LLP_PER_LLPSET) + llp_id, destedgeupdateptrs_baseoffset, edge_map_vec, {% include '___HBM___ARGS___.template' %});
						for(unsigned int n=0; n<NUM_VALID_PEs; n++){
						#pragma HLS UNROLL
							edgeupdate_maps[n][llp_id] = edge_map_vec[n];
						}
					}	
				}

				PREPARE_EDGEUPDATES_LOOP1: for(unsigned int t=0; t<work_size; t++){ // EDGE_UPDATES_DRAMBUFFER_SIZE, 1024, work_size
				#pragma HLS PIPELINE II={{context['II_PREPARE_EDGEUPDATES_LOOP1']}}
					dretrievemany_rawedgeupdates(base_offset, offsets_eu, t, edge_update_vecs, {% include '___HBM___ARGS___.template' %});
					for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
					#pragma HLS UNROLL
						for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
						#pragma HLS UNROLL
							#ifdef _DEBUGMODE_KERNELPRINTS//4
							if(inst == 0 && t<1){ cout<<">>> collect-stats: [t:"<<t<<"]: edge_update_vecs["<<inst<<"].data["<<v<<"].srcvid: "<<edge_update_vecs[inst].data[v].srcvid<<" ("<<edge_update_vecs[inst].data[v].srcvid % EDGE_PACK_SIZE<<"), edge_update_vecs["<<inst<<"].data["<<v<<"].dstvid: "<<edge_update_vecs[inst].data[v].dstvid<<" ("<<edge_update_vecs[inst].data[v].dstvid % EDGE_PACK_SIZE<<")"<<endl; }		
							#endif 
							unsigned int data = 0; if(c==0){ data = edge_update_vecs[inst].data[v].srcvid; } else { data = edge_update_vecs[inst].data[v].dstvid; }
							unsigned int p = data % EDGE_PACK_SIZE;
							#ifndef FPGA_IMPL
							checkoutofbounds("acts_kernel::ERROR 2215::", p, EDGE_PACK_SIZE, NAp, NAp, NAp);
							#endif 
							if(data != INVALIDDATA){ count[inst][v][p].size += 1; }
						}
					}
					update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___ECPROCESSEDGES___, 1);
				}
				#ifdef _DEBUGMODE_KERNELPRINTS//4
				for(unsigned int p=0; p<EDGE_PACK_SIZE; p++){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ for(unsigned int n=0; n<1; n++){ cout<<"c: "<<c<<" (before): count["<<n<<"]["<<v<<"]["<<p<<"].offset: "<<count[n][v][p].offset<<", count["<<n<<"]["<<v<<"]["<<p<<"].size: "<<count[n][v][p].size<<endl; }}}		
				#endif 
				
				LOOP1334: for(unsigned int p=1; p<EDGE_PACK_SIZE; p++){ 
				#pragma HLS PIPELINE II=1
					for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
					#pragma HLS UNROLL
						for(unsigned int n=0; n<NUM_VALID_PEs; n++){
						#pragma HLS UNROLL
							count[n][v][p].offset = count[n][v][p-1].offset + count[n][v][p-1].size;					
							#ifdef _DEBUGMODE_CHECKS3
							if(count[0][v][p-1].offset + count[0][v][p-1].size > EDGE_UPDATES_DRAMBUFFER_SIZE){ cout<<"ALERT: count[0]["<<v<<"]["<<p-1<<"].offset ("<<count[0][v][p-1].offset<<") + count[0]["<<v<<"]["<<p-1<<"].size ("<<count[0][v][p-1].size<<") (:"<<count[0][v][p-1].offset + count[0][v][p-1].size<<":) >= EDGE_UPDATES_DRAMBUFFER_SIZE. EXITING..."<<endl; exit(EXIT_FAILURE); }					
							#endif
						}	
					}	
				}		
				#ifdef _DEBUGMODE_KERNELPRINTS//4
				for(unsigned int p=0; p<EDGE_PACK_SIZE; p++){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ for(unsigned int n=0; n<1; n++){ cout<<"c: "<<c<<" (after): count["<<n<<"]["<<v<<"]["<<p<<"].offset: "<<count[n][v][p].offset<<", count["<<n<<"]["<<v<<"]["<<p<<"].size: "<<count[n][v][p].size<<endl; }}}	
				#endif 
				
				LOOP1234: for(unsigned int p=0; p<EDGE_PACK_SIZE; p++){ 
				#pragma HLS PIPELINE II=1
					for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
					#pragma HLS UNROLL
						for(unsigned int n=0; n<NUM_VALID_PEs; n++){
						#pragma HLS UNROLL
							count[n][v][p].size = 0;
						}
					}
				}	

				PREPARE_EDGEUPDATES_LOOP2: for(unsigned int t=0; t<work_size; t++){ // EDGE_UPDATES_DRAMBUFFER_SIZE, 1024, work_size
				#pragma HLS PIPELINE II={{context['II_PREPARE_EDGEUPDATES_LOOP2']}}
					dretrievemany_rawedgeupdates(base_offset, offsets_eu, t, edge_update_vecs, {% include '___HBM___ARGS___.template' %});
					for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
					#pragma HLS UNROLL
						for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
						#pragma HLS UNROLL
							unsigned int data = 0; if(c==0){ data = edge_update_vecs[inst].data[v].srcvid; } else { data = edge_update_vecs[inst].data[v].dstvid; }
							unsigned int p = data % EDGE_PACK_SIZE;

							#ifndef FPGA_IMPL
							checkoutofbounds("acts_kernel::ERROR 2215::", p, EDGE_PACK_SIZE, NAp, NAp, NAp);
							#endif 
							insert_edgeupdatesbuffer(v, count[inst][v][p].offset + count[inst][v][p].size, edge_update_vecs[inst].data[v], edgeupdates_buffer[inst]); 
							if(data != INVALIDDATA){ count[inst][v][p].size += 1; }
							
							#ifdef _DEBUGMODE_KERNELPRINTS//4	
							if(inst==0 && t<8 && v==0){ cout<<"[finalized edge update: p: "<<p<<", srcvid: "<<edge_update_vecs[inst].data[v].srcvid<<", dstvid: "<<edge_update_vecs[inst].data[v].dstvid<<"]"<<endl; }						
							#endif 
						}
					}
					update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___ECPROCESSEDGES___, 1);
				}
				
				if(c==0){ 
					{%for i in context['NUM_VALID_PEs_seq']%}	
					temp_size[{{i}}] = save_partiallyprepared_edgeupdates(globalparams[GLOBALPARAMSCODE__BASEOFFSET__PARTIALLYPROCESSEDEDGEUPDATES], count[{{i}}], edgeupdates_buffer[{{i}}], HBM_channelA{{i}}, HBM_channelB{{i}}, globalparams, _NUMCLOCKCYCLES_);	
					{%endfor%}	
				} else {
					#ifdef _DEBUGMODE_KERNELPRINTS4_PREPAREEDGEUPDATES
					for(unsigned int n=0; n<NUM_VALID_PEs; n++){ for(unsigned int llp_id=0; llp_id<NUM_LLP_PER_LLPSET; llp_id++){ cout<<"prepare-edge-updates (before): edgeupdate_maps[n]["<<llp_id<<"]: p_u: "<<p_u<<", llp_set: "<<llp_set<<", llp_id: "<<llp_id<<", offset: "<<edgeupdate_maps[n][llp_id].offset<<", size: "<<edgeupdate_maps[n][llp_id].size<<""<<endl; }}
					#endif 	
					{%for i in context['NUM_VALID_PEs_seq']%}	
					save_fullyprepared_edgeupdates(destedgeupdates_baseoffset, count[{{i}}], edgeupdates_buffer[{{i}}], edgeupdate_maps[{{i}}], HBM_channelA{{i}}, HBM_channelB{{i}}, globalparams, _NUMCLOCKCYCLES_);	
					{%endfor%}	
					#ifdef _DEBUGMODE_KERNELPRINTS4_PREPAREEDGEUPDATES
					for(unsigned int n=0; n<NUM_VALID_PEs; n++){ for(unsigned int llp_id=0; llp_id<NUM_LLP_PER_LLPSET; llp_id++){ cout<<"prepare-edge-updates (after): edgeupdate_maps[n]["<<llp_id<<"]: p_u: "<<p_u<<", llp_set: "<<llp_set<<", llp_id: "<<llp_id<<", offset: "<<edgeupdate_maps[n][llp_id].offset<<", size: "<<edgeupdate_maps[n][llp_id].size<<""<<endl; }}
					#endif 
				}

				// update edge maps
				if(c == 1){ 
					SAVE_EDGEMAPS_LOOP1: for(unsigned int llp_id=0; llp_id<NUM_LLP_PER_LLPSET; llp_id++){	
						map_t edge_map_vec[NUM_VALID_PEs];
						for(unsigned int n=0; n<NUM_VALID_PEs; n++){
						#pragma HLS UNROLL
							edge_map_vec[n] = edgeupdate_maps[n][llp_id];
						}				
						save_edgemaps((p_u * MAX_NUM_LLP_PER_UPARTITION) + (llp_set * NUM_LLP_PER_LLPSET) + llp_id, destedgeupdateptrs_baseoffset, edge_map_vec, {% include '___HBM___ARGS___.template' %});
					}
				}
				// exit(EXIT_SUCCESS); 
			}
			// exit(EXIT_SUCCESS); 
		}
		// exit(EXIT_SUCCESS);
	}
	// exit(EXIT_SUCCESS); 

}
#endif 

void transport_frontier(unsigned int inst, unsigned int p_v, unsigned int baseoffset_nfdram, unsigned int * cfrontier_dram___size, unsigned int * nfrontier_dram___size, offset_t * upartition_vertices, HBM_channelAXI_t * HBM_channelA, HBM_channelAXI_t * HBM_channelB, HBM_channelAXI_t * HBM_centerA, HBM_channelAXI_t * HBM_centerB, unsigned int * totalactvvs2, unsigned int _NUMCLOCKCYCLES_[2][32]){
	frontier_t actvv[EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = actvv complete
	unsigned int totalactvvs2_tmp[EDGE_PACK_SIZE]; 
	#pragma HLS ARRAY_PARTITION variable = totalactvvs2_tmp complete
	unsigned int data[HBM_CHANNEL_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable=data complete
				
	for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ totalactvvs2_tmp[v] = 0; }
	TRANSPORT_FRONTIER_PROPERTIES_LOOP1: for(unsigned int p_actvv=0; p_actvv<NUM_ACTVVPARTITIONS_PER_APPLYPARTITION; p_actvv++){
		unsigned int p_actvv_ = p_v * NUM_ACTVVPARTITIONS_PER_APPLYPARTITION + p_actvv;
		#ifndef FPGA_IMPL
		checkoutofbounds("acts_kernel::ERROR 225::", p_actvv_, MAX_NUM_UPARTITIONS, NAp, NAp, NAp);
		#endif 
		unsigned int offset_n = baseoffset_nfdram + (p_actvv_ * MAX_APPLYPARTITION_VECSIZE);
		unsigned int offset_c = p_actvv_ * MAX_UPARTITION_VECSIZE;
		unsigned int st = cfrontier_dram___size[p_actvv_];
		
		TRANSPORT_FRONTIER_PROPERTIES_LOOP1B: for(unsigned int t=0; t<nfrontier_dram___size[p_actvv_]; t++){
		#pragma HLS PIPELINE II={{context['II_TRANSPORT_FRONTIER_PROPERTIES_LOOP1B']}}
			{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
			data[{{v}}] = HBM_channelA[offset_n + t].data[{{v}}];
			{%endfor%}
			{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
			data[{{context['HBM_AXI_PACK_SIZE'] + v}}] = HBM_channelB[offset_n + t].data[{{v}}];
			{%endfor%}	
			
			{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
			HBM_centerA[offset_c + st + t].data[{{v}}] = data[{{v}}];
			{%endfor%}
			{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
			HBM_centerB[offset_c + st + t].data[{{v}}] = data[{{context['HBM_AXI_PACK_SIZE'] + v}}];
			{%endfor%}	
			
			for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
			#pragma HLS UNROLL
				if(actvv[v].key != INVALIDDATA){ 
					totalactvvs2_tmp[v] += 1;
				}
			}
			if(inst==0){ update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___GATHER_FRONTIERINFOS___, 1); }
		}
		upartition_vertices[p_actvv_].count += nfrontier_dram___size[p_actvv_]; 
		cfrontier_dram___size[p_actvv_] += nfrontier_dram___size[p_actvv_];
	}
	for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ *totalactvvs2 += totalactvvs2_tmp[v]; }
}	

//////////////////////////////////////////////////////////////////
extern "C" {	
MY_IFDEF_TOPLEVELFUNC(){		
{%for i in context['NUM_VALID_HBM_CHANNELS_seq']%}
#pragma HLS INTERFACE m_axi port = HBM_channelA{{i}} offset = slave bundle = gmem{{2*i}}
#pragma HLS INTERFACE m_axi port = HBM_channelB{{i}} offset = slave bundle = gmem{{2*i+1}}
{%endfor%}
#pragma HLS INTERFACE m_axi port = HBM_centerA offset = slave bundle = gmem{{2*context['NUM_VALID_HBM_CHANNELS']}}
#pragma HLS INTERFACE m_axi port = HBM_centerB offset = slave bundle = gmem{{2*context['NUM_VALID_HBM_CHANNELS']+1}}

{%for i in context['NUM_VALID_HBM_CHANNELS_seq']%}
#pragma HLS INTERFACE s_axilite port = HBM_channelA{{i}}
#pragma HLS INTERFACE s_axilite port = HBM_channelB{{i}}
{%endfor%}	
#pragma HLS INTERFACE s_axilite port = HBM_centerA
#pragma HLS INTERFACE s_axilite port = HBM_centerB

#pragma HLS INTERFACE s_axilite port = module
#pragma HLS INTERFACE s_axilite port = start_pu 
#pragma HLS INTERFACE s_axilite port = size_pu
#pragma HLS INTERFACE s_axilite port = start_pv
#pragma HLS INTERFACE s_axilite port = size_pv
#pragma HLS INTERFACE s_axilite port = start_llpset
#pragma HLS INTERFACE s_axilite port = size_llpset
#pragma HLS INTERFACE s_axilite port = start_llpid
#pragma HLS INTERFACE s_axilite port = size_llpid
#pragma HLS INTERFACE s_axilite port = start_gv
#pragma HLS INTERFACE s_axilite port = size_gv
#pragma HLS INTERFACE s_axilite port = finish
#pragma HLS INTERFACE s_axilite port = return

	#ifdef _DEBUGMODE_KERNELPRINTS4
	if(finish == 1) { cout<<"acts_kernel::run:: acts started "<<endl; }
	#endif 
	
	// commands from host
	action_t action;
	action.module = module; 
	action.start_pu = start_pu; 
	action.size_pu = size_pu; 
	action.start_pv = start_pv;
	action.size_pv = size_pv; 
	action.start_llpset = start_llpset; 
	action.size_llpset = size_llpset; 
	action.start_llpid = start_llpid; 
	action.size_llpid = size_llpid; 
	action.start_gv = start_gv; 
	action.size_gv = size_gv;
	action.finish = finish;
	
	// declare BRAM variables
	{% include '___ENABLE___DECLARATIONS___.template' %}	
	
	// initialize variables 
	{% include '___ENABLE___INITIALIZE___.template' %}		
	
	// reset buffers at start
	if(___ENABLE___RESETBUFFERSATSTART___BOOL___ == 1){
		#ifdef ___ENABLE___RESETBUFFERSATSTART___
		{% include '___ENABLE___RESETBUFFERSATSTART___.template' %}		
		#endif 
	}
	
	// load vertex-updates map 
	LOAD_UPDATEPTRS_lOOP1: for(unsigned int t=0; t<globalparams[GLOBALPARAMSCODE__PARAM__NUM_APPLYPARTITIONS]+1; t++){	
	#pragma HLS PIPELINE II=1
		updatesptrs[t] = load_vupdate_map(globalparams[GLOBALPARAMSCODE__BASEOFFSET__UPDATESPTRS], t, {% include '___HBM___ARGS___.template' %});
		if(action.finish == 2){ updatesptrs[t].size = 0; }
		#ifdef _DEBUGMODE_KERNELPRINTS//4
		cout<<"start: updatesptrs["<<t<<"].offset: "<<updatesptrs[t].offset<<", updatesptrs["<<t<<"].size: "<<updatesptrs[t].size<<endl;
		#endif 
	}
	
	// prepare edge updates into actpack format	
	if(___ENABLE___PREPAREEDGEUPDATES___BOOL___ == 1){
		#ifdef ___ENABLE___DYNAMICGRAPHANALYTICS___ 
		{% include '___ENABLE___PREPARE_EDGEUPDATES___.template' %}		
		#endif 
	}
	// return; // REMOVEME.
	
	// run acts 
	RUN_ACTS_LOOP1: for(unsigned int run=0; run<globalparams[GLOBALPARAMSCODE__PARAM__NUM_RUNS]; run++){
	RUN_ACTS_LOOP1B: for(unsigned int GraphIter=0; GraphIter<globalparams[GLOBALPARAMSCODE__PARAM__NUM_ITERATIONS]; GraphIter++){
		#ifdef _DEBUGMODE_KERNELPRINTS4 
		if(action.finish == 1){ cout<<"### processing [run "<<run<<", graph iteration "<<GraphIter<<"]..."<<endl; }
		if(false){ cout<<"### processing action [module "<<action.module<<", start_pu "<<action.start_pu<<", size_pu "<<action.size_pu<<", start_pv "<<action.start_pv<<", size_pv "<<action.size_pv<<", start_llpset "<<action.start_llpset<<", size_llpset "<<action.size_llpset<<", start_llpid "<<action.start_llpid<<", size_llpid "<<action.size_llpid<<"]"<<endl; }
		#endif 
			
		unsigned int MASK_CODE = 1 + GraphIter;
		unsigned int MASK_CODE_PE = 1 + GraphIter;
		unsigned int MASK_CODE_AU = 4094 + 1 + GraphIter;
		
		// capture sparsity distribution for sssp, bfs
		{% include '___ENABLE___CAPTUREACTVVS___.template' %}	
		
		// clear counters
		#ifdef ___ENABLE___CLEAR_COUNTERS___
		{% include '___ENABLE___CLEAR_COUNTERS___.template' %}	
		#endif 
		
		// insert/delete/update edges
		#ifdef ___ENABLE___DYNAMICGRAPHANALYTICS___
		if(___ENABLE___PROCESSEDGEUPDATES___BOOL___ == 1){
			
			{% include '___ENABLE___PROCESS_EDGEUPDATES___.template' %}	
			
			/* {% include '___ENABLE___PROCESS_EDGEUPDATES___2222222.template' %}	 */
			
		}
		#endif
		// exit(EXIT_SUCCESS);
		
		// process-edges and partition-updates
		#ifdef ___ENABLE___PROCESSEDGES___
		if(action.module == PROCESS_EDGES_MODULE || action.module == ALL_MODULES){
		PROCESS_EDGES_MODULE_LOOP1B: for(unsigned int p_u=action.start_pu; p_u<action.start_pu + action.size_pu; p_u++){ 
			MASK_CODE_PE = ((1 + GraphIter) * MAX_NUM_UPARTITIONS) + p_u;
			#ifdef _DEBUGMODE_KERNELPRINTS//4 
			cout<<"### processing edges in upartition "<<p_u<<": [PEs "; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<n<<", "; } cout<<"]"<<endl; 
			#endif 
			
			// read & map frontier properties 
			#ifdef ___ENABLE___READ_FRONTIER_PROPERTIES___
			if(___ENABLE___READ_FRONTIER_PROPERTIES___BOOL___ == 1){ 
			{% include '___ENABLE___READ_FRONTIER_PROPERTIES___.template' %}	
			}
			#endif 
			
			// reset buffers [done]
			#ifdef ___ENABLE___RESET_BUFFERS___
			{% include '___ENABLE___RESET_BUFFERS___.template' %}	
			#endif 
	
			// process-edges and partition-updates
			#ifdef ___ENABLE___ECPROCESSEDGES___II1___
			if(___ENABLE___ECPROCESSEDGES___BOOL___ == 1){
				{% include '___ENABLE___PROCESS_EDGES___.template' %}	
			}
			#endif
		}
		}
		#endif 
		
		// prepare active destID stats [done] 
		#ifdef ___ENABLE___COLLECTACTIVEDSTVIDS___
		if(___ENABLE___COLLECTACTIVEDSTVIDS___BOOL___ == 1){
			{% include '___ENABLE___COLLECTACTIVEDSTVIDS___.template' %}	
		}
		#endif 
		
		unsigned int totalactvvs2 = 0; 
		frontier_t actvv[EDGE_PACK_SIZE]; 
		MY_LOOP311: for(unsigned int p_u=0; p_u<__NUM_UPARTITIONS; p_u++){ upartition_vertices[p_u].count = 0; }
		MY_LOOP312: for(unsigned int p_u=0; p_u<__NUM_UPARTITIONS; p_u++){ cfrontier_dram___size[p_u] = 0; } // reset

		// apply updates 
		#ifdef ___ENABLE___APPLYUPDATESMODULE___
		if(action.module == APPLY_UPDATES_MODULE || action.module == APPLY_UPDATES_MODULE___AND___GATHER_DSTPROPERTIES_MODULE || action.module == ALL_MODULES){
		APPLY_UPDATES_MODULE_LOOP: for(unsigned int p_v=action.start_pv; p_v<action.start_pv + action.size_pv; p_v++){
			#ifndef FPGA_IMPL
			checkoutofbounds("acts_kernel::ERROR 862::", p_v, __NUM_APPLYPARTITIONS, p_v, __NUM_APPLYPARTITIONS, NAp);
			#endif 
			bool en = true; if(enable___collectactivedstvids == true){ if(vpartition_vertices[0][p_v].count > 0){ en=true; } else { en=false; }} else { en = true; }
			unsigned int voffset = globalparams[GLOBALPARAMSCODE__BASEOFFSET__VDATAS] + (p_v * MAX_APPLYPARTITION_VECSIZE);
			#ifdef _DEBUGMODE_KERNELPRINTS
			cout<<"APPLY_UPDATES_MODULE_LOOP: vpartition_vertices[0]["<<p_v<<"].count: "<<vpartition_vertices[0][p_v].count<<" "<<endl;
			#endif 
			
			if(vpartition_vertices[0][p_v].count > 0 || all_vertices_active_in_all_iterations == true){ 
				#ifdef _DEBUGMODE_KERNELPRINTS4
				if(en == true){ cout<<"### applying updates in vpartition "<<p_v<<"..."<<endl; }
				#endif
			
				// read destination properties
				#ifdef ___ENABLE___READ_DEST_PROPERTIES___
				if(___ENABLE___READ_DEST_PROPERTIES___BOOL___ == 1){
					{% include '___ENABLE___READ_DEST_PROPERTIES___.template' %}	
				}
				#endif 
				
				// apply updates [done]
				#ifdef ___ENABLE___APPLYUPDATES___II1___ 
				if(___ENABLE___APPLYUPDATES___BOOL___ == 1){
					{% include '___ENABLE___APPLYUPDATES___.template' %}	 
				}
				#endif 
				
				// collect and save frontier information
				#ifdef ___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___
				if(___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___BOOL___ == 1){
					{% include '___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___.template' %}	
				}
				#endif 
				
				// save destination properties
				#ifdef ___ENABLE___SAVE_DEST_PROPERTIES___
				if(___ENABLE___SAVE_DEST_PROPERTIES___BOOL___ == 1){	
					{% include '___ENABLE___SAVE_DEST_PROPERTIES___.template' %}	
				}
				#endif 
			}
		} 
		}
		#endif 
		
		// transport dest to center and ddr (for export to remote fpga)
		#ifdef ___ENABLE___GATHER_FRONTIERINFOS___
		if(action.module == GATHER_DSTPROPERTIES_MODULE || action.module == APPLY_UPDATES_MODULE___AND___GATHER_DSTPROPERTIES_MODULE || action.module == ALL_MODULES){
		GATHER_FRONTIERS_MODULE_LOOP: for(unsigned int p_v=action.start_pv; p_v<action.start_pv + action.size_pv; p_v++){		
			if(___ENABLE___EXCHANGEFRONTIERINFOS___BOOL___ == 1){
				{% include '___ENABLE___GATHER_FRONTIERINFOS___.template' %}	
			}
		}
		}
		#endif
		
		#ifdef ___ENABLE___REPORT_STATISTICS___
		{% include '___ENABLE___REPORT_STATISTICS___.template' %}	
		#endif 
		
		{% include '___ENABLE___FINISH___.template' %}	
	} // NUM_ITs
	}

	// save updates ptrs
	if(action.module == PROCESS_EDGES_MODULE || action.module == ALL_MODULES){
		LOAD_UPDATEPTRS_lOOP2: for(unsigned int t=0; t<globalparams[GLOBALPARAMSCODE__PARAM__NUM_APPLYPARTITIONS]; t++){	
		// #pragma HLS PIPELINE II=1
			save_vupdate_map(globalparams[GLOBALPARAMSCODE__BASEOFFSET__UPDATESPTRS], t, updatesptrs[t], {% include '___HBM___ARGS___.template' %});
			#ifdef _DEBUGMODE_KERNELPRINTS//4
			cout<<"finish: updatesptrs["<<t<<"].offset: "<<updatesptrs[t].offset<<", updatesptrs["<<t<<"].size: "<<updatesptrs[t].size<<endl;
			#endif 
		}
	}
	
	// report result
	#ifdef _DEBUGMODE_CHECKS3
	if(action.finish == 1){
		{% include '___ENABLE___SUMMARY___.template' %}	
	}
	#endif
	return;
}
}
