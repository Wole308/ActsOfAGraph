#define ___ENABLE___RESETBUFFERSATSTART___ 
#define ___ENABLE___CLEAR_COUNTERS___
#define ___ENABLE___PROCESSEDGES___ 
#define ___ENABLE___READ_FRONTIER_PROPERTIES___
#define ___ENABLE___RESET_BUFFERS___
#define ___ENABLE___ECPROCESSEDGES___II1___ 
// // // // // // // // // // // // // // // // // // #define ___ENABLE___COLLECTACTIVEDSTVIDS___ 
#define ___ENABLE___APPLYUPDATESMODULE___ 
	#define ___ENABLE___READ_DEST_PROPERTIES___ 
	#define ___ENABLE___APPLYUPDATES___II1___
	#define ___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___ 
	#define ___ENABLE___SAVE_DEST_PROPERTIES___ 
#define ___ENABLE___GATHER_FRONTIERINFOS___ 
#define ___ENABLE___REPORT_STATISTICS___
#define _____DEBUG_____	

#define MAXVALID_APPLYPARTITION_VECSIZE (MAX_APPLYPARTITION_VECSIZE >> POW_VALID_VDATA)

#ifdef ___RUNNING_FPGA_SYNTHESIS___ // FPGA_IMPL
#define MY_IFDEF_NFRONTIER() keyvalue_t nfrontier_buffer[EDGE_PACK_SIZE][VDATA_SUBPARTITION_VECSIZE]
#define MY_IFDEF_CFRONTIER_TMP() keyvalue_t URAM_frontiers[EDGE_PACK_SIZE][MAXVALID_APPLYPARTITION_VECSIZE]
#define MY_IFDEF_CFRONTIER() keyvalue_t cfrontier_buffer[NUM_VALID_PEs][MAXVALID_APPLYPARTITION_VECSIZE]
#define MY_IFDEF_STATSBUFFERMASKBASED_TMP() unsigned int statsbuffer_maskbased_tmp[EDGE_PACK_SIZE][BLOCKRAM_SIZE]	
#define MY_IFDEF_STATSBUFFERMASKBASED() unsigned int statsbuffer_maskbased[MAX_NUM_APPLYPARTITIONS][BLOCKRAM_SIZE]	
#define MY_IFDEF_STATSBUFFERIDBASED() unsigned int statsbuffer_idbased[MAX_NUM_APPLYPARTITIONS][BLOCKRAM_SIZE]	
#define MY_IFDEF_UPDATESTMPBUFFER() keyvalue_t updates_buffer2[UPDATES_BUFFER_PACK_SIZE][UPDATES_BUFFER_SIZE]	
#define MY_IFDEF_VPTRBUFFER() vtr_t vptr_buffer[VPTR_BUFFER_SIZE]
#define MY_IFDEF_EDGESBUFFER() edge3_type edges_buffer[EDGE_PACK_SIZE][EDGE_BUFFER_SIZE]
#define MY_IFDEF_EDGEUPDATESBUFFER() edge_update_type URAM_edges[EDGE_PACK_SIZE][EDGE_UPDATES_DRAMBUFFER_SIZE]
#define MY_IFDEF_VDATABUFFER() vprop_t URAM_vprop[EDGE_PACK_SIZE][MAXVALID_APPLYPARTITION_VECSIZE]
#define MY_IFDEF_TOPLEVELFUNC() void top_function({% include '___HBM___PARAMS___.template' %}, HBM_channelAXI_t * HBM_centerA, HBM_channelAXI_t * HBM_centerB, \
	HBM_channelAXI_t * HBM_import, HBM_channelAXI_t * HBM_export, \
	checkpoint_t * HBM_import_chkpt, checkpoint_t * HBM_export_chkpt, \
	unsigned int fpga, unsigned int module, unsigned int graph_iteration, unsigned int start_pu, unsigned int size_pu, unsigned int skip_pu, unsigned int start_pv, unsigned int size_pv, unsigned int start_llpset, unsigned int size_llpset, unsigned int start_llpid, unsigned int size_llpid, unsigned int start_gv, unsigned int size_gv, unsigned int id_import ,unsigned int id_export, unsigned int size_import_export, unsigned int status)
#else
#define MY_IFDEF_NFRONTIER() keyvalue_t * nfrontier_buffer[EDGE_PACK_SIZE]
#define MY_IFDEF_CFRONTIER_TMP() keyvalue_t * URAM_frontiers[EDGE_PACK_SIZE]
#define MY_IFDEF_CFRONTIER() keyvalue_t * cfrontier_buffer[NUM_VALID_PEs]
#define MY_IFDEF_STATSBUFFERMASKBASED_TMP() unsigned int * statsbuffer_maskbased_tmp[EDGE_PACK_SIZE]
#define MY_IFDEF_STATSBUFFERMASKBASED() unsigned int * statsbuffer_maskbased[MAX_NUM_APPLYPARTITIONS]
#define MY_IFDEF_STATSBUFFERIDBASED() unsigned int * statsbuffer_idbased[MAX_NUM_APPLYPARTITIONS]
#define MY_IFDEF_UPDATESTMPBUFFER() keyvalue_t * updates_buffer2[UPDATES_BUFFER_PACK_SIZE]
#define MY_IFDEF_VPTRBUFFER() vtr_t * vptr_buffer
#define MY_IFDEF_EDGESBUFFER() edge3_type * edges_buffer[EDGE_PACK_SIZE]
#define MY_IFDEF_EDGEUPDATESBUFFER() edge_update_type * URAM_edges[EDGE_PACK_SIZE]
#define MY_IFDEF_VDATABUFFER() vprop_t * URAM_vprop[EDGE_PACK_SIZE]
#define MY_IFDEF_TOPLEVELFUNC() unsigned int acts_kernel::top_function({% include '___HBM___PARAMS___.template' %}, HBM_channelAXI_t * HBM_centerA, HBM_channelAXI_t * HBM_centerB, \
	HBM_channelAXI_t * HBM_import, HBM_channelAXI_t * HBM_export, \
	checkpoint_t * HBM_import_chkpt, checkpoint_t * HBM_export_chkpt, \
	unsigned int fpga, unsigned int module, unsigned int graph_iteration, unsigned int start_pu, unsigned int size_pu, unsigned int skip_pu, unsigned int start_pv, unsigned int size_pv, unsigned int start_llpset, unsigned int size_llpset, unsigned int start_llpid, unsigned int size_llpid, unsigned int start_gv, unsigned int size_gv, unsigned int id_import ,unsigned int id_export, unsigned int size_import_export, unsigned int status, \
	vector<edge3_type> (&final_edge_updates)[NUM_PEs][MAX_NUM_UPARTITIONS][MAX_NUM_LLPSETS], unsigned int report_statistics[64])					
#endif

#define APPLY_CMD 2
#define TRANSPORT_CMD 3

#ifndef ___RUNNING_FPGA_SYNTHESIS___ // FPGA_IMPL
unsigned int * globalparams_debug;
// unsigned int _NUMCLOCKCYCLES_[2][32]; 
#endif 

#ifndef ___RUNNING_FPGA_SYNTHESIS___ // FPGA_IMPL 
acts_kernel::acts_kernel(universalparams_t _universalparams){
	utilityobj = new utility(_universalparams);
	universalparams = _universalparams;
	algorithmobj = new algorithm();
}
acts_kernel::~acts_kernel(){} 
#endif 

{% include '___ENABLE___UTILFUNCS___.template' %}	

{% include '___ENABLE___ACCESSHBM___.template' %}	

{% include '___ENABLE___ACCESSBRAM___.template' %}		

#ifndef ___RUNNING_FPGA_SYNTHESIS___
{% include '___ENABLE___CREATE_ACTPACK___.template' %}
#endif 

void import_frontiers(unsigned int chunk, HBM_channelAXI_t * HBM_centerA, HBM_channelAXI_t * HBM_import, action_t action, unsigned int _NUMCLOCKCYCLES_[2][32]){
	#ifdef _DEBUGMODE_KERNELPRINTS4
	cout<<"acts_kernel::run:: importing "<<action.size_import_export<<" 32bit-integers (Host -> FPGA)..."<<endl;
	#endif 
	unsigned int offset_c = 0 * chunk; // FIXME
	IMPORT_LOOP1: for(unsigned int t=0; t<action.size_import_export; t++){ 
	#pragma HLS PIPELINE II={{context['II_TRANSPORT_FRONTIER_PROPERTIES_LOOP1B']}}
		// import (Host -> FPGA)
		{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
		HBM_centerA[offset_c + t].data[{{v}}] = HBM_import[t].data[{{v}}];
		{%endfor%}	
	}
}	

void export_frontiers(unsigned int chunk, HBM_channelAXI_t * HBM_centerA, HBM_channelAXI_t * HBM_export, action_t action, unsigned int _NUMCLOCKCYCLES_[2][32]){	
	#ifdef _DEBUGMODE_KERNELPRINTS4
	cout<<"acts_kernel::run:: exporting "<<action.size_import_export<<" 32bit-integers (FPGA -> Host)..."<<endl;
	#endif 
	unsigned int offset_c = 0 * chunk; // FIXME
	EXPORT_LOOP1: for(unsigned int t=0; t<action.size_import_export; t++){ 
	#pragma HLS PIPELINE II={{context['II_TRANSPORT_FRONTIER_PROPERTIES_LOOP1B']}}
		// export (FPGA -> Host)
		{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
		HBM_export[t].data[{{v}}] = HBM_centerA[offset_c + t].data[{{v}}];
		{%endfor%}	
	}
}	

void gather_frontiers(unsigned int inst, unsigned int p_v, unsigned int * cfrontier_dram___size, unsigned int * nfrontier_dram___size, offset_t * upartition_vertices, HBM_channelAXI_t * HBM_channelA, HBM_channelAXI_t * HBM_channelB, HBM_channelAXI_t * HBM_centerA, HBM_channelAXI_t * HBM_centerB, unsigned int globalparams[GLOBALBUFFER_SIZE], unsigned int _NUMCLOCKCYCLES_[2][32]){	
	GATHER_FRONTIERS_LOOP1: for(unsigned int local_subpartitionID=0; local_subpartitionID<NUM_SUBPARTITION_PER_PARTITION; local_subpartitionID++){
		unsigned int upartitionID = (p_v * NUM_SUBPARTITION_PER_PARTITION) + local_subpartitionID; // w.r.t. a given hbm (corresponds to number of upartitions)
		unsigned int offset_centerhbm = (upartitionID * MAX_UPARTITION_VECSIZE); 
		unsigned int offset_channelhbm = globalparams[GLOBALPARAMSCODE__BASEOFFSET__NFRONTIERS] + (upartitionID * VDATA_SUBPARTITION_VECSIZE);
		
		GATHER_FRONTIERS_LOOP1B: for(unsigned int t=0; t<nfrontier_dram___size[upartitionID]; t++){
		#pragma HLS PIPELINE II={{context['II_TRANSPORT_FRONTIER_PROPERTIES_LOOP1B']}}
			{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
			HBM_centerA[offset_centerhbm + t].data[{{v}}] = HBM_channelA[offset_channelhbm + t].data[{{v}}];
			{%endfor%}
			{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
			HBM_centerB[offset_centerhbm + t].data[{{v}}] = HBM_channelB[offset_channelhbm + t].data[{{v}}];
			{%endfor%}	
			if(inst==0){ update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___GATHER_FRONTIERINFOS___, 1); }
		}
		
		upartition_vertices[upartitionID].count += nfrontier_dram___size[upartitionID]; 
		cfrontier_dram___size[upartitionID] += nfrontier_dram___size[upartitionID];
		// cout<<"--- gather_frontiers ------------------------- _NUMCLOCKCYCLES_[0][___CODE___GATHER_FRONTIERINFOS___]: "<<_NUMCLOCKCYCLES_[0][___CODE___GATHER_FRONTIERINFOS___]<<", NUM_SUBPARTITION_PER_PARTITION: "<<NUM_SUBPARTITION_PER_PARTITION<<", VDATA_SUBPARTITION_VECSIZE: "<<VDATA_SUBPARTITION_VECSIZE<<", local_subpartitionID: "<<local_subpartitionID<<", cfrontier_dram___size["<<upartitionID<<"]: "<<cfrontier_dram___size[upartitionID]<<endl;
	}
	return;
}	

extern "C" {	
MY_IFDEF_TOPLEVELFUNC(){		
{%for i in context['NUM_VALID_HBM_CHANNELS_seq']%}
#pragma HLS INTERFACE m_axi port = HBM_channelA{{i}} offset = slave bundle = gmem{{2*i}}
#pragma HLS INTERFACE m_axi port = HBM_channelB{{i}} offset = slave bundle = gmem{{2*i+1}}
{%endfor%}
#pragma HLS INTERFACE m_axi port = HBM_centerA offset = slave bundle = gmem{{2*context['NUM_VALID_HBM_CHANNELS']}}
#pragma HLS INTERFACE m_axi port = HBM_centerB offset = slave bundle = gmem{{2*context['NUM_VALID_HBM_CHANNELS']+1}}
#pragma HLS INTERFACE m_axi port = HBM_import offset = slave bundle = gmem{{2*context['NUM_VALID_HBM_CHANNELS']+2}}
#pragma HLS INTERFACE m_axi port = HBM_export offset = slave bundle = gmem{{2*context['NUM_VALID_HBM_CHANNELS']+3}}
#pragma HLS INTERFACE m_axi port = HBM_import_chkpt offset = slave bundle = gmem{{2*context['NUM_VALID_HBM_CHANNELS']+4}}
#pragma HLS INTERFACE m_axi port = HBM_export_chkpt offset = slave bundle = gmem{{2*context['NUM_VALID_HBM_CHANNELS']+4}}

{%for i in context['NUM_VALID_HBM_CHANNELS_seq']%}
#pragma HLS INTERFACE s_axilite port = HBM_channelA{{i}}
#pragma HLS INTERFACE s_axilite port = HBM_channelB{{i}}
{%endfor%}	
#pragma HLS INTERFACE s_axilite port = HBM_centerA
#pragma HLS INTERFACE s_axilite port = HBM_centerB
#pragma HLS INTERFACE s_axilite port = HBM_import
#pragma HLS INTERFACE s_axilite port = HBM_export
#pragma HLS INTERFACE s_axilite port = HBM_import_chkpt
#pragma HLS INTERFACE s_axilite port = HBM_export_chkpt

#pragma HLS INTERFACE s_axilite port = fpga
#pragma HLS INTERFACE s_axilite port = module
#pragma HLS INTERFACE s_axilite port = graph_iteration
#pragma HLS INTERFACE s_axilite port = start_pu 
#pragma HLS INTERFACE s_axilite port = size_pu
#pragma HLS INTERFACE s_axilite port = skip_pu
#pragma HLS INTERFACE s_axilite port = start_pv
#pragma HLS INTERFACE s_axilite port = size_pv
#pragma HLS INTERFACE s_axilite port = start_llpset
#pragma HLS INTERFACE s_axilite port = size_llpset
#pragma HLS INTERFACE s_axilite port = start_llpid
#pragma HLS INTERFACE s_axilite port = size_llpid
#pragma HLS INTERFACE s_axilite port = start_gv
#pragma HLS INTERFACE s_axilite port = size_gv
#pragma HLS INTERFACE s_axilite port = id_import
#pragma HLS INTERFACE s_axilite port = id_export
#pragma HLS INTERFACE s_axilite port = size_import_export
#pragma HLS INTERFACE s_axilite port = status
#pragma HLS INTERFACE s_axilite port = return

	#ifndef ___RUNNING_FPGA_SYNTHESIS___
	#ifdef ___ENABLE___DYNAMICGRAPHANALYTICS___
	if(status == 1 || true) { cout<<"acts_kernel::run:: dynamic acts started: start_pu: "<<start_pu<<", size_pu: "<<size_pu<<", skip_pu: "<<skip_pu<<", start_pv: "<<start_pv<<", size_pv: "<<size_pv<<endl; }
	#else 
	if(status == 1 || true) { cout<<"acts_kernel::run:: acts started: start_pu: "<<start_pu<<", size_pu: "<<size_pu<<", skip_pu: "<<skip_pu<<", start_pv: "<<start_pv<<", size_pv: "<<size_pv<<endl; }	
	#endif 
	#endif 
	
	// commands from host
	action_t action;
	action.fpga = fpga; 
	action.module = module; 
	action.graph_iteration = graph_iteration; 
	action.start_pu = start_pu; 
	action.size_pu = size_pu; 
	action.skip_pu = skip_pu; 
	action.start_pv = start_pv;
	action.size_pv = size_pv; 
	action.start_llpset = start_llpset; 
	action.size_llpset = size_llpset; 
	action.start_llpid = start_llpid; 
	action.size_llpid = size_llpid; 
	action.start_gv = start_gv; 
	action.size_gv = size_gv;
	action.id_import = id_import;
	action.id_export = id_export;
	action.size_import_export = size_import_export;
	action.status = status;
	
	// declarations
	{% include '___ENABLE___DECLARATIONS___.template' %}	
	
	// initialize variables 
	{% include '___ENABLE___INITIALIZE___.template' %}	

	// resets
	if(___ENABLE___RESETBUFFERSATSTART___BOOL___ == 1){
		#ifdef ___ENABLE___RESETBUFFERSATSTART___
		{% include '___ENABLE___RESETBUFFERSATSTART___.template' %}		
		#endif 
	}
	
	// load vertex-updates map 
	LOAD_UPDATEPTRS_lOOP1: for(unsigned int fpga=0; fpga<NUM_FPGAS; fpga++){
		#ifdef _DEBUGMODE_KERNELPRINTS4
		if(action.module == ALL_MODULES){ cout<<"acts: offsets for fpga "<<fpga<<endl; }
		#endif 
		LOAD_UPDATEPTRS_lOOP1B: for(unsigned int t=0; t<globalparams[GLOBALPARAMSCODE__PARAM__NUM_APPLYPARTITIONS]; t++){	
		#pragma HLS PIPELINE II=1
			updatesptrs[fpga][t] = load_vupdate_map(globalparams[GLOBALPARAMSCODE__BASEOFFSET__UPDATESPTRS], (fpga * MAX_NUM_LLPSETS) + t, {% include '___HBM___ARGS___.template' %});	
			if((action.module == ALL_MODULES || action.module == PROCESS_EDGES_MODULE) && action.start_pu == 0){ updatesptrs[fpga][t].size = 0; }		
			#ifdef _DEBUGMODE_KERNELPRINTS4
			if(action.module == ALL_MODULES){ cout<<"acts: updatesptrs["<<fpga<<"]["<<t<<"].offset: "<<updatesptrs[fpga][t].offset<<", updatesptrs["<<fpga<<"]["<<t<<"].size: "<<updatesptrs[fpga][t].size<<endl; }
			#endif 
		}
	}
	
	// turn raw edges into actpact format
	if(___ENABLE___PREPAREEDGEUPDATES___BOOL___ == 1 && action.module == PREPROCESSING_MODULE){
		#ifndef ___RUNNING_FPGA_SYNTHESIS___
		edge_update_type * URAM_edges[NUM_VALID_PEs][EDGE_PACK_SIZE];
		for(unsigned int i=0; i<NUM_VALID_PEs; i++){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ URAM_edges[i][v] = new edge_update_type[EDGE_UPDATES_DRAMBUFFER_LONGSIZE]; }}
		if(globalparams[GLOBALPARAMSCODE__COMMANDS__COMMAND0] == 0){ 
			return create_actpack(action, globalparams[GLOBALPARAMSCODE__BASEOFFSET__ACTPACKEDGES], globalparams[GLOBALPARAMSCODE__BASEOFFSET__ACTPACKVPTRS2], URAM_edges, EDGE_UPDATES_DRAMBUFFER_LONGSIZE, EDGE_UPDATES_DRAMBUFFER_LONGSIZE, globalparams, {% include '___HBM___ARGS___.template' %}, final_edge_updates, _NUMCLOCKCYCLES_);		
		} else if(globalparams[GLOBALPARAMSCODE__COMMANDS__COMMAND0] == 1){	
			return create_actpack(action, globalparams[GLOBALPARAMSCODE__BASEOFFSET__EDGEUPDATES], globalparams[GLOBALPARAMSCODE__BASEOFFSET__EDGEUPDATESPTRS], URAM_edges, EDGE_UPDATES_DRAMBUFFER_SIZE, EDGE_UPDATES_WORKBUFFER_SIZE, globalparams, {% include '___HBM___ARGS___.template' %}, final_edge_updates, _NUMCLOCKCYCLES_);	
		}
		#endif
	}
	
	// run acts 
	RUN_ACTS_LOOP1: for(unsigned int run=0; run<globalparams[GLOBALPARAMSCODE__PARAM__NUM_RUNS]; run++){
		RUN_ACTS_LOOP1B: for(unsigned int GraphIter=0; GraphIter<globalparams[GLOBALPARAMSCODE__PARAM__NUM_ITERATIONS]; GraphIter++){
			#ifdef _DEBUGMODE_KERNELPRINTS4 
			if(action.status == 1){ cout<<"### processing [run "<<run<<", graph iteration "<<GraphIter<<"]..."<<endl; }
			if(false){ cout<<"### processing action [module "<<action.module<<", start_pu "<<action.start_pu<<", size_pu "<<action.size_pu<<", start_pv "<<action.start_pv<<", size_pv "<<action.size_pv<<", start_llpset "<<action.start_llpset<<", size_llpset "<<action.size_llpset<<", start_llpid "<<action.start_llpid<<", size_llpid "<<action.size_llpid<<"]"<<endl; }
			#endif 
				
			unsigned int MASK_CODE = 1 + GraphIter;
			unsigned int MASK_CODE_PE = 1 + GraphIter;
			unsigned int MASK_CODE_AU = 4094 + 1 + GraphIter;
			
			// capture sparsity distribution for sssp, bfs
			{% include '___ENABLE___CAPTUREACTVVS___.template' %}	
			
			// clear counters
			#ifdef ___ENABLE___CLEAR_COUNTERS___
			{% include '___ENABLE___CLEAR_COUNTERS___.template' %}	
			#endif
			
			// process-edges and partition-updates
			#ifdef ___ENABLE___PROCESSEDGES___
			if(action.module == PROCESS_EDGES_MODULE || action.module == ALL_MODULES){
			PROCESS_EDGES_MODULE_LOOP1B: for(unsigned int p_u=action.start_pu; p_u<action.start_pu + action.size_pu; p_u+=action.skip_pu){ 
			// PROCESS_EDGES_MODULE_LOOP1B: for(unsigned int p_u=0; p_u<globalparams[GLOBALPARAMSCODE__PARAM__NUM_UPARTITIONS]; p_u+=1){ // FIXME.
				MASK_CODE_PE = ((1 + GraphIter) * MAX_NUM_UPARTITIONS) + p_u;
				#ifdef _DEBUGMODE_KERNELPRINTS//4 
				cout<<"$$$ processing edges in upartition "<<p_u<<": [PEs "; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<n<<", "; } cout<<"]"<<endl; 
				#endif 
				
				// insert/delete/update edges
				#ifdef ___ENABLE___DYNAMICGRAPHANALYTICS___
				if(___ENABLE___PROCESSEDGEUPDATES___BOOL___ == 1){	
					{% include '___ENABLE___APPLY_EDGEUPDATES___.template' %}		
				}	
				#endif	
				// exit(EXIT_SUCCESS);
				
				// read & map frontier properties 
				#ifdef ___ENABLE___READ_FRONTIER_PROPERTIES___
				if(___ENABLE___READ_FRONTIER_PROPERTIES___BOOL___ == 1){ 
				{% include '___ENABLE___READ_FRONTIERS___.template' %}	
				}
				#endif
				
				#ifdef _DEBUGMODE_KERNELPRINTS4	
				if(action.id_import != INVALIDDATA){ cout<< TIMINGRESULTSCOLOR << "<-- exporting vpartition: "<<action.id_import<<"..."<< RESET <<endl; }	 
				if(action.id_export != INVALIDDATA){ cout<< TIMINGRESULTSCOLOR << "--> importing upartition: "<<action.id_export<<"..."<< RESET <<endl; }	
				#endif 
				
				// process-edges and partition-updates
				#ifdef ___ENABLE___ECPROCESSEDGES___II1___		
				if(___ENABLE___PROCESSEDGES___BOOL___ == 1){ 
					{% include '___ENABLE___PROCESS2_EDGES___.template' %}		
				}
				#endif
			}
			}
			#endif 
			// exit(EXIT_SUCCESS); 
			
			// prepare active destID stats [done] 
			#ifdef ___ENABLE___COLLECTACTIVEDSTVIDS___
			if(___ENABLE___COLLECTACTIVEDSTVIDS___BOOL___ == 1){
				{% include '___ENABLE___COLLECTACTIVEDSTVIDS___.template' %}	
			}
			#endif 
			
			unsigned int totalactvvs2 = 0; 
			frontier_t actvv[EDGE_PACK_SIZE]; 
			for(unsigned int p_u=0; p_u<globalparams[GLOBALPARAMSCODE__PARAM__NUM_UPARTITIONS]; p_u++){ upartition_vertices[p_u].count = 0; }
			for(unsigned int p_u=0; p_u<globalparams[GLOBALPARAMSCODE__PARAM__NUM_UPARTITIONS]; p_u++){ cfrontier_dram___size[p_u] = 0; } // reset

			// apply updates 
			#ifdef ___ENABLE___APPLYUPDATESMODULE___
			if(action.module == APPLY_UPDATES_MODULE || action.module == APPLY_UPDATES_MODULE___AND___GATHER_DSTPROPERTIES_MODULE || action.module == ALL_MODULES){
			APPLY_UPDATES_MODULE_LOOP: for(unsigned int p_v=action.start_pv; p_v<action.start_pv + action.size_pv; p_v++){
				#ifndef FPGA_IMPL
				checkoutofbounds("acts_kernel::ERROR 862::", p_v, globalparams[GLOBALPARAMSCODE__PARAM__NUM_APPLYPARTITIONS], p_v, globalparams[GLOBALPARAMSCODE__PARAM__NUM_APPLYPARTITIONS], NAp);
				#endif 
				bool en = true; if(enable___collectactivedstvids == true){ if(vpartition_vertices[0][p_v].count > 0){ en=true; } else { en=false; }} else { en = true; }
				unsigned int voffset = globalparams[GLOBALPARAMSCODE__BASEOFFSET__VDATAS] + (p_v * MAX_APPLYPARTITION_VECSIZE);
				#ifdef _DEBUGMODE_KERNELPRINTS4
				cout<<"APPLY_UPDATES_MODULE_LOOP: vpartition_vertices[0]["<<p_v<<"].count: "<<vpartition_vertices[0][p_v].count<<" "<<endl;
				#endif 
				
				if(vpartition_vertices[0][p_v].count > 0 || all_vertices_active_in_all_iterations == true){ 
					// read destination properties
					#ifdef ___ENABLE___READ_DEST_PROPERTIES___
					if(___ENABLE___READ_DEST_PROPERTIES___BOOL___ == 1){
						{% include '___ENABLE___READ_DEST_PROPERTIES___.template' %}	
					}
					#endif 
					
					#ifdef _DEBUGMODE_KERNELPRINTS4
					if(action.id_import != INVALIDDATA){ cout<< TIMINGRESULTSCOLOR << "<-- exporting vpartition: "<<action.id_import<<"..."<< RESET <<endl; }	 
					if(action.id_export != INVALIDDATA){ cout<< TIMINGRESULTSCOLOR << "--> importing upartition: "<<action.id_export<<"..."<< RESET <<endl; }	
					#endif 
					
					// apply updates [done]
					#ifdef ___ENABLE___APPLYUPDATES___II1___ 
					if(___ENABLE___APPLYUPDATES___BOOL___ == 1){
						for(unsigned int fpga=0; fpga<NUM_FPGAS; fpga++){
						{% include '___ENABLE___APPLY_VERTEXUPDATES___.template' %}	
						}						
					}
					#endif 
					
					// collect and save frontier information
					#ifdef ___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___
					if(___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___BOOL___ == 1){
						{% include '___ENABLE___COLLECT_AND_SAVE_FRONTIERS___.template' %}	
					}
					#endif 
					
					// save destination properties
					#ifdef ___ENABLE___SAVE_DEST_PROPERTIES___
					if(___ENABLE___SAVE_DEST_PROPERTIES___BOOL___ == 1){	
						{% include '___ENABLE___SAVE_DEST_PROPERTIES___.template' %}	
					}
					#endif 
					
					// gather frontiers to center hbm
					#ifdef ___ENABLE___GATHER_FRONTIERINFOS___
					if(___ENABLE___EXCHANGEFRONTIERINFOS___BOOL___ == 1){	
						{%for i in context['NUM_VALID_PEs_seq']%}	
						#ifndef ___RUNNING_FPGA_SYNTHESIS___
						cout<<"### gathering dst vertex properties for vpartition "<<p_v<<": [PEs "; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<n<<", "; } cout<<"]"<<endl; 
						#endif 
						gather_frontiers({{i}}, p_v, cfrontier_dram___size, nfrontier_dram___size[{{i}}], upartition_vertices, HBM_channelA{{i}}, HBM_channelB{{i}}, HBM_centerA, HBM_centerB, globalparams, _NUMCLOCKCYCLES_);
						{%endfor%}	
					}
					#endif
				}
			} 
			}
			#endif
			
			#ifdef ___ENABLE___REPORT_STATISTICS___
			{% include '___ENABLE___REPORT_STATISTICS___.template' %}	
			#endif 
			
			{% include '___ENABLE___FINISH___.template' %}	
		} // NUM_ITs
	}
	
	// save state
	if(action.module == PROCESS_EDGES_MODULE){ //  || action.module == ALL_MODULES){
		SAVE_UPDATEPTRS_lOOP1: for(unsigned int fpga=0; fpga<NUM_FPGAS; fpga++){
			SAVE_UPDATEPTRS_lOOP2: for(unsigned int t=0; t<globalparams[GLOBALPARAMSCODE__PARAM__NUM_APPLYPARTITIONS]; t++){	
				save_vupdate_map(globalparams[GLOBALPARAMSCODE__BASEOFFSET__UPDATESPTRS], (fpga * MAX_NUM_LLPSETS) + t, updatesptrs[fpga][t], {% include '___HBM___ARGS___.template' %});
				#ifdef _DEBUGMODE_KERNELPRINTS//4
				cout<<"finish: updatesptrs["<<fpga<<"]["<<t<<"].offset: "<<updatesptrs[fpga][t].offset<<", updatesptrs["<<fpga<<"]["<<t<<"].size: "<<updatesptrs[fpga][t].size<<endl;
				#endif 
			}
		}
	}
	
	// report result
	#ifdef _DEBUGMODE_CHECKS3
	if(action.status == 1){
		{% include '___ENABLE___SUMMARY___.template' %}	
	}
	#endif	
	
	#ifdef ___RUNNING_FPGA_SYNTHESIS___
	return;
	#else 
	return 0;	
	#endif 
}
}
