// broadcast active frontiers [done]
unsigned int uoffset_vecsz = p_u * MAX_UPARTITION_VECSIZE; 
unsigned int data[HBM_CHANNEL_PACK_SIZE];
#pragma HLS ARRAY_PARTITION variable=data complete
unsigned int offset_c = globalparams[GLOBALPARAMSCODE__BASEOFFSET__CFRONTIERSTMP];

for(unsigned int n=0; n<NUM_VALID_PEs; n++){ offsets[n] = 0; }
#ifdef _DEBUGMODE_CHECKS3
checkoutofbounds("acts_kernel::ERROR 12073::", cfrontier_dram___size[p_u], MAX_APPLYPARTITION_VECSIZE+1, NAp, NAp, NAp);
#endif 

unsigned int import_offset = id_import * action.size_import_export;
unsigned int export_offset = id_export * action.size_import_export;

READ_FRONTIER_INFO_LOOP1: for(unsigned int t=0; t<cfrontier_dram___size[p_u]; t++){ 
#pragma HLS PIPELINE II=1	
	{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
	data[{{v}}] = HBM_centerA[uoffset_vecsz + t].data[{{v}}];
	{%endfor%}
	{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
	data[{{context['HBM_AXI_PACK_SIZE'] + v}}] = HBM_centerB[uoffset_vecsz + t].data[{{v}}];
	{%endfor%}
	
	{%for n in context['NUM_VALID_PEs_seq']%}
	{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
	HBM_channelA{{n}}[offset_c + t].data[{{v}}] = data[{{v}}];
	{%endfor%}
	{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
	HBM_channelB{{n}}[offset_c + t].data[{{v}}] = data[{{context['HBM_AXI_PACK_SIZE'] + v}}];
	{%endfor%}
	{%endfor%}
	
	// import (Host -> FPGA)
	if(action.id_import != INVALIDDATA && t<action.size_import_export){	
		{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
		HBM_centerA[import_offset + t].data[{{v}}] = HBM_import[t].data[{{v}}];
		{%endfor%}	
	}		
	
	// export (FPGA -> Host)
	if(action.id_export != INVALIDDATA && t<action.size_import_export){	
		{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
		HBM_export[t].data[{{v}}] = HBM_centerB[export_offset + t].data[{{v}}];
		{%endfor%}
	}
}

// parallel-read and map active frontiers [done]
MY_LOOP173: for(unsigned int n=0; n<NUM_VALID_PEs; n++){ offsets[n] = 0; }
unsigned int uoffset = p_u * MAX_UPARTITION_SIZE;
MY_LOOP175_DEBUG: for(unsigned int t=0; t<cfrontier_dram___size[p_u]; t++){ 
#pragma HLS PIPELINE II=1
	dretrievemany_cfrontierdram_tmp(globalparams[GLOBALPARAMSCODE__BASEOFFSET__CFRONTIERSTMP], offsets, t, kvdatas, {% include '___HBM___ARGS___.template' %});
	insertvec_cfrontierbuffer_tmp(t, kvdatas[0], URAM_frontiers); // NEW
	for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
	#pragma HLS UNROLL
		for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
		#pragma HLS UNROLL
			unsigned int srcvid_lpv__ = (kvdatas[inst][v].key - uoffset) >> EDGE_PACK_SIZE_POW;
			if(kvdatas[inst][v].key != INVALIDDATA && srcvid_lpv__ < MAX_UPARTITION_VECSIZE){
				unsigned int srcvid_lpv = srcvid_lpv__; 
				vprop_t tmp; tmp.prop = kvdatas[inst][v].value; tmp.degree = MASK_CODE_PE;
				insert_vdatabuffer(v, srcvid_lpv, tmp, URAM_vprop[inst]); 
			}
		}
	}
	update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___READ_FRONTIER_PROPERTIES___, 1);
}


				