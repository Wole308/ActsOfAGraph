edge_update_vec_dt edge_update_vecs[NUM_VALID_PEs];
#pragma HLS ARRAY_PARTITION variable=edge_update_vecs complete
edge3_vec_dt edge3_vecs[NUM_VALID_PEs]; 
#pragma HLS ARRAY_PARTITION variable=edge3_vecs complete

PROCESS_EDGEUPDATES_MODULE_LOOP1B: for(unsigned int p_u=0; p_u<globalparams[GLOBALPARAMSCODE__PARAM__NUM_UPARTITIONS]; p_u++){ // 1, __NUM_UPARTITIONS. REMOVEME.
	#ifdef _DEBUGMODE_KERNELPRINTS4 
	if(all_vertices_active_in_all_iterations == true){ cout<<"### inserting/deleting/updating edges in upartition "<<p_u<<": [PEs "; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<n<<", "; } cout<<"]"<<endl; }
	#endif 
	
	/* //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	for(unsigned int edge_block=0; edge_block<__NUM_APPLYPARTITIONS * NUM_LLP_PER_LLPSET; edge_block++){ // EDGE_PACK_SIZE	
		map_t edge_map_vec[NUM_VALID_PEs];
		load_edgemap_vec((p_u * MAX_NUM_LLP_PER_UPARTITION) + edge_block, globalparams[GLOBALPARAMSCODE__BASEOFFSET__ACTPACKVPTRS2], edge_map_vec, {% include '___HBM___ARGS___.template' %});
		for(unsigned int n=0; n<NUM_VALID_PEs; n++){
		#pragma HLS UNROLL
			edge_map[n] = edge_map_vec[n];
		}
		
		for(unsigned int n=0; n<NUM_VALID_PEs; n++){
		#pragma HLS UNROLL
			edge_maps[n][edge_block] = edge_map[n];
		}
	}
	
	// load maps 
	for(unsigned int edge_block=0; edge_block<globalparams[GLOBALPARAMSCODE__PARAM__NUM_APPLYPARTITIONS] * NUM_LLP_PER_LLPSET; edge_block++){	
		map_t edge_map_vec[NUM_VALID_PEs];
		load_edgemap_vec((p_u * MAX_NUM_LLP_PER_UPARTITION) + edge_block, globalparams[GLOBALPARAMSCODE__BASEOFFSET__EDGEUPDATESPTRS], edge_map_vec, {% include '___HBM___ARGS___.template' %});
		for(unsigned int n=0; n<NUM_VALID_PEs; n++){
		#pragma HLS UNROLL
			edgeupdate_map[n] = edge_map_vec[n];
		}
		
		for(unsigned int n=0; n<NUM_VALID_PEs; n++){
		#pragma HLS UNROLL
			#ifndef FPGA_IMPL
			checkoutofbounds("acts_kernel::ERROR 8162::", edge_block, EDGEMAPS_BUFFER_SIZE, NAp, __NUM_APPLYPARTITIONS, NAp);
			#endif 
			edgeupdate_maps[n][edge_block] = edgeupdate_map[n];
		}
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

	EC_PROCESS_EDGEUPDATES_LOOP1: for(unsigned int llp_set=0; llp_set<globalparams[GLOBALPARAMSCODE__PARAM__NUM_APPLYPARTITIONS]; llp_set++){	
		EC_PROCESS_EDGEUPDATES_LOOP1B: for(unsigned int llp_id=0; llp_id<EDGE_PACK_SIZE; llp_id++){ // REMOVEME.
			#ifdef _DEBUGMODE_KERNELPRINTS4
			cout<<"------------------- update edges: ["<<p_u<<", "<<llp_set<<", "<<llp_id<<", "<<llp_id<<"] -------------------"<<endl; 
			#endif 
			
			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// load edges map
			map_t edge_map_vec[NUM_VALID_PEs];
			load_edgemap_vec((p_u * MAX_NUM_LLP_PER_UPARTITION) + (llp_set * NUM_LLP_PER_LLPSET) + llp_id, globalparams[GLOBALPARAMSCODE__BASEOFFSET__ACTPACKVPTRS2], edge_map_vec, {% include '___HBM___ARGS___.template' %});
			for(unsigned int n=0; n<NUM_VALID_PEs; n++){
			#pragma HLS UNROLL
				edge_map[n] = edge_map_vec[n];
			}
			for(unsigned int n=0; n<NUM_VALID_PEs; n++){
			#pragma HLS UNROLL
				edge_maps[n][llp_id] = edge_map[n];
			}
			
			// load edge updates maps 
			// cout<<"(p_u * MAX_NUM_LLP_PER_UPARTITION) + (llp_set * NUM_LLP_PER_LLPSET) + llp_id: "<<(p_u * MAX_NUM_LLP_PER_UPARTITION) + (llp_set * NUM_LLP_PER_LLPSET) + llp_id<<endl;
			load_edgemap_vec((p_u * MAX_NUM_LLP_PER_UPARTITION) + (llp_set * NUM_LLP_PER_LLPSET) + llp_id, globalparams[GLOBALPARAMSCODE__BASEOFFSET__EDGEUPDATESPTRS], edge_map_vec, {% include '___HBM___ARGS___.template' %});
			for(unsigned int n=0; n<NUM_VALID_PEs; n++){
			#pragma HLS UNROLL
				edgeupdate_map[n] = edge_map_vec[n];
			}
			for(unsigned int n=0; n<NUM_VALID_PEs; n++){
			#pragma HLS UNROLL
				#ifndef FPGA_IMPL
				checkoutofbounds("acts_kernel::ERROR 8162::", llp_id, EDGEMAPS_BUFFER_SIZE, NAp, __NUM_APPLYPARTITIONS, NAp);
				#endif 
				edgeupdate_maps[n][llp_id] = edgeupdate_map[n];
			}
			
			#ifdef _DEBUGMODE_KERNELPRINTS4
			for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<"process-edge-updates: edgeupdate_maps[n]["<<llp_id<<"]: p_u: "<<p_u<<", llp_set: "<<llp_set<<", llp_id: "<<llp_id<<", offset: "<<edgeupdate_maps[n][llp_id].offset<<", size: "<<edgeupdate_maps[n][llp_id].size<<""<<endl; }
			#endif 
			// exit(EXIT_SUCCESS);
			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
			// unsigned int edge_block = NAp;// (llp_set * EDGE_PACK_SIZE) + llp_id;
			// #ifdef _DEBUGMODE_KERNELPRINTS4
			// cout<<"------------------- update edges: ["<<p_u<<", "<<llp_set<<", "<<llp_id<<", "<<llp_id<<"] -------------------"<<endl; 
			// #endif 
			
			// prepare maps, offsets, variables 
			for(unsigned int n=0; n<NUM_VALID_PEs; n++){ offsets[n] = edge_maps[n][llp_id].offset; }	

			// prepare maps, offsets, variables 
			unsigned int max_sz_eu = 0; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ limits_eu[n] = edgeupdate_maps[n][llp_id].size; } for(unsigned int n=0; n<NUM_VALID_PEs; n++){ if(max_sz_eu < limits_eu[n]){ max_sz_eu = limits_eu[n]; }}
			for(unsigned int n=0; n<NUM_VALID_PEs; n++){ 
				offsets_eu[n] = edgeupdate_maps[n][llp_id].offset; 
			}	
			#ifdef _DEBUGMODE_KERNELPRINTS4
			cout<<"[BEFORE - EDGE UPDATES MAP]: "; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<edgeupdate_maps[n][llp_id].size<<", "; } cout<<endl;
			cout<<"[BEFORE - EDGE MAP]: "; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<edge_maps[n][llp_id].size<<", "; } cout<<endl;
			#endif 
			
			// clear edge updates buffers
			// #ifdef FFFFFFF
			MY_LOOP180: for(unsigned int t=0; t<EDGE_UPDATES_DRAMBUFFER_SIZE; t++){ 
			#pragma HLS PIPELINE II=1
				MY_LOOP181: for(unsigned int i=0; i<NUM_VALID_PEs; i++){ 
				#pragma HLS UNROLL
					MY_LOOP182: for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
					#pragma HLS UNROLL
						edgeupdates_buffer[i][v][t].srcvid = INVALIDDATA; 
						edgeupdates_buffer[i][v][t].dstvid = INVALIDDATA; 
					}
				}			
			}	
			// #endif 
			
			// populate edge updates buffers
			unsigned int sz = max_sz_eu; if(max_sz_eu > EDGE_UPDATES_DRAMBUFFER_SIZE){ sz = EDGE_UPDATES_DRAMBUFFER_SIZE; }
			edge_update_vec_dt edge_update_vecs[NUM_VALID_PEs];
			LOAD_EDGEUPDATES_LOOP1: for(unsigned int t=0; t<sz; t++){ 
			#pragma HLS PIPELINE II=1
				dretrievemany_edgeupdates(globalparams[GLOBALPARAMSCODE__BASEOFFSET__EDGEUPDATES], offsets_eu, t, edge_update_vecs, {% include '___HBM___ARGS___.template' %});
				MY_LOOP1273: for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
				#pragma HLS UNROLL
					MY_LOOP1274: for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
					#pragma HLS UNROLL
						edge_update_type edge_update = edge_update_vecs[inst].data[v];
						#ifdef _DEBUGMODE_CHECKS3
						if(edge_update_vecs[inst].data[v].srcvid != INVALIDDATA){ checkoutofbounds("acts_kernel::ERROR 8813::", edge_update_vecs[inst].data[v].srcvid, MAX_UPARTITION_SIZE, t, v, inst); }
						if(edge_update_vecs[inst].data[v].dstvid != INVALIDDATA){ checkoutofbounds("acts_kernel::ERROR 8823::", edge_update_vecs[inst].data[v].dstvid, MAX_UPARTITION_SIZE, t, v, inst); }
						#endif
						
						if(edge_update.srcvid != INVALIDDATA && edge_update.dstvid != INVALIDDATA){
							unsigned int uniq_srcvid = edge_update.srcvid / EDGE_PACK_SIZE;
							unsigned int uniq_dstvid = edge_update.dstvid / EDGE_PACK_SIZE;
							unsigned int edge_hashid = hash_edge(uniq_srcvid, uniq_dstvid, t);
							
							#ifdef _DEBUGMODE_KERNELPRINTS//4
							if(inst==0 && t<4){ cout<<"[hashing edge updates into buffer locations: edge["<<inst<<"]["<<t<<"]["<<v<<"]: srcvid: "<<edge_update.srcvid<<", dstvid: "<<edge3_vecs[inst].data[v].dstvid<<", weight: "<<edge3_vecs[inst].data[v].weight<<", edge_hashid: "<<edge_hashid<<"]"<<endl; }
							#endif 
							#ifdef _DEBUGMODE_CHECKS3
							checkoutofbounds("acts_kernel::ERROR 2513::", edge_hashid, EDGE_UPDATES_DRAMBUFFER_SIZE, edge_update.srcvid, NAp, NAp);
							#endif
							insert_edgeupdatesbuffer(v, edge_hashid, edge_update, edgeupdates_buffer[inst]); 
						}
						if(inst==0 && v==0){ update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___NUMBER_OF_EDGEUPDATES_LOADED___, 1); }
					}
				}
			}
			
			// update trackers
			#ifdef ___ENABLE___DYNAMICGRAPHANALYTICS___
			for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
			#pragma HLS UNROLL
				if(edgeupdate_maps[inst][llp_id].size >= sz){ edgeupdate_maps[inst][llp_id].size -= sz; } else { edgeupdate_maps[inst][llp_id].size = 0; }
			}
			#ifdef _DEBUGMODE_KERNELPRINTS//4
			cout<<"[EDGE UPDATES MAP(BEFORE)]: "; for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ cout<<edgeupdate_maps[inst][llp_id].size + sz<<", "; } cout<<endl;
			cout<<"[EDGE UPDATES MAP(AFTER)]: "; for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ cout<<edgeupdate_maps[inst][llp_id].size<<", "; } cout<<endl;
			#endif 
			#endif 
			
			// update edges 
			edge_update_type invalid_data; invalid_data.srcvid = INVALIDDATA; invalid_data.dstvid = INVALIDDATA; 
			EC_PROCESS_EDGEUPDATES_MAINLOOP1D: for(unsigned int t=0; t<max_sz_eu; t++){ 
			#pragma HLS PIPELINE II=1
				dretrievemanyfromB_actpackedges(globalparams[GLOBALPARAMSCODE__BASEOFFSET__ACTPACKEDGES], offsets, t, edge3_vecs, {% include '___HBM___ARGS___.template' %});
				
				PROCESS_EDGEUPDATES_LOOP1E: for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
				#pragma HLS UNROLL
					PROCESS_EDGEUPDATES_LOOP1F: for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
					#pragma HLS UNROLL
						edge3_type edge = edge3_vecs[inst].data[v];
						unsigned int uniq_srcvid = edge.srcvid;		
						unsigned int uniq_dstvid = edge.dstvid;		
						unsigned int weight = edge.weight;		
						unsigned int edge_hashid = hash_edge(uniq_srcvid, uniq_dstvid, t);
						
						if(edge.srcvid != INVALIDDATA && edge.dstvid != INVALIDDATA){	
							edge_update_type edge_update = retrieve_edgeupdatesbuffer(v, edge_hashid, edgeupdates_buffer[inst]);
							unsigned int uniq_eu_srcvid = edge_update.srcvid;
							unsigned int uniq_eu_dstvid = edge_update.dstvid;
							unsigned int eu_weight = 1; // edge_update.weight;
							
							if(uniq_srcvid == uniq_eu_srcvid && uniq_dstvid == uniq_eu_dstvid){
								// edge update found. merge edge with edge update & invalidate the edge update 
								edge3_vecs[inst].data[v].weight += eu_weight; 
								insert_edgeupdatesbuffer(v, edge_hashid, invalid_data, edgeupdates_buffer[inst]); // FIXME. can prevent complete pipelining with II=1
								
								#ifdef _DEBUGMODE_KERNELPRINTS//4	
								if(inst==0 && t<1){ cout<<"[newly updated edge: edge["<<inst<<"]["<<t<<"]["<<v<<"]: srcvid: "<<edge.srcvid<<", dstvid: "<<edge.dstvid<<", new weight: "<<edge.weight<<", old weight: "<<edge.weight - eu_weight<<", edge_hashid: "<<edge_hashid<<"]"<<endl; }
								#endif 	
								if(inst==0 && v==0){ update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___NUMBER_OF_EDGEUPDATES_APPLIED___, 1); }
							} else {
								#ifdef _DEBUGMODE_KERNELPRINTS//4	
								if(inst==0 && t<1){ 
									cout<<"[un-updated edge: edge["<<inst<<"]["<<t<<"]["<<v<<"]: srcvid: "<<edge.srcvid<<", dstvid: "<<edge.dstvid<<", new weight: "<<edge.weight<<", old weight: "<<edge.weight - eu_weight<<", edge_hashid: "<<edge_hashid<<"]"<<endl; 
									cout<<"[edge update: edge_update: srcvid: "<<edge_update.srcvid<<", dstvid: "<<edge_update.dstvid<<", new weight: "<<edge_update.weight<<", old weight: "<<edge_update.weight<<", edge_hashid: "<<edge_hashid<<"]"<<endl; 
								}
								#endif 	
							}
						}
					}
				}
			
				dinsertmanytoA_actpackedges(globalparams[GLOBALPARAMSCODE__BASEOFFSET__ACTPACKEDGES], offsets, t, edge3_vecs, {% include '___HBM___ARGS___.template' %}); // FIXME
				update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___ECPROCESSEDGES___, 1);
			}
			
			// compress unclaimed edge updates and save
			#ifdef ___NOT_YET_IMPLEMENTED___ ////////////////
			for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ 
			#pragma HLS UNROLL
				for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
				#pragma HLS UNROLL
					edge_counts[inst][v] = 0;
				}
			}
			
			COMPRESS_EDGEUPDATES_LOOP1: for(unsigned int t=0; t<sz; t++){ 
			#pragma HLS PIPELINE II=1
				for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
				#pragma HLS UNROLL
					for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
					#pragma HLS UNROLL
						edge_update_type edge_update = retrieve_edgeupdatesbuffer(v, t, edgeupdates_buffer[inst]);		
						if(edge_update.srcvid != INVALIDDATA){
							insert_edgeupdatesbuffer(v, edge_counts[inst][v], edge_update, edgeupdates_outbuffer[inst]); 
							edge_counts[inst][v] += 1;
							if(inst==0 && v==0){ update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___NUMBER_OF_NEW_EDGEUPDATES_ADDED___, 1); }
						}		
					}
				}
			}
			
			for(unsigned int n=0; n<NUM_VALID_PEs; n++){ 
			#pragma HLS UNROLL
				limits[n] = 0; for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ if(limits[n] < edge_counts[n][v]){ limits[n] = edge_counts[n][v]; }}	
			}
			unsigned int maxsz = 0; for(unsigned int n=0; n<NUM_VALID_PEs; n++){  if(maxsz < limits[n]){ maxsz = limits[n]; }}	
			for(unsigned int n=0; n<NUM_VALID_PEs; n++){ offsets[n] = edge_maps[n][llp_id].offset + edge_maps[n][llp_id].size; }	
			
			#ifdef _DEBUGMODE_KERNELPRINTS4
			cout<<"save new edges: edge counts: [maxsz: "<<maxsz<<"]: "; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ cout<<edge_counts[n][v]<<", "; }} cout<<endl;
			#endif
			SAVE_NEWEDGEUPDATES_LOOP1: for(unsigned int t=0; t<maxsz; t++){ 
			#pragma HLS PIPELINE II=1
				for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
				#pragma HLS UNROLL
					for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
					#pragma HLS UNROLL
						edge_update_vecs[inst].data[v] = retrieve_edgeupdatesbuffer(v, t, edgeupdates_buffer[inst]);	
						if(inst==0 && v==0){ update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___NUMBER_OF_NEW_EDGEUPDATES_ADDED___, 1); }	
					}					
					for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
					#pragma HLS UNROLL
						edge3_vecs[inst].data[v].srcvid = edge_update_vecs[inst].data[v].srcvid;
						edge3_vecs[inst].data[v].dstvid = edge_update_vecs[inst].data[v].dstvid;
						edge3_vecs[inst].data[v].weight = 1;
						edge3_vecs[inst].data[v].valid = 1;
					}
				}
				dinsertmanytoA_actpackedges(globalparams[GLOBALPARAMSCODE__BASEOFFSET__ACTPACKEDGES], offsets, t, edge3_vecs, {% include '___HBM___ARGS___.template' %}); // FIXME
			}
			for(unsigned int n=0; n<NUM_VALID_PEs; n++){ edge_maps[n][llp_id].size += maxsz; }	
			#endif ////////////////
			
			#ifdef _DEBUGMODE_KERNELPRINTS4
			cout<<"[AFTER - EDGE MAP]: "; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<edge_maps[n][llp_id].size<<", "; } cout<<endl;
			cout<<"[AFTER - EDGE UPDATES MAP]: "; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<edgeupdate_maps[n][llp_id].size<<", "; } cout<<endl;
			#endif 
			exit(EXIT_SUCCESS);
		}
		// exit(EXIT_SUCCESS); 
	}
	// exit(EXIT_SUCCESS); 
}






















						