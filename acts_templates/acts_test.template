// https://github.com/Xilinx/Vitis-HLS-Introductory-Examples/blob/1d19087a2b4aa90fa2d86cf556aa883d3b413247/Vitis/multiple_kernels/vadd_kernel/krnl_vadd.cpp
// https://github.com/Xilinx/SDAccel_Examples/blob/master/getting_started/dataflow/dataflow_stream_c/src/adder.cpp
// https://github.com/Xilinx/Vitis-HLS-Introductory-Examples/blob/1d19087a2b4aa90fa2d86cf556aa883d3b413247/Dataflow/Channels/using_fifos/diamond.cpp  *

keyvalue_t {{context['classname__processedges']}}process_edge(bool enx, unsigned int v, unsigned int loc, keyvalue_t edge_data, keyvalue_vbuffer_t vbuffer[MAX_BLOCKRAM_VSRCDATA_SIZE], globalparams_t globalparams){				
	#pragma HLS INLINE
	
	// flag 
	bool en = true; if(edge_data.key == INVALIDDATA || edge_data.value == INVALIDDATA || enx == false){ en = false; } else { en = true; }

	// check loc 
	if(loc >= globalparams.SIZEKVS2_PROCESSEDGESPARTITION){ loc = 0; }
	#ifdef _DEBUGMODE_CHECKS
	if(loc >= globalparams.SIZEKVS2_PROCESSEDGESPARTITION && edge_data.key != INVALIDDATA){ cout<<"PROCESS{{context['id']}}_processvector::ERROR SEEN @@ loc("<<loc<<") >= globalparams.SIZEKVS2_PROCESSEDGESPARTITION("<<globalparams.SIZEKVS2_PROCESSEDGESPARTITION<<"). edge_data.key: "<<edge_data.key<<", edge_data.value: "<<edge_data.value<<", v: "<<v<<", INVALIDDATA: "<<INVALIDDATA<<". EXITING... "<<endl; exit(EXIT_FAILURE); }
	#endif 
		
	// read vertex data 
	keyvalue_vbuffer_t bits_vector = vbuffer[loc / VDATA_SHRINK_RATIO];
	
	// read vertex mask
	vmdata_t vmdata; if(en == true){ vmdata = MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK(bits_vector); } else { vmdata.vmask = 0; }
	if(globalparams.ALGORITHMINFO_GRAPHALGORITHMCLASS == ALGORITHMCLASS_ALLVERTEXISACTIVE){ vmdata.vmask = 1; }
	#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
	if(vmdata.vmask == 1){ cout<<">>> PROCESS VECTOR:: ACTIVE VERTEX PROCESSED: SEEN: @ v: "<<v<<", loc: "<<loc<<", edge_data.key: "<<edge_data.key<<", edge_data.value(srcvid): "<<edge_data.value<<", en: "<<en<<", vid: "<<UTIL{{context['id']}}_GETREALVID(edge_data.key, globalparams.ACTSPARAMS_INSTID)<<endl; }
	#endif
			
	// process
	value_t res = process_func(vmdata.vdata, 1, globalparams.ALGORITHMINFO_GRAPHALGORITHMID);
	
	keyvalue_t vupdate; vupdate.key = edge_data.key; vupdate.value = res;
	return vupdate;
}

void {{context['classname__reduceupdates']}}reduce_update(bool enx, unsigned int loc, keyvalue_t update_data, keyvalue_vbuffer_t vbufferA[MAX_BLOCKRAM_VDESTDATA_SIZE], keyvalue_vbuffer_t vbufferB[MAX_BLOCKRAM_VDESTDATA_SIZE], unsigned int memory[1], globalparams_t globalparams){
	#pragma HLS INLINE
	
	unsigned int which = loc % 2; // FIXME
	
	// flag 
	bool en = true;
	if(update_data.key == UTIL{{context['id']}}_GETK(INVALIDDATA) || update_data.value == UTIL{{context['id']}}_GETV(INVALIDDATA) || update_data.key == MAXVDATA || update_data.value == MAXVDATA){ en = false; }
	
	// check loc 
	if(loc >= (globalparams.SIZEKVS2_REDUCEPARTITION / 2) && en == true){ loc = 0; } // loc = loc / 2; // urams pack in 2s
	#ifdef ENABLE_PERFECTACCURACY
	if(true){ cout<<"REDUCE{{context['id']}}reduce_update::ERROR SEEN @ loc("<<loc<<") >= globalparams.SIZEKVS2_REDUCEPARTITION("<<globalparams.SIZEKVS2_REDUCEPARTITION<<"). update_data.key: "<<update_data.key<<", upperlimit: "<<upperlimit<<", col: "<<col<<". EXITING... "<<endl; exit(EXIT_FAILURE); }
	#endif 
	
	// 
	if(en == true){ if(loc == memory[0]){ loc = (loc + 1) % 8; } memory[0] = loc; } // CRITICAL FIXME.
	#ifdef _DEBUGMODE_CHECKS3
	if(en == true){ actsutilityobj->checkoutofbounds("reducevector(114)::DEBUG CODE 113::1", loc, MAX_BLOCKRAM_VDESTDATA_SIZE, NAp, loc, VDATA_SHRINK_RATIO); }
	#endif
	
	/* // read vertex data 
	keyvalue_vbuffer_t bits_vectorA = 0; keyvalue_vbuffer_t bits_vectorB = 0;  vmdata_t tmpvdata; tmpvdata.vmask = 0; 
	if(en == true){ bits_vectorA = vbufferA[globalparams.BUFFERBASEOFFSETKVS_VDATA1 + (loc / VDATA_SHRINK_RATIO)]; }
	if(en == true){ bits_vectorB = vbufferB[globalparams.BUFFERBASEOFFSETKVS_VDATA1 + (loc / VDATA_SHRINK_RATIO)]; }
	
	keyvalue_vbuffer_t bits_vector = 0; 
	if(which == 0){ bits_vector = bits_vectorA; } else { bits_vector = bits_vectorB; } */
	
	vmdata_t tmpvdata; tmpvdata.vmask = 0; 
	keyvalue_vbuffer_t bits_vector = loc + 7; // CRITICAL REMOVEME. 
	
	#if defined(ALGORITHMTYPE_REPRESENTVDATASASBITS)
		if(en == true){ tmpvdata = MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK2(loc, bits_vector); }
			#else 
				if(en == true){ tmpvdata = MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK(bits_vector); }
					#endif
	
	// reduce 
	value_t new_vprop = reduce_func(tmpvdata.vdata, tmpvdata.vdata, update_data.value, globalparams.ALGORITHMINFO_GRAPHITERATIONID, globalparams.ALGORITHMINFO_GRAPHALGORITHMID);
	
	if(en == true && new_vprop != tmpvdata.vdata){ tmpvdata.vmask = 1; } else { tmpvdata.vmask = 0; }
	#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
	if(en == true && new_vprop != tmpvdata.vdata){ cout<<">>> REDUCE VECTOR:: ACTIVE MASK SEEN AT: loc: "<<loc<<", tmpvdata.vdata: "<<tmpvdata.vdata<<", tmpvdata.vmask: "<<tmpvdata.vmask<<endl; }
	if(en == true && new_vprop != tmpvdata.vdata){ cout<<">>> REDUCE VECTOR:: ACTIVE REDUCE SEEN @ instance "<<globalparams.ACTSPARAMS_INSTID<<", col: "<<col<<", loc: "<<loc<<", vid: "<<UTIL{{context['id']}}_GETREALVID(update_data.key, globalparams.ACTSPARAMS_INSTID)<<endl; }
	#endif
	
	// write-back vertx data
	#if defined(ALGORITHMTYPE_REPRESENTVDATASASBITS)
		if(en == true && which == 0){ MEMCA{{context['id']}}_WRITETOBUFFER_VDATAWITHVMASK2(loc, vbufferA, globalparams.BUFFERBASEOFFSETKVS_VDATA1, bits_vector, new_vprop, tmpvdata.vmask); }
		if(en == true && which == 1){ MEMCA{{context['id']}}_WRITETOBUFFER_VDATAWITHVMASK2(loc, vbufferB, globalparams.BUFFERBASEOFFSETKVS_VDATA1, bits_vector, new_vprop, tmpvdata.vmask); }
			#else 
				if(en == true && which == 0){ MEMCA{{context['id']}}_WRITETOBUFFER_VDATAWITHVMASK(loc, vbufferA, globalparams.BUFFERBASEOFFSETKVS_VDATA1, bits_vector, new_vprop, tmpvdata.vmask); }
				if(en == true && which == 1){ MEMCA{{context['id']}}_WRITETOBUFFER_VDATAWITHVMASK(loc, vbufferB, globalparams.BUFFERBASEOFFSETKVS_VDATA1, bits_vector, new_vprop, tmpvdata.vmask); }
					#endif
	return;
}	

#ifdef FPGA_IMPL
void load(uint512_dt *in, hls::stream<uint512_evec_dt >& out, batch_type sourcebaseaddr_kvs, unsigned int offset_kvs, int size){
	Loop_Ld: for (int i = 0; i < size; i++){
	#pragma HLS PIPELINE II=1
		uint512_evec_dt data = UTIL{{context['id']}}_ReadEdges(in, sourcebaseaddr_kvs + offset_kvs + i);
		out.write(data);
	}
}

void compute_and_store(hls::stream<uint512_evec_dt >& in, uint512_dt *out, keyvalue_vbuffer_t vbuffer_source[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VSRCDATA_SIZE],
					batch_type destbaseaddr_kvs, unsigned int offset_kvs, int size, unsigned int upperlimit, 
						collection_t collections[COLLECTIONS_BUFFERSZ], globalparams_t globalparamsK, globalposition_t globalposition){
	uint512_uvec_dt res;
	
	Loop_A: for (int i = 0; i < size; i++){
	#pragma HLS PIPELINE II=1
		uint512_evec_dt data = in.read();
		
		// set flag
		bool enx = true;
		collections[TRAVERSEDEDGES_COLLECTIONID].data1 += UPDATEDATA_PACKINGSIZE;
		collections[PROCESSEDGES_COLLECTIONID].data1 += EDGEDATA_PACKINGSIZE;  // *** used in PR, CF implementations ONLY (not BFS) ***
		
		// process
		for(unsigned int v=0; v<EDGEDATA_PACKINGSIZE; v++){
		#pragma HLS UNROLL
			res.data[v] = process_edge(enx, v, data.data[v].value - upperlimit, data.data[v], vbuffer_source[v], globalparamsK);
		}
		
		// store
		UTIL{{context['id']}}_WriteDataset(out, destbaseaddr_kvs + offset_kvs + i, res);
	}
}
#endif 

void {{context['classname__acts']}}ACTS{{context['id']}}_read_process_partition_and_write(uint512_dt *in, uint512_dt *out, keyvalue_vbuffer_t vbuffer_source[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VSRCDATA_SIZE],
			batch_type sourcebaseaddr_kvs, unsigned int srcoffset_kvs, batch_type destbaseaddr_kvs, unsigned int destoffset_kvs, int size, unsigned int upperlimit, 
				collection_t collections[COLLECTIONS_BUFFERSZ], globalparams_t globalparamsK, globalposition_t globalposition){
	uint512_uvec_dt res; // uint512_uvec_dt

	for(int i = 0; i < size; i++){
		// load 
		uint512_evec_dt data = UTIL{{context['id']}}_ReadEdges(in, sourcebaseaddr_kvs + srcoffset_kvs + i);
	
		// set flag
		bool enx = true;
		collections[TRAVERSEDEDGES_COLLECTIONID].data1 += UPDATEDATA_PACKINGSIZE;
		collections[PROCESSEDGES_COLLECTIONID].data1 += EDGEDATA_PACKINGSIZE; // *** used in PR, CF implementations ONLY (not BFS) ***
		
		// process
		for(unsigned int v=0; v<EDGEDATA_PACKINGSIZE; v++){
		#pragma HLS UNROLL
			res.data[v] = process_edge(enx, v, data.data[v].value - upperlimit, data.data[v], vbuffer_source[v], globalparamsK);
		}
		
		// store
		UTIL{{context['id']}}_WriteDataset(out, destbaseaddr_kvs + destoffset_kvs + i, res);
		
		#ifdef _DEBUGMODE_STATS___NOTUSED
		if(enx == true){
			actsutilityobj->globalstats_countkvsprocessed(globalparamsK.ACTSPARAMS_INSTID, EDGEDATA_PACKINGSIZE);
			actsutilityobj->globalstats_processedges_countvalidkvsprocessed(globalparamsK.ACTSPARAMS_INSTID, EDGEDATA_PACKINGSIZE); }
		#endif 
	}
}

void {{context['classname__acts']}}ACTS{{context['id']}}_read_process_partition_and_write_base(uint512_dt * kvdram, keyvalue_vbuffer_t vbuffer_source[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VSRCDATA_SIZE],	
			unsigned int upperlimit, unsigned int sourcebaseaddr_kvs, workload_t workload_kvs, unsigned int destbaseaddr_kvs, unsigned int destoffset_kvs,
				collection_t collections[COLLECTIONS_BUFFERSZ], globalparams_t globalparamsK, globalposition_t globalposition){

	#ifdef FPGA_IMPL
	hls::stream<uint512_evec_dt> c0; //, c1, c2, c3, c4, c5;
	#pragma HLS STREAM variable = c0 depth = 512

	#pragma HLS dataflow
	load(kvdram, c0, sourcebaseaddr_kvs, workload_kvs.offset_begin, workload_kvs.size);
	compute_and_store(c0, kvdram, vbuffer_source,
					destbaseaddr_kvs, destoffset_kvs, workload_kvs.size, upperlimit, 
						collections, globalparamsK, globalposition);
						
	#else 
	ACTS{{context['id']}}_read_process_partition_and_write(kvdram, kvdram, vbuffer_source,
		sourcebaseaddr_kvs, workload_kvs.offset_begin, destbaseaddr_kvs, destoffset_kvs, workload_kvs.size, upperlimit, 
					collections, globalparamsK, globalposition);
	#endif
}

void {{context['classname__acts']}}ACTS{{context['id']}}_read_and_reduce(unsigned int mode, uint512_dt * kvdram, keyvalue_vbuffer_t vbuffer_dest[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VDESTDATA_SIZE],	
			sweepparams_t sweepparams, unsigned int sourcebaseaddr_kvs, workload_t workload_kvs, 
				collection_t collections[COLLECTIONS_BUFFERSZ], globalparams_t globalparamsK, globalposition_t globalposition){
	unsigned int memory[VECTOR2_SIZE][1];
	#pragma HLS ARRAY_PARTITION variable = memory // complete
	
	unsigned int tmp = collections[ACTIVEEDGESPROCESSED_COLLECTIONID].data1;
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"actit3(reduce): processing all chunks [begin_kvs: "<<workload_kvs.offset_begin<<"][end_kvs: "<<workload_kvs.offset_end<<"][workload_kvs.size: "<<workload_kvs.size<<"][size: "<<workload_kvs.size * UPDATEDATA_PACKINGSIZE<<"][workbuffer_size: "<<globalparamsK.ACTSPARAMS_WORKBUFFER_SIZE<<"][num_chunks: "<<(workload_kvs.offset_end - workload_kvs.offset_begin) / globalparamsK.ACTSPARAMS_WORKBUFFER_SIZE<<"] ... "<<endl;					
	#endif
	ACTIT3_MAINLOOP2A: for(batch_type offset_kvs=workload_kvs.offset_begin; offset_kvs<workload_kvs.offset_begin + workload_kvs.size; offset_kvs++){
	#pragma HLS PIPELINE II=1
	// #pragma HLS dependence variable=vbuffer_dest inter false
	// #pragma HLS PIPELINE II=5
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<"actit3(reduce): processing chunk [offset_kvs: "<<offset_kvs<<"]: [workload_kvs.offset_begin: "<<workload_kvs.offset_begin<<"]: [workload_kvs.offset_end: "<<workload_kvs.offset_end<<"] ... "<<endl;
		#endif
		
		// get dataset
		uint512_uvec_dt data = UTIL{{context['id']}}_GetUpdates(kvdram, sourcebaseaddr_kvs + offset_kvs);
		
		// set flag
		bool enx = true;
		if(globalparamsK.ALGORITHMINFO_GRAPHALGORITHMCLASS != ALGORITHMCLASS_ALLVERTEXISACTIVE){  // used in BFS implementations ONLY (not PR or CF)
			collections[TRAVERSEDEDGES_COLLECTIONID].data1 += UPDATEDATA_PACKINGSIZE;
			collections[PROCESSEDGES_COLLECTIONID].data1 += UPDATEDATA_PACKINGSIZE;
			if(tmp + ((offset_kvs - workload_kvs.offset_begin) * UPDATEDATA_PACKINGSIZE) >= globalposition.num_active_edges_in_channel){ enx = false; } 
			else { enx = true; collections[ACTIVEEDGESPROCESSED_COLLECTIONID].data1 += UPDATEDATA_PACKINGSIZE; }
		} // else { enx = true; collections[PROCESSEDGES_COLLECTIONID].data1 += UPDATEDATA_PACKINGSIZE; }
		
		// reduce
		{%for v in context['VECTOR_SIZE_seq']%}	
		reduce_update(enx, data.data[{{v}}].key, data.data[{{v}}], vbuffer_dest[{{2*v}}], vbuffer_dest[{{2*v+1}}], memory[{{v}}], globalparamsK);
		{%endfor%}
		
		if(enx == true){ collections[REDUCEUPDATES_COLLECTIONID].data1 += UPDATEDATA_PACKINGSIZE; }
	}
}

void {{context['classname__acts']}}ACTS{{context['id']}}_read_process_and_reduce(uint512_dt *in, uint512_dt *out, keyvalue_vbuffer_t vbuffer_source[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VSRCDATA_SIZE],
				collection_t collections[COLLECTIONS_BUFFERSZ], globalparams_t globalparamsE, globalparams_t globalparamsK, globalposition_t globalposition){
	keyvalue_t res[EDGEDATA_PACKINGSIZE]; // uint512_uvec_dt

	keyvaluemask_t buffer[EDGEDATA_PACKINGSIZE][BLOCKRAM_SIZE];
	unsigned int buffer_index[EDGEDATA_PACKINGSIZE]; for(int i = 0; i < EDGEDATA_PACKINGSIZE; i++){ buffer_index[i] = 0; }
	unsigned int size_actvvs[BLOCKRAM_SIZE];
	unsigned int offsetkvs_actvvs[BLOCKRAM_SIZE];
	
	unsigned int num_actvvs = globalposition.num_active_vertices;
	for(int i = 0; i < num_actvvs; i++){ size_actvvs[i] = 4; } // FIXME.
	for(int i = 0; i < num_actvvs; i++){ offsetkvs_actvvs[i] = 0; } // FIXME.
	unsigned int srcvoffset = globalparamsE.BASEOFFSETKVS_EDGESDATA * VDATA_PACKINGSIZE;
	
	keyvaluemask_t data[EDGEDATA_PACKINGSIZE]; 
	for(int i = 0; i < EDGEDATA_PACKINGSIZE; i++){ data[i].mask = 1; } // FIXME.
	
	// read and process 
	for(int n=0; n<num_actvvs; n++){
		unsigned int size = size_actvvs[n];
		unsigned int srcoffset_kvs = offsetkvs_actvvs[n];
		for(int i = 0; i < size; i++){
		#pragma HLS PIPELINE II=1
			// load 
			uint512_evec_dt edge = UTIL{{context['id']}}_ReadEdges(in, globalparamsE.BASEOFFSETKVS_EDGESDATA + srcoffset_kvs + i);
			keyvaluemask_t data[EDGEDATA_PACKINGSIZE];
			
			// set flag
			bool enx = true;
			collections[TRAVERSEDEDGES_COLLECTIONID].data1 += EDGEDATA_PACKINGSIZE; // used in BFS implementations ONLY (not PR or CF)
			collections[PROCESSEDGES_COLLECTIONID].data1 += EDGEDATA_PACKINGSIZE; 
			collections[ACTIVEEDGESPROCESSED_COLLECTIONID].data1 += UPDATEDATA_PACKINGSIZE;
			
			// process
			for(unsigned int v=0; v<EDGEDATA_PACKINGSIZE; v++){
			#pragma HLS UNROLL
				if(data[v].mask == 1){ res[v] = process_edge(enx, v, edge.data[v].value, edge.data[v], vbuffer_source[v], globalparamsK); }
				else { res[v].key = INVALIDDATA; res[v].value = 0; }
			}
			
			for(unsigned int v=0; v<EDGEDATA_PACKINGSIZE; v++){
			#pragma HLS UNROLL
				if(data[v].mask == 1){ buffer[v][buffer_index[v]].key = res[v].key; buffer[v][buffer_index[v]].value = res[v].value; buffer[v][buffer_index[v]].mask = 1; buffer_index[v] += 1; }
			}
		}
	}
	
	// direct reduce 
	unsigned int max = 0; for(int i = 0; i < EDGEDATA_PACKINGSIZE; i++){ if(max >= buffer_index[i]){ max = buffer_index[i]; }}
	for(int i = 0; i < max * EDGEDATA_PACKINGSIZE; i++){
		// read update 
		keyvaluemask_t data = buffer[i % EDGEDATA_PACKINGSIZE][i / EDGEDATA_PACKINGSIZE];
		
		// read vertex property
		keyvalue_vbuffer_t vdata = UTIL{{context['id']}}_ReadData(out, globalparamsK.BASEOFFSETKVS_DESTVERTICESDATA, data.key);
		
		// reduce
		value_t new_vprop = reduce_func(vdata, vdata, data.value, globalparamsK.ALGORITHMINFO_GRAPHITERATIONID, globalparamsK.ALGORITHMINFO_GRAPHALGORITHMID);
	
		// write vertex property
		if(data.mask == 1){ UTIL{{context['id']}}_WriteData(out, globalparamsK.BASEOFFSETKVS_DESTVERTICESDATA, data.key, new_vprop); }
		
		if(data.mask == 1){ collections[REDUCEUPDATES_COLLECTIONID].data1 += 1; } // UPDATEDATA_PACKINGSIZE
	}
}

void {{context['classname__acts']}}ACTS{{context['id']}}_actit(bool_type enable, unsigned int mode,
		uint512_dt * kvdram, keyvalue_vbuffer_t vbuffer_source[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VSRCDATA_SIZE], keyvalue_vbuffer_t vbuffer_dest[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VDESTDATA_SIZE],	
			keyvalue_t globalcapsule[BLOCKRAM_GLOBALSTATS_SIZE], globalparams_t globalparamsE, globalparams_t globalparamsK, globalposition_t globalposition, sweepparams_t sweepparams, travstate_t ptravstate, batch_type sourcebaseaddr_kvs, batch_type destbaseaddr_kvs,
				bool_type resetenv, bool_type flush, unsigned int edgebankID, collection_t collections[COLLECTIONS_BUFFERSZ]){

	unsigned int memory[VECTOR2_SIZE][1];
	#pragma HLS ARRAY_PARTITION variable = memory // complete
	workload_t workloads_kvs[BLOCKRAM_SIZE];
	
	collection_t collections_tmp[COLLECTIONS_BUFFERSZ];
	#pragma HLS ARRAY_PARTITION variable=collections_tmp complete
	collections_tmp[TRAVERSEDEDGES_COLLECTIONID] = collections[TRAVERSEDEDGES_COLLECTIONID];
	collections_tmp[PROCESSEDGES_COLLECTIONID] = collections[PROCESSEDGES_COLLECTIONID];
	collections_tmp[ACTIVEEDGESPROCESSED_COLLECTIONID] = collections[ACTIVEEDGESPROCESSED_COLLECTIONID];
	collections_tmp[REDUCEUPDATES_COLLECTIONID] = collections[REDUCEUPDATES_COLLECTIONID];
	
	unsigned int num_vPs = globalparamsK.NUM_PROCESSEDGESPARTITIONS;
	unsigned int num_LLPs = globalparamsK.NUM_REDUCEPARTITIONS * OPT_NUM_PARTITIONS; 
	unsigned int vsize_LLP; if(globalparamsK.ALGORITHMINFO_GRAPHALGORITHMCLASS != ALGORITHMCLASS_ALLVERTEXISACTIVE){ vsize_LLP = 262144; } else { vsize_LLP = globalparamsK.SIZEKVS2_REDUCEPARTITION; }
	unsigned int num_LLPset = (num_LLPs + (OPT_NUM_PARTITIONS - 1)) / OPT_NUM_PARTITIONS; 
	unsigned int upperlimit = sweepparams.source_partition * globalparamsK.SIZEKVS2_PROCESSEDGESPARTITION;
	
	bool enx = true;
	unsigned int _EN_PROCESS_PARTITION_SAVE = OFF; 
	unsigned int _EN_PROCESS_PARTITION_REDUCE = OFF;
	if(globalparamsK.ACTSPARAMS_TREEDEPTH == 1){ _EN_PROCESS_PARTITION_SAVE = OFF; _EN_PROCESS_PARTITION_REDUCE = ON; }
	else { if(mode == ACTSPROCESSMODE || mode == ACTSPARTITIONMODE){ _EN_PROCESS_PARTITION_SAVE = ON; } else if(mode == ACTSREDUCEMODE){ _EN_PROCESS_PARTITION_REDUCE = ON; }}
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"actit3:: [num_LLPs: "<<num_LLPs<<", num_LLPset: "<<num_LLPset<<", num_vPs: "<<num_vPs<<"] "<<endl;
	#endif 
	// cout<<"actit3:: ------------------------------- globalposition.source_partition: "<<globalposition.source_partition<<", globalposition.num_active_vertices: "<<globalposition.num_active_vertices<<", globalparamsK.THRESHOLD_HYBRIDGPMODE_HYBRIDVTHRESHOLD_PER_VPARTITION: "<<globalparamsK.THRESHOLD_HYBRIDGPMODE_HYBRIDVTHRESHOLD_PER_VPARTITION<<"--------------------------------"<<endl; 
	// if(globalparamsK.ALGORITHMINFO_GRAPHALGORITHMCLASS != ALGORITHMCLASS_ALLVERTEXISACTIVE && globalposition.num_active_vertices < globalparamsK.THRESHOLD_HYBRIDGPMODE_HYBRIDVTHRESHOLD_PER_VPARTITION){ cout<<"actit3:: -- returning..."<<endl; return; }
	// exit(EXIT_SUCCESS);
	
	if(globalparamsK.EVALUATION_ACTS_HYBRIDLOGIC == ON && globalparamsK.ALGORITHMINFO_GRAPHALGORITHMCLASS != ALGORITHMCLASS_ALLVERTEXISACTIVE && globalposition.num_active_vertices < globalparamsK.THRESHOLD_HYBRIDGPMODE_HYBRIDVTHRESHOLD_PER_VPARTITION){
		#ifdef CONFIG_ACTS_HYBRIDLOGIC
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<"actit3:: TOO FEW VERTICES. using TRADGP instead: [source_partition: "<<globalposition.source_partition<<", num_active_vertices: "<<globalposition.num_active_vertices<<"]"<<endl; 
		#endif 
		// ACTS{{context['id']}}_read_process_and_reduce(kvdram, kvdram, vbuffer_source, collections, globalparamsE, globalparamsK, globalposition);
		#endif 
	} else {	
		ACTIT3_LOOP1: for(unsigned int llp_set=0; llp_set<num_LLPset; llp_set++){
			// retreived pre-processed llp_set information first
			workload_t workload_kvs;
			workload_kvs.offset_begin = MEMACCESS{{context['id']}}_getdata(kvdram, vbuffer_source[0], globalparamsE.BASEOFFSETKVS_EDGESMAP, (sweepparams.source_partition * num_LLPset) + llp_set) / UPDATEDATA_PACKINGSIZE;
			workload_kvs.offset_end = MEMACCESS{{context['id']}}_getdata(kvdram, vbuffer_source[1], globalparamsE.BASEOFFSETKVS_EDGESMAP, (sweepparams.source_partition * num_LLPset) + llp_set + 1) / UPDATEDATA_PACKINGSIZE;
			workload_kvs.size = workload_kvs.offset_end - workload_kvs.offset_begin;
			if(workload_kvs.offset_end < workload_kvs.offset_begin){ workload_kvs.size = 0; }
			#ifdef _DEBUGMODE_CHECKS3
			if(workload_kvs.offset_end < workload_kvs.offset_begin){ cout<<"actit3(process): ERROR 23: workload_kvs.offset_end("<<workload_kvs.offset_end<<") < workload_kvs.offset_begin("<<workload_kvs.offset_begin<<"). EXITING..."<<endl; exit(EXIT_FAILURE); }
			#endif		
			
			workloads_kvs[llp_set] = workload_kvs;
		}
		
		if(_EN_PROCESS_PARTITION_SAVE == ON && globalparamsK.ENABLE_PROCESSCOMMAND == ON){
			ACTIT3_MAINLOOP1: for(unsigned int llp_set=0; llp_set<num_LLPset; llp_set++){
				workload_t workload_kvs = workloads_kvs[llp_set];
				batch_type destoffset_kvs = (globalcapsule[llp_set].key + globalcapsule[llp_set].value) / UPDATEDATA_PACKINGSIZE;
				
				#ifdef _DEBUGMODE_KERNELPRINTS
				unsigned int num_chunks = workload_kvs.size / BLOCKRAM_SIZE;
				cout<<"actit3(process): processing all chunks [begin_kvs: "<<workload_kvs.offset_begin<<"][end_kvs: "<<workload_kvs.offset_end<<"][size_kvs: "<<workload_kvs.size<<"][size: "<<workload_kvs.size * UPDATEDATA_PACKINGSIZE<<"][workbuffer_size: "<<globalparamsK.ACTSPARAMS_WORKBUFFER_SIZE<<"][num_chunks: "<<num_chunks<<"] ... "<<endl;					
				#endif
				
				ACTS{{context['id']}}_read_process_partition_and_write_base(kvdram, vbuffer_source,	
					upperlimit, sourcebaseaddr_kvs, workload_kvs, destbaseaddr_kvs, destoffset_kvs, 
						collections_tmp, globalparamsK, globalposition);
				
				globalcapsule[llp_set].value += workload_kvs.size * UPDATEDATA_PACKINGSIZE; // CRITICAL FIXME. let globalcapsule load all partitions of LLOP-1
			}
		}
		
		if(_EN_PROCESS_PARTITION_REDUCE == ON && globalparamsK.ENABLE_APPLYUPDATESCOMMAND == ON){  // CRITICAL REMOVEME URGENT.
			// retreived pre-processed llp_set information first
			workload_t workload_kvs;
			if(globalparamsK.ACTSPARAMS_TREEDEPTH == 1){
				workload_kvs.offset_begin = MEMACCESS{{context['id']}}_getdata(kvdram, vbuffer_source[0], globalparamsE.BASEOFFSETKVS_EDGESMAP, sweepparams.source_partition) / UPDATEDATA_PACKINGSIZE;
				workload_kvs.offset_end = MEMACCESS{{context['id']}}_getdata(kvdram, vbuffer_source[1], globalparamsE.BASEOFFSETKVS_EDGESMAP, sweepparams.source_partition + 1) / UPDATEDATA_PACKINGSIZE;
			} else { workload_kvs.offset_begin = ptravstate.begin_kvs; workload_kvs.offset_end = ptravstate.end_kvs; }
			workload_kvs.size = workload_kvs.offset_end - workload_kvs.offset_begin;
			#ifdef _DEBUGMODE_CHECKS3
			if(workload_kvs.offset_end < workload_kvs.offset_begin){ cout<<"actit3(reduce): ERROR 23: workload_kvs.offset_end("<<workload_kvs.offset_end<<") < workload_kvs.offset_begin("<<workload_kvs.offset_begin<<"). EXITING..."<<endl; exit(EXIT_FAILURE); }
			#endif
		
			// ACTS{{context['id']}}_read_and_reduce(mode, kvdram, vbuffer_dest,	
				// sweepparams, sourcebaseaddr_kvs, workload_kvs,
					// collections_tmp, globalparamsK, globalposition);
			ACTS{{context['id']}}_read_and_reduce(mode, kvdram, vbuffer_source,	
				sweepparams, sourcebaseaddr_kvs, workload_kvs,
					collections_tmp, globalparamsK, globalposition);
		}
		
		collections[TRAVERSEDEDGES_COLLECTIONID] = collections_tmp[TRAVERSEDEDGES_COLLECTIONID];
		collections[PROCESSEDGES_COLLECTIONID] = collections_tmp[PROCESSEDGES_COLLECTIONID];
		collections[ACTIVEEDGESPROCESSED_COLLECTIONID] = collections_tmp[ACTIVEEDGESPROCESSED_COLLECTIONID];
		collections[REDUCEUPDATES_COLLECTIONID] = collections_tmp[REDUCEUPDATES_COLLECTIONID];
	}
}

void {{context['classname__acts']}}ACTS{{context['id']}}_actit_base(bool_type enable, unsigned int mode,
		uint512_dt * kvdram, keyvalue_vbuffer_t vbuffer_source[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VSRCDATA_SIZE], keyvalue_vbuffer_t vbuffer_dest[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VDESTDATA_SIZE], keyvalue_t globalcapsule[BLOCKRAM_GLOBALSTATS_SIZE],				
		globalparams_t globalparamsE, globalparams_t globalparamsK, globalposition_t globalposition, sweepparams_t sweepparams, travstate_t ptravstate, batch_type sourcebaseaddr_kvs, batch_type destbaseaddr_kvs,
		bool_type resetenv, bool_type flush, unsigned int edgebankID, collection_t collections[COLLECTIONS_BUFFERSZ]){
	ACTS{{context['id']}}_actit(enable, mode, kvdram, vbuffer_source, vbuffer_dest, globalcapsule, globalparamsE, globalparamsK, globalposition, sweepparams, ptravstate, sourcebaseaddr_kvs, destbaseaddr_kvs, resetenv, flush, edgebankID, collections);
}