uint512_vec_dt updates_vecs[NUM_VALID_PEs];
max_limit = 0; for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ limits[inst] = actpackupdates_dram___size[inst][p_v]; } for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ if(max_limit < limits[inst]){ max_limit = limits[inst]; }}

// cout<<"------------------------------------------------------ ___ENABLETEST___APPLYUPDATES___II1___:: max_limit: "<<max_limit<<endl;
// for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
	// cout<<"------------------------------------------------------ ___ENABLETEST___APPLYUPDATES___II1___:: actpackupdates_dram___size["<<inst<<"]["<<p_v<<"]: "<<actpackupdates_dram___size[inst][p_v]<<endl;
// }

unsigned int it=0;
// APPLY_UPDATES_LOOP1: for(unsigned int it=0; it<((max_limit + (BLOCKRAM_SIZE - 1)) / BLOCKRAM_SIZE) - 1; it++){
// #pragma HLS loop_flatten off
	// std::cout<<"------------------------------------------------------ ___ENABLETEST___APPLYUPDATES___II1___:: it: "<<it<<std::endl;
	
	// unsigned int sz = 0; if((it + 1) * BLOCKRAM_SIZE >= max_limit){ sz = max_limit - (it * BLOCKRAM_SIZE); } else { sz = BLOCKRAM_SIZE; }
	APPLY_UPDATES_LOOP1A: for(unsigned int t_=0; t_<64 * BLOCKRAM_SIZE; t_++){ //>>> sz, BLOCKRAM_SIZE
	#pragma HLS loop_flatten off
	#pragma HLS PIPELINE II=1
		/////////////////////////////////////////////////////////////////////////
		// unsigned int t = (it * BLOCKRAM_SIZE) + t_;
		// dretrievemany_udatesdram(globalparams[GLOBALPARAMSCODE__BASEOFFSET__UPDATES] + updatesptrs[p_v], p_v, t, updates_vecs, {% include 'arguments_allchannelsinslr.template' %}, updatesptrs); // NEW
		///////////////////////////////////////////////////////////////////////
		unsigned int t = t_; ///////////////////// FIXME.REMOVEME.
		{%for n in context['NUM_VALID_PEs_seq']%}
		{%for v in context['HBM_AXI_PACK_SIZE_seq']%} /////////////////
		updates_vecs[{{n}}].data[{{v}}].key = HBM_channelB{{n}}[globalparams[GLOBALPARAMSCODE__BASEOFFSET__UPDATES] + updatesptrs[p_v] + (it * BLOCKRAM_SIZE) + t_].data[{{v}}];
		{%endfor%}	
		{%endfor%}	
		/////////////////////////////////////////////////////////////////////////
		
		MY_LOOP1521: for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ 
		#pragma HLS UNROLL
			if(t < limits[inst]){
				uint512_vec_dt updates_vec = updates_vecs[inst];
				APPLY_UPDATES_LOOP1C: for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
				#pragma HLS UNROLL
					keyvalue_t update = updates_vec.data[v];
					unsigned int dstvid_lp = update.key; 
					// unsigned int dstvid_lpv = update.key / EDGE_PACK_SIZE;
					unsigned int dstvid_lpv = update.key % 512; // REMOVEME.
					// if(update.key != INVALIDDATA && update.key < MAX_APPLYPARTITION_SIZE){
						#ifdef _DEBUGMODE_CHECKS3___________
						#ifndef ___FORCE_SUCCESS___
						if(t < limits[inst] && ((dstvid_lp % EDGE_PACK_SIZE) != v)){ cout<<"acts_kernel 234:: dstvid_lp("<<dstvid_lp<<") % v("<<v<<") != 0. EXITING..."<<endl; exit(EXIT_FAILURE); }
						#endif 
						if(t < limits[inst]){ checkoutofbounds("acts_kernel::ERROR 727a::", dstvid_lp, MAX_APPLYPARTITION_SIZE, NAp, inst, update.key); checkoutofbounds("acts_kernel::ERROR 727b::", dstvid_lpv, MAX_APPLYPARTITION_VECSIZE, NAp, inst, update.key); }
						#endif
						// vprop_t vprop =  retrieve_vdatabuffer(v, dstvid_lpv, vdata_buffer[inst]);
						vprop_t vprop; vprop.prop = update.key; ////////////////
						// unsigned int new_vprop = reduce_funcG(vprop.prop, vprop.prop, update.value, globalparams[GLOBALPARAMSCODE__PARAM__ALGORITHM]);
						unsigned int new_vprop = reduce_funcG(vprop.prop, vprop.prop, it+t_, globalparams[GLOBALPARAMSCODE__PARAM__ALGORITHM]); // REMOVEME.
						// if(new_vprop != vprop.prop && t < limits[inst]){ 
							#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
							std::cout<<"APPLY (ACT-PACK) UPDATE SEEN @: inst: ["<<inst<<"]: dstvid_lp: "<<dstvid_lp<<", dstvid_lpv: "<<dstvid_lpv<<", new_vprop: "<<new_vprop<<", vid: "<<update.key<<std::endl;
							#endif
							vprop_t newprop; newprop.prop = new_vprop; newprop.mask = MASK_CODE_AU;
							insert_vdatabuffer(v, dstvid_lpv, newprop, vdata_buffer[inst]);
						// }
					// }
				}
			}
		}
		update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___APPLYUPDATES___, 1);
	}
// }	
				