#include "../include/common.h"
#ifndef FPGA_IMPL
#include "acts_kernel.h"
using namespace std;
#endif 
// __NOT__YET__IMPLEMENTED___
// __OBSOLETE___
// #define ___FALSE___ 

#define ___ENABLE___RESETBUFFERSATSTART___ 
#define ___ENABLE___CLEAR_COUNTERS___
#define ___ENABLE___PROCESSEDGES___ 
#define ___ENABLE___READ_FRONTIER_PROPERTIES___
#define ___ENABLE___RESET_BUFFERS___
#define ___ENABLE___VCPROCESSEDGES___ 
#define ___ENABLE___ECPROCESSEDGES___II1___ 
// #define ___ENABLE___ECPROCESSEDGES___II2___
#define ___ENABLE___SAVEVCUPDATES___ 
// // // // // // // // // // // // // // // // // // #define ___ENABLE___COLLECTACTIVEDSTVIDS___ 
#define ___ENABLE___APPLYUPDATESMODULE___ 
	#define ___ENABLE___READ_DEST_PROPERTIES___ 
	#define ___ENABLE___APPLYUPDATES___II1___
	// #define ___ENABLE___APPLYUPDATES___II2___ 
	#define ___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___ 
	#define ___ENABLE___SAVE_DEST_PROPERTIES___ 
#define ___ENABLE___EXCHANGEFRONTIERINFOS___ 
#define ___ENABLE___REPORT_STATISTICS___

#define ___CODE___RESETBUFFERSATSTART___ 0
#define ___CODE___PROCESSEDGES___ 1
#define ___CODE___READ_FRONTIER_PROPERTIES___ 2
#define ___CODE___VCPROCESSEDGES___ 3
#define ___CODE___ECPROCESSEDGES___ 4
#define ___CODE___SAVEVCUPDATES___ 5
#define ___CODE___COLLECTACTIVEDSTVIDS___ 6
#define ___CODE___APPLYUPDATESMODULE___ 7
	#define ___CODE___READ_DEST_PROPERTIES___ 8
	#define ___CODE___APPLYUPDATES___ 9
	#define ___CODE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___ 10
	#define ___CODE___SAVE_DEST_PROPERTIES___ 11
#define ___CODE___EXCHANGEFRONTIERINFOS___ 12

#define MAXVALID_APPLYPARTITION_VECSIZE (MAX_APPLYPARTITION_VECSIZE >> POW_VALID_VDATA)

#ifdef FPGA_IMPL
#define MY_IFDEF_NFRONTIER() keyvalue_t nfrontier_buffer[EDGE_PACK_SIZE][MAX_ACTVV_VECSIZE]
#define MY_IFDEF_CFRONTIER_TMP() keyvalue_t cfrontier_buffer_tmp[EDGE_PACK_SIZE][MAXVALID_APPLYPARTITION_VECSIZE]
#define MY_IFDEF_CFRONTIER() keyvalue_t cfrontier_buffer[NUM_VALID_PEs][MAXVALID_APPLYPARTITION_VECSIZE]
#define MY_IFDEF_STATSBUFFERMASKBASED_TMP() unsigned int statsbuffer_maskbased_tmp[EDGE_PACK_SIZE][BLOCKRAM_SIZE]	
#define MY_IFDEF_STATSBUFFERMASKBASED() unsigned int statsbuffer_maskbased[MAX_NUM_APPLYPARTITIONS][BLOCKRAM_SIZE]	
#define MY_IFDEF_STATSBUFFERIDBASED() unsigned int statsbuffer_idbased[MAX_NUM_APPLYPARTITIONS][BLOCKRAM_SIZE]	
#define MY_IFDEF_UPDATESTMPBUFFER() keyvalue_t updates_buffer2[UPDATES_BUFFER_PACK_SIZE][UPDATES_BUFFER_SIZE]	
#define MY_IFDEF_VPTRBUFFER() vtr_t vptr_buffer[VPTR_BUFFER_SIZE]
#define MY_IFDEF_EDGESBUFFER() edge3_type edges_buffer[EDGE_PACK_SIZE][EDGE_BUFFER_SIZE]
#define MY_IFDEF_VDATABUFFER() vprop_t vdata_buffer[EDGE_PACK_SIZE][MAXVALID_APPLYPARTITION_VECSIZE]
#define MY_IFDEF_TOPLEVELFUNC() void top_function({% include 'parameters_allchannelsinslr.template' %}, HBM_channelAXI_t * HBM_centerA, HBM_channelAXI_t * HBM_centerB)
#else
#define MY_IFDEF_NFRONTIER() keyvalue_t * nfrontier_buffer[EDGE_PACK_SIZE]
#define MY_IFDEF_CFRONTIER_TMP() keyvalue_t * cfrontier_buffer_tmp[EDGE_PACK_SIZE]
#define MY_IFDEF_CFRONTIER() keyvalue_t * cfrontier_buffer[NUM_VALID_PEs]
#define MY_IFDEF_STATSBUFFERMASKBASED_TMP() unsigned int * statsbuffer_maskbased_tmp[EDGE_PACK_SIZE]
#define MY_IFDEF_STATSBUFFERMASKBASED() unsigned int * statsbuffer_maskbased[MAX_NUM_APPLYPARTITIONS]
#define MY_IFDEF_STATSBUFFERIDBASED() unsigned int * statsbuffer_idbased[MAX_NUM_APPLYPARTITIONS]
#define MY_IFDEF_UPDATESTMPBUFFER() keyvalue_t * updates_buffer2[UPDATES_BUFFER_PACK_SIZE]
#define MY_IFDEF_VPTRBUFFER() vtr_t * vptr_buffer
#define MY_IFDEF_EDGESBUFFER() edge3_type * edges_buffer[EDGE_PACK_SIZE]
#define MY_IFDEF_VDATABUFFER() vprop_t * vdata_buffer[EDGE_PACK_SIZE]
#define MY_IFDEF_TOPLEVELFUNC() void acts_kernel::top_function({% include 'parameters_allchannelsinslr.template' %}, HBM_channelAXI_t * HBM_centerA, HBM_channelAXI_t * HBM_centerB)
#endif

#ifndef FPGA_IMPL
unsigned int * globalparams_debug;
unsigned int _NUMCLOCKCYCLES_[2][16]; 
#endif 

#ifndef FPGA_IMPL
acts_kernel::acts_kernel(universalparams_t _universalparams){
	utilityobj = new utility(_universalparams);
	universalparams = _universalparams;
	algorithmobj = new algorithm();
}
acts_kernel::~acts_kernel(){} 
#endif 

{% include '___ENABLE___UTILFUNCS___.template' %}	

{% include '___ENABLE___ACCESSHBM___.template' %}	

{% include '___ENABLE___ACCESSBRAM___.template' %}	

//////////////////////////////////////////////////////////////////
void load_edges(unsigned int inst, unsigned int offset_vptrbuffer, unsigned int baseoffset_csrdram, unsigned int vptrbuffer___size, MY_IFDEF_VPTRBUFFER(), unsigned int * edges_buffer___size, MY_IFDEF_EDGESBUFFER(), HBM_channelAXI_t * HBM_channelA, HBM_channelAXI_t * HBM_channelB){
	if(offset_vptrbuffer < vptrbuffer___size){ // NEW
		vtr_t vptr_data = retrieve_vptrbuffer(offset_vptrbuffer, vptr_buffer); 
		unsigned int vid = vptr_data.vid;
		unsigned int edges_size = vptr_data.end - vptr_data.begin; 
		unsigned int edgelist_size = (edges_size / EDGE_PACK_SIZE) + 2; if((edges_size == 0) || (vptr_data.end < vptr_data.begin)){ edgelist_size = 0; }
		unsigned int uprop = vptr_data.prop;
		
		#ifdef ___FORCE_SUCCESS___
		if(*edges_buffer___size + edgelist_size >= EDGE_BUFFER_SIZE){ edgelist_size = EDGE_BUFFER_SIZE - *edges_buffer___size; }
		#endif
		
		VC_READ_EDGES_LOOP1B: for(unsigned int t=0; t<edgelist_size; t++){
		#pragma HLS PIPELINE II=1
			edge3_vec_dt edges = dretrieve_csredges(baseoffset_csrdram, (vptr_data.begin / EDGE_PACK_SIZE) + t, HBM_channelA, HBM_channelB, inst);
			edge3_type edge_list[EDGE_PACK_SIZE];
			MY_LOOP711: for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
			#pragma HLS UNROLL
				if(edges.data[v].srcvid == vid && edges.data[v].srcvid != INVALIDDATA){ edge_list[v] = edges.data[v]; edge_list[v].srcvid = uprop; } else { edge_list[v].srcvid = INVALIDDATA; edge_list[v].dstvid = INVALIDDATA; }
			}
			MY_LOOP712: for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
			#pragma HLS UNROLL
				#ifndef FPGA_IMPL
				checkoutofbounds("acts_kernel::ERROR 812::", *edges_buffer___size, EDGE_BUFFER_SIZE, vptrbuffer___size, inst, edgelist_size);
				#endif 
				insert_edgesbuffer(v, *edges_buffer___size, edge_list[v], edges_buffer);
			}
			*edges_buffer___size += 1;	
			#ifndef FPGA_IMPL
			if(inst==0){ update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___VCPROCESSEDGES___, 1); }
			#endif 
		}
	}
	return;
}

void transport_frontier(unsigned int inst, unsigned int p_v, unsigned int baseoffset_nfdram, unsigned int * cfrontier_dram___size, unsigned int * nfrontier_dram___size, offset_t * upartition_vertices, HBM_channelAXI_t * HBM_channelA, HBM_channelAXI_t * HBM_channelB, HBM_channelAXI_t * HBM_centerA, HBM_channelAXI_t * HBM_centerB, unsigned int * totalactvvs2){
	frontier_t actvv[EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = actvv complete
	unsigned int totalactvvs2_tmp[EDGE_PACK_SIZE]; 
	#pragma HLS ARRAY_PARTITION variable = totalactvvs2_tmp complete
	unsigned int data[HBM_CHANNEL_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable=data complete
				
	for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ totalactvvs2_tmp[v] = 0; }
	TRANSPORT_FRONTIER_PROPERTIES_LOOP1: for(unsigned int p_actvv=0; p_actvv<NUM_ACTVVPARTITIONS_PER_APPLYPARTITION; p_actvv++){
		unsigned int p_actvv_ = p_v * NUM_ACTVVPARTITIONS_PER_APPLYPARTITION + p_actvv;
		#ifndef FPGA_IMPL
		checkoutofbounds("acts_kernel::ERROR 225::", p_actvv_, MAX_NUM_UPARTITIONS, NAp, NAp, NAp);
		#endif 
		unsigned int offset_n = baseoffset_nfdram + (p_actvv_ * MAX_APPLYPARTITION_VECSIZE);
		unsigned int offset_c = p_actvv_ * MAX_UPARTITION_VECSIZE;
		unsigned int st = cfrontier_dram___size[p_actvv_];
		TRANSPORT_FRONTIER_PROPERTIES_LOOP1B: for(unsigned int t=0; t<nfrontier_dram___size[p_actvv_]; t++){
		#pragma HLS PIPELINE II=1
			{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
			data[{{v}}] = HBM_channelA[offset_n + t].data[{{v}}];
			{%endfor%}
			{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
			data[{{context['HBM_AXI_PACK_SIZE'] + v}}] = HBM_channelB[offset_n + t].data[{{v}}];
			{%endfor%}
			
			{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
			HBM_centerA[offset_c + st + t].data[{{v}}] = data[{{v}}];
			{%endfor%}
			{%for v in context['HBM_AXI_PACK_SIZE_seq']%}
			HBM_centerB[offset_c + st + t].data[{{v}}] = data[{{context['HBM_AXI_PACK_SIZE'] + v}}];
			{%endfor%}
		
			for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
			#pragma HLS UNROLL
				if(actvv[v].key != INVALIDDATA){ 
					totalactvvs2_tmp[v] += 1;
				}
			}
			#ifndef FPGA_IMPL
			update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___EXCHANGEFRONTIERINFOS___, 1);
			#endif 
				
		}
		upartition_vertices[p_actvv_].count += nfrontier_dram___size[p_actvv_]; 
		cfrontier_dram___size[p_actvv_] += nfrontier_dram___size[p_actvv_];
	}
	for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ *totalactvvs2 += totalactvvs2_tmp[v]; }
}	

//////////////////////////////////////////////////////////////////
extern "C" {	
MY_IFDEF_TOPLEVELFUNC(){		
{%for i in context['NUM_VALID_PEs_seq']%} 
#pragma HLS INTERFACE m_axi port = HBM_channelA{{i}} offset = slave bundle = gmem{{2*i}}
#pragma HLS INTERFACE m_axi port = HBM_channelB{{i}} offset = slave bundle = gmem{{2*i+1}}
{%endfor%}
#pragma HLS INTERFACE m_axi port = HBM_centerA offset = slave bundle = gmem{{2*context['NUM_VALID_PEs']}}
#pragma HLS INTERFACE m_axi port = HBM_centerB offset = slave bundle = gmem{{2*context['NUM_VALID_PEs']+1}}

{%for i in context['NUM_VALID_PEs_seq']%}
#pragma HLS INTERFACE s_axilite port = HBM_channelA{{i}} bundle = control
#pragma HLS INTERFACE s_axilite port = HBM_channelB{{i}} bundle = control
{%endfor%}	
#pragma HLS INTERFACE s_axilite port = HBM_centerA bundle = control
#pragma HLS INTERFACE s_axilite port = HBM_centerB bundle = control

#pragma HLS INTERFACE s_axilite port=return bundle=control

	#ifdef _DEBUGMODE_KERNELPRINTS4
	cout<<"acts_kernel::run:: acts started "<<endl;
	#endif 
	
	// declaration of BRAM variables
	#ifdef FPGA_IMPL
	keyvalue_t nfrontier_buffer[NUM_VALID_PEs][EDGE_PACK_SIZE][MAX_ACTVV_VECSIZE]; 
	#pragma HLS ARRAY_PARTITION variable=nfrontier_buffer complete dim=1
    #pragma HLS ARRAY_PARTITION variable=nfrontier_buffer complete dim=2
	keyvalue_t cfrontier_buffer_tmp[EDGE_PACK_SIZE][MAXVALID_APPLYPARTITION_VECSIZE]; 
	#pragma HLS resource variable=cfrontier_buffer_tmp core=XPM_MEMORY uram
	#pragma HLS ARRAY_PARTITION variable=cfrontier_buffer_tmp complete dim=1
	keyvalue_t cfrontier_buffer[NUM_VALID_PEs][MAXVALID_APPLYPARTITION_VECSIZE];
	#pragma HLS resource variable=cfrontier_buffer core=XPM_MEMORY uram
	#pragma HLS ARRAY_PARTITION variable=cfrontier_buffer complete dim=1
	unsigned int statsbuffer_maskbased_tmp[NUM_VALID_PEs][EDGE_PACK_SIZE][BLOCKRAM_SIZE];
	#pragma HLS ARRAY_PARTITION variable=statsbuffer_maskbased_tmp complete dim=1
    #pragma HLS ARRAY_PARTITION variable=statsbuffer_maskbased_tmp complete dim=2
	unsigned int statsbuffer_maskbased[NUM_VALID_PEs][MAX_NUM_APPLYPARTITIONS][BLOCKRAM_SIZE];
	#pragma HLS ARRAY_PARTITION variable=statsbuffer_maskbased complete dim=1
    #pragma HLS ARRAY_PARTITION variable=statsbuffer_maskbased complete dim=2
	unsigned int statsbuffer_idbased[NUM_VALID_PEs][MAX_NUM_APPLYPARTITIONS][BLOCKRAM_SIZE];
	#pragma HLS ARRAY_PARTITION variable=statsbuffer_idbased complete dim=1 
    #pragma HLS ARRAY_PARTITION variable=statsbuffer_idbased complete dim=2
	vtr_t vptr_buffer[NUM_VALID_PEs][VPTR_BUFFER_SIZE];
	#pragma HLS ARRAY_PARTITION variable=vptr_buffer complete dim=1
	edge3_type edges_buffer[NUM_VALID_PEs][EDGE_PACK_SIZE][EDGE_BUFFER_SIZE];
	#pragma HLS ARRAY_PARTITION variable=edges_buffer complete dim=1
    #pragma HLS ARRAY_PARTITION variable=edges_buffer complete dim=2
	keyvalue_t updates_buffer2[NUM_VALID_PEs][UPDATES_BUFFER_PACK_SIZE][UPDATES_BUFFER_SIZE]; // EDGE_PACK_SIZE
	#pragma HLS ARRAY_PARTITION variable=updates_buffer2 complete dim=1
    #pragma HLS ARRAY_PARTITION variable=updates_buffer2 complete dim=2
	vprop_t vdata_buffer[NUM_VALID_PEs][EDGE_PACK_SIZE][MAXVALID_APPLYPARTITION_VECSIZE];
	#pragma HLS resource variable=vdata_buffer core=XPM_MEMORY uram 
	#pragma HLS ARRAY_PARTITION variable=vdata_buffer complete dim=1
    #pragma HLS ARRAY_PARTITION variable=vdata_buffer complete dim=2 
	#pragma HLS aggregate variable=vdata_buffer 
	#else 
	keyvalue_t * nfrontier_buffer[NUM_VALID_PEs][EDGE_PACK_SIZE]; 
	keyvalue_t * cfrontier_buffer_tmp[EDGE_PACK_SIZE]; 
	keyvalue_t * cfrontier_buffer[NUM_VALID_PEs]; 
	unsigned int * statsbuffer_maskbased_tmp[NUM_VALID_PEs][EDGE_PACK_SIZE]; 
	unsigned int * statsbuffer_maskbased[NUM_VALID_PEs][MAX_NUM_APPLYPARTITIONS]; 
	unsigned int * statsbuffer_idbased[NUM_VALID_PEs][MAX_NUM_APPLYPARTITIONS]; 
	vtr_t * vptr_buffer[NUM_VALID_PEs]; 
	edge3_type * edges_buffer[NUM_VALID_PEs][EDGE_PACK_SIZE];
	keyvalue_t * updates_buffer2[NUM_VALID_PEs][UPDATES_BUFFER_PACK_SIZE]; 
	vprop_t * vdata_buffer[NUM_VALID_PEs][EDGE_PACK_SIZE];
	for(unsigned int i=0; i<NUM_VALID_PEs; i++){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ nfrontier_buffer[i][v] = new keyvalue_t[MAX_ACTVV_VECSIZE]; }}
	for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ cfrontier_buffer_tmp[v] = new keyvalue_t[MAX_APPLYPARTITION_VECSIZE]; }
	for(unsigned int i=0; i<NUM_VALID_PEs; i++){ cfrontier_buffer[i] = new keyvalue_t[MAX_APPLYPARTITION_VECSIZE]; }
	for(unsigned int i=0; i<NUM_VALID_PEs; i++){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ statsbuffer_maskbased_tmp[i][v] = new unsigned int[BLOCKRAM_SIZE]; }}
	for(unsigned int i=0; i<NUM_VALID_PEs; i++){ for(unsigned int v=0; v<MAX_NUM_APPLYPARTITIONS; v++){ statsbuffer_maskbased[i][v] = new unsigned int[BLOCKRAM_SIZE]; }}
	for(unsigned int i=0; i<NUM_VALID_PEs; i++){ for(unsigned int v=0; v<MAX_NUM_APPLYPARTITIONS; v++){ statsbuffer_idbased[i][v] = new unsigned int[BLOCKRAM_SIZE]; }}
	for(unsigned int i=0; i<NUM_VALID_PEs; i++){ vptr_buffer[i] = new vtr_t[VPTR_BUFFER_SIZE]; }
	for(unsigned int i=0; i<NUM_VALID_PEs; i++){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ edges_buffer[i][v] = new edge3_type[EDGE_BUFFER_SIZE]; }}
	for(unsigned int i=0; i<NUM_VALID_PEs; i++){ for(unsigned int v=0; v<UPDATES_BUFFER_PACK_SIZE; v++){ updates_buffer2[i][v] = new keyvalue_t[UPDATES_BUFFER_SIZE]; }}
	for(unsigned int i=0; i<NUM_VALID_PEs; i++){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ vdata_buffer[i][v] = new vprop_t[MAX_APPLYPARTITION_VECSIZE]; }}
	#endif 
	
	#ifdef FPGA_IMPL	
	unsigned int cfrontier_dram___size[MAX_NUM_UPARTITIONS]; 
	unsigned int nfrontier_dram___size[NUM_VALID_PEs][MAX_NUM_UPARTITIONS];
	#pragma HLS ARRAY_PARTITION variable = nfrontier_dram___size complete dim=1
	unsigned int nfrontier_buffer___size[NUM_VALID_PEs][EDGE_PACK_SIZE][NUM_ACTVVPARTITIONS_PER_APPLYPARTITION]; 
	#pragma HLS ARRAY_PARTITION variable = nfrontier_buffer___size complete dim=1
	#pragma HLS ARRAY_PARTITION variable = nfrontier_buffer___size complete dim=2
	unsigned int updates_tmpbuffer___size[NUM_VALID_PEs][NUM_VALID_PEs]; 
	#pragma HLS ARRAY_PARTITION variable = updates_tmpbuffer___size complete dim=1
	unsigned int updates_buffer___size[NUM_VALID_PEs][EDGE_PACK_SIZE][MAX_NUM_APPLYPARTITIONS]; 
	#pragma HLS ARRAY_PARTITION variable = updates_buffer___size complete dim=1
	#pragma HLS ARRAY_PARTITION variable = updates_buffer___size complete dim=2
	unsigned int stats_buffer___size[NUM_VALID_PEs][MAX_NUM_APPLYPARTITIONS]; 
	#pragma HLS ARRAY_PARTITION variable = stats_buffer___size complete dim=1
	unsigned int statsbuffer_idbased___size[NUM_VALID_PEs][MAX_NUM_APPLYPARTITIONS]; 
	#pragma HLS ARRAY_PARTITION variable = statsbuffer_idbased___size complete dim=1
	offset_t upartition_vertices[MAX_NUM_UPARTITIONS]; 
	offset_t vpartition_vertices[NUM_VALID_PEs][MAX_NUM_APPLYPARTITIONS]; 
	#pragma HLS ARRAY_PARTITION variable = vpartition_vertices complete dim=1
	unsigned int actpackupdates_dram___size[NUM_VALID_PEs][MAX_NUM_APPLYPARTITIONS]; 
	#pragma HLS ARRAY_PARTITION variable = actpackupdates_dram___size complete dim=1
	unsigned int vptrbuffer___size[NUM_VALID_PEs]; 
	#pragma HLS ARRAY_PARTITION variable = vptrbuffer___size complete // dim=1
	unsigned int edges_buffer___size[NUM_VALID_PEs]; 
	#pragma HLS ARRAY_PARTITION variable = edges_buffer___size complete // dim=1
	unsigned int cfrontier_bufferREAL___size[NUM_VALID_PEs]; 
	#pragma HLS ARRAY_PARTITION variable = cfrontier_bufferREAL___size complete
	#pragma HLS ARRAY_MAP variable=nfrontier_dram___size instance=array1 horizontal
	#pragma HLS ARRAY_MAP variable=stats_buffer___size instance=array1 horizontal
	#pragma HLS ARRAY_MAP variable=statsbuffer_idbased___size instance=array1 horizontal
	#pragma HLS ARRAY_MAP variable=vpartition_vertices instance=array1 horizontal
	#pragma HLS ARRAY_MAP variable=actpackupdates_dram___size instance=array1 horizontal
	#pragma HLS ARRAY_MAP variable=vptrbuffer___size instance=array2 horizontal
	#pragma HLS ARRAY_MAP variable=edges_buffer___size instance=array2 horizontal
	#ifndef HW
	unsigned int hybrid_map[MAXNUMGRAPHITERATIONS][MAX_NUM_UPARTITIONS]; 
	#endif 
	#else 
	unsigned int * cfrontier_dram___size = new unsigned int[MAX_NUM_UPARTITIONS]; 
	unsigned int * nfrontier_dram___size[NUM_VALID_PEs]; for(unsigned int i=0; i<NUM_VALID_PEs; i++){ nfrontier_dram___size[i] = new unsigned int[MAX_NUM_UPARTITIONS]; }
	unsigned int * nfrontier_buffer___size[NUM_VALID_PEs][EDGE_PACK_SIZE]; for(unsigned int i=0; i<NUM_VALID_PEs; i++){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ nfrontier_buffer___size[i][v] = new unsigned int[NUM_ACTVVPARTITIONS_PER_APPLYPARTITION]; }}
	unsigned int updates_tmpbuffer___size[NUM_VALID_PEs][NUM_VALID_PEs]; 
	unsigned int * updates_buffer___size[NUM_VALID_PEs][EDGE_PACK_SIZE]; for(unsigned int i=0; i<NUM_VALID_PEs; i++){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ updates_buffer___size[i][v] = new unsigned int[MAX_NUM_APPLYPARTITIONS]; }}
	unsigned int stats_buffer___size[NUM_VALID_PEs][MAX_NUM_APPLYPARTITIONS]; 
	unsigned int statsbuffer_idbased___size[NUM_VALID_PEs][MAX_NUM_APPLYPARTITIONS]; 
	offset_t * upartition_vertices = new offset_t[MAX_NUM_UPARTITIONS]; 
	offset_t * vpartition_vertices[NUM_VALID_PEs]; for(unsigned int i=0; i<NUM_VALID_PEs; i++){ vpartition_vertices[i] = new offset_t[MAX_NUM_APPLYPARTITIONS];  }
	unsigned int actpackupdates_dram___size[NUM_VALID_PEs][MAX_NUM_APPLYPARTITIONS]; 
	unsigned int vptrbuffer___size[NUM_VALID_PEs]; 
	unsigned int edges_buffer___size[NUM_VALID_PEs]; 
	unsigned int cfrontier_bufferREAL___size[NUM_VALID_PEs]; 
	unsigned int * hybrid_map[MAXNUMGRAPHITERATIONS]; for(unsigned int i=0; i<MAXNUMGRAPHITERATIONS; i++){ hybrid_map[i] = new unsigned int[MAX_NUM_UPARTITIONS]; }
	#endif 
	
	edge3_type edges[NUM_VALID_PEs][EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = edges complete dim=0
	unsigned int res[NUM_VALID_PEs][EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = res complete dim=0
	unsigned int vtemp_in[NUM_VALID_PEs][EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = vtemp_in complete dim=0
	unsigned int vtemp_out[NUM_VALID_PEs][EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = vtemp_out complete dim=0
	vprop_t uprop[NUM_VALID_PEs][EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = uprop complete dim=0
	keyvalue_t update_in[NUM_VALID_PEs][EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = update_in complete dim=0
	keyvalue_t update_out[NUM_VALID_PEs][EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = update_out complete dim=0
	bool ens[NUM_VALID_PEs][EDGE_PACK_SIZE]; 
	#pragma HLS ARRAY_PARTITION variable = ens complete dim=0
	vprop_t data[EDGE_PACK_SIZE]; 
	#pragma HLS ARRAY_PARTITION variable = data complete
	vprop_t datas[NUM_VALID_PEs][EDGE_PACK_SIZE]; 
	#pragma HLS ARRAY_PARTITION variable = datas complete dim=0
	keyvalue_t kvdata[EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = kvdata complete
	keyvalue_t kvdatas[NUM_VALID_PEs][EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = kvdatas complete dim=0
	unsigned int offsets0[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable = offsets0 complete
	unsigned int offsets[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable = offsets complete
	unsigned int offsets2[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable = offsets2 complete
	unsigned int counts[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable = counts complete
	keyvalue_t actvvs[NUM_VALID_PEs][EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable = actvvs complete dim=0
	frontier_t actvv[EDGE_PACK_SIZE];
	unsigned int vid_first0[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable = vid_first0 complete
	unsigned int vid_first1[NUM_VALID_PEs]; 
	#pragma HLS ARRAY_PARTITION variable = vid_first1 complete
	unsigned int globalparams[GLOBALBUFFER_SIZE];
	unsigned int updatesptrs[MAX_NUM_LLPSETS];
	unsigned int limits[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable = limits complete
	unsigned int max_limits[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable = max_limits complete
	uint512_vec_dt updates_vecs[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable = updates_vecs complete
	uint512_vec_dt edges_vecs[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable = edges_vecs complete
	unsigned int stats_count[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable=stats_count complete
	unsigned int stats_counts[NUM_VALID_PEs][EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable=stats_counts complete dim=0
	unsigned int cummtv2[NUM_VALID_PEs]; 
	#pragma HLS ARRAY_PARTITION variable = cummtv2 complete
	unsigned int masks[NUM_VALID_PEs][EDGE_PACK_SIZE];
	#pragma HLS ARRAY_PARTITION variable=masks complete dim=0
	edge3_vec_dt edge3_vecs[NUM_VALID_PEs]; 
	#pragma HLS ARRAY_PARTITION variable=edge3_vecs complete
	map_t maps[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable=maps complete	
	#ifdef FPGA_IMPL
	unsigned int _NUMCLOCKCYCLES_[2][16]; 
	#endif 
	
	unsigned int maxGraphIter = 0;
	unsigned int total_num_actvvs = 0; 
	bool enable___vertexcentric = true;
	#ifdef ___ENABLE___COLLECTACTIVEDSTVIDS___
	bool enable___collectactivedstvids = true;
	#else 
	bool enable___collectactivedstvids = false; // false
	#endif 
	unsigned int max_limit = 0, max_limit2 = 0; 
	unsigned int CONST1 = NUM_PEs * EDGE_PACK_SIZE; 
	unsigned int CONST2 = MAX_ACTVV_VECSIZE * NUM_PEs * EDGE_PACK_SIZE;
	for(unsigned int k=0; k<2; k++){ for(unsigned int t=0; t<16; t++){ _NUMCLOCKCYCLES_[k][t] = 0; } }
	unsigned int total_cycles = 0;
	
	// load global parameters	
	MY_LOOP209: for(unsigned int t=0; t<GLOBALBUFFER_SIZE; t++){
	#pragma HLS PIPELINE II=1
		globalparams[t] = dretrieve_globalparams(0, t, HBM_channelA0, HBM_channelB0, 0);
	}
	unsigned int __NUM_UPARTITIONS = globalparams[GLOBALPARAMSCODE__PARAM__NUM_UPARTITIONS];
	unsigned int __NUM_APPLYPARTITIONS = globalparams[GLOBALPARAMSCODE__PARAM__NUM_APPLYPARTITIONS]; 
	#ifndef FPGA_IMPL
	globalparams_debug = (unsigned int *)&globalparams[0];
	#endif
	
	int ___ENABLE___RESETBUFFERSATSTART___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___RESETBUFFERSATSTART];
	int ___ENABLE___PROCESSEDGES___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___PROCESSEDGES];
	int ___ENABLE___READ_FRONTIER_PROPERTIES___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___READ_FRONTIER_PROPERTIES];
	int ___ENABLE___VCPROCESSEDGES___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___VCPROCESSEDGES]; 
	int ___ENABLE___ECPROCESSEDGES___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___ECPROCESSEDGES]; 
	int ___ENABLE___SAVEVCUPDATES___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___SAVEVCUPDATES]; 
	int ___ENABLE___COLLECTACTIVEDSTVIDS___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___COLLECTACTIVEDSTVIDS];
	int ___ENABLE___APPLYUPDATESMODULE___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___APPLYUPDATESMODULE]; 
		int ___ENABLE___READ_DEST_PROPERTIES___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___READ_DEST_PROPERTIES];
		int ___ENABLE___APPLYUPDATES___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___APPLYUPDATES]; 
		int ___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES]; 
		int ___ENABLE___SAVE_DEST_PROPERTIES___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___SAVE_DEST_PROPERTIES]; 
	int ___ENABLE___EXCHANGEFRONTIERINFOS___BOOL___ = globalparams[GLOBALPARAMSCODE___ENABLE___EXCHANGEFRONTIERINFOS]; 
	
	unsigned int threshold___activedstvids = globalparams[GLOBALPARAMSCODE__PARAM__THRESHOLD__ACTIVEDSTVID];
	
	#ifdef ___ENABLE___RESETBUFFERSATSTART___
	if(___ENABLE___RESETBUFFERSATSTART___BOOL___ == 1){
	{% include '___ENABLE___RESETBUFFERSATSTART___.template' %}		
	}
	#endif
	
	bool all_vertices_active_in_all_iterations = false; 
	if(globalparams[GLOBALPARAMSCODE__PARAM__ALGORITHM] == PAGERANK || globalparams[GLOBALPARAMSCODE__PARAM__ALGORITHM] == CF || globalparams[GLOBALPARAMSCODE__PARAM__ALGORITHM] == HITS || globalparams[GLOBALPARAMSCODE__PARAM__ALGORITHM] == SPMV){ all_vertices_active_in_all_iterations = true; }
	if(all_vertices_active_in_all_iterations == true){ cfrontier_dram___size[0] = MAXVALID_APPLYPARTITION_VECSIZE; } else { cfrontier_dram___size[0] = 1; }// activate root vid
	unsigned int threshold___activefrontiers = globalparams[GLOBALPARAMSCODE__PARAM__THRESHOLD__ACTIVEFRONTIERSFORCONTROLSWITCH]; 
	
	#ifdef _DEBUGMODE_KERNELPRINTS4
	cout<<"=== acts_kernel::run:: parameters ==="<<endl;
	cout<<"=== num vertices: "<<globalparams[GLOBALPARAMSCODE__PARAM__NUM_VERTICES]<<" === "<<endl;
	cout<<"=== num edges: "<<globalparams[GLOBALPARAMSCODE__PARAM__NUM_EDGES]<<" === "<<endl;
	cout<<"=== num_pes: "<<NUM_VALID_PEs<<" === "<<endl;
	cout<<"=== EDGE_PACK_SIZE: "<<EDGE_PACK_SIZE<<" === "<<endl;
	cout<<"=== MAX_UPARTITION_SIZE: "<<MAX_UPARTITION_SIZE<<" === "<<endl;
	cout<<"=== NUM_UPARTITIONS: "<<__NUM_UPARTITIONS<<" === "<<endl;
	cout<<"=== MAX_APPLYPARTITION_SIZE: "<<MAX_APPLYPARTITION_SIZE<<" === "<<endl;
	cout<<"=== NUM_APPLYPARTITIONS: "<<__NUM_APPLYPARTITIONS<<" === "<<endl;
	cout<<"=== MULT_FACTOR: "<<MULT_FACTOR<<" === "<<endl;
	cout<<"---------------------------------------------------------------------- ACTS running "<<NUM_VALID_PEs<<" instances ----------------------------------------------------------------------"<<endl;
	cout<<"### GAS iteration: 0 [1 active vertices]"<<endl; 
	#endif 
	
	// reset ubuffer 
	vprop_t prop; prop.prop = 0; prop.mask = INVALIDMASK; 
	MY_LOOP195: for(unsigned int t=0; t<MAX_UPARTITION_VECSIZE; t++){ 
	#pragma HLS PIPELINE II=1
		MY_LOOP194: for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ 
		#pragma HLS UNROLL
			MY_LOOP196: for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
			#pragma HLS UNROLL
				insert_vdatabuffer(v, t, prop, vdata_buffer[inst]); 
			}
		}
		update_bramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___READ_FRONTIER_PROPERTIES___, 1);
	}
	
	// load updates ptrs
	MY_LOOP193: for(unsigned int t=0; t<MAX_NUM_LLPSETS; t++){
	#pragma HLS PIPELINE II=1
		updatesptrs[t] = dretrieve_updatesptrs(globalparams[GLOBALPARAMSCODE__BASEOFFSET__UPDATESPTRS], t, HBM_channelA0, HBM_channelB0, 0);
		#ifdef _DEBUGMODE_KERNELPRINTS//4
		cout<<"--- updatesptrs["<<t<<"]: "<<updatesptrs[t]<<endl;
		#endif 
	}

	// run acts 
	RUN_ACTS_LOOP: for(unsigned int GraphIter=0; GraphIter<globalparams[GLOBALPARAMSCODE__PARAM__NUM_ITERATIONS]; GraphIter++){
		unsigned int MASK_CODE = 1 + GraphIter;
		unsigned int MASK_CODE_PE = 1 + GraphIter;
		unsigned int MASK_CODE_AU = 4094 + 1 + GraphIter;
		
		// clear counters [done]
		#ifdef ___ENABLE___CLEAR_COUNTERS___
		{% include '___ENABLE___CLEAR_COUNTERS___.template' %}	
		#endif 
				
		// process-edges and partition-updates
		PROCESS_EDGES_MODULE_LOOP1: for(unsigned int sweep=0; sweep<2; sweep++){
			// process-edges and partition-updates
			#ifdef ___ENABLE___PROCESSEDGES___
			if(___ENABLE___PROCESSEDGES___BOOL___ == 1){
			PROCESS_EDGES_MODULE_LOOP1B: for(unsigned int p_u=0; p_u<__NUM_UPARTITIONS; p_u++){
				MASK_CODE_PE = ((1 + GraphIter) * MAX_NUM_UPARTITIONS) + p_u;
				bool ___use_vertex_centric___ = false; 
				bool en = false;
				if((upartition_vertices[p_u].count < threshold___activefrontiers && enable___vertexcentric == true) && (all_vertices_active_in_all_iterations == false)){ ___use_vertex_centric___ = true; } else { ___use_vertex_centric___ = false; }
				
				// read & map frontier properties 
				#ifdef ___ENABLE___READ_FRONTIER_PROPERTIES___
				if(___ENABLE___READ_FRONTIER_PROPERTIES___BOOL___ == 1){ 
				{% include '___ENABLE___READ_FRONTIER_PROPERTIES___.template' %}	
				}
				#endif 
				
				// reset buffers [done]
				#ifdef ___ENABLE___RESET_BUFFERS___
				{% include '___ENABLE___RESET_BUFFERS___.template' %}	
				#endif 
		
				// process-edges and partition-updates
				if(upartition_vertices[p_u].count > 0 || all_vertices_active_in_all_iterations == true){
					if(sweep == 0 && ___use_vertex_centric___ == true){
						#ifdef ___ENABLE___VCPROCESSEDGES___
						if(___ENABLE___VCPROCESSEDGES___BOOL___ == 1){
						{% include '___ENABLE___VCPROCESSEDGES___.template' %}	
						}
						#endif 
					} else if (sweep == 1  && ___use_vertex_centric___ == false) { // edge-centric [done]
						#ifdef ___ENABLE___ECPROCESSEDGES___II1___
						if(___ENABLE___ECPROCESSEDGES___BOOL___ == 1){
						{% include '___ENABLE___ECPROCESSEDGES___II1___.template' %}	
						}
						#endif
					} else {
						// do nothing
					}
				}
			}
			}
			#endif 
			
			// save csr updates [done]
			#ifdef ___ENABLE___SAVEVCUPDATES___
			if(___ENABLE___SAVEVCUPDATES___BOOL___ == 1){	
			{% include '___ENABLE___SAVEVCUPDATES___.template' %}		
			}
			#endif 
		}
		
		// prepare active destID stats [done] 
		#ifdef ___ENABLE___COLLECTACTIVEDSTVIDS___
		if(___ENABLE___COLLECTACTIVEDSTVIDS___BOOL___ == 1){
		{% include '___ENABLE___COLLECTACTIVEDSTVIDS___.template' %}	
		}
		#endif 
		
		// apply updates
		#ifdef ___ENABLE___APPLYUPDATESMODULE___
		if(___ENABLE___APPLYUPDATESMODULE___BOOL___ == 1){
		APPLY_UPDATES_MODULE_LOOP: for(unsigned int p_v=0; p_v<__NUM_APPLYPARTITIONS; p_v++){
			bool en = true; if(enable___collectactivedstvids == true){ if(vpartition_vertices[0][p_v].count > 0){ en=true; } else { en=false; }} else { en = true; }
			unsigned int voffset = globalparams[GLOBALPARAMSCODE__BASEOFFSET__VDATAS] + (p_v * MAX_APPLYPARTITION_VECSIZE);
			
			if(vpartition_vertices[0][p_v].count > 0){ 
				// read destination properties
				#ifdef ___ENABLE___READ_DEST_PROPERTIES___
				if(___ENABLE___READ_DEST_PROPERTIES___BOOL___ == 1){
				{% include '___ENABLE___READ_DEST_PROPERTIES___.template' %}	
				}
				#endif 
				
				// apply updates [done]
				#ifdef ___ENABLE___APPLYUPDATES___II1___ 
				if(___ENABLE___APPLYUPDATES___BOOL___ == 1){
				{% include '___ENABLE___APPLYUPDATES___II1___.template' %}	 
				}
				#endif 
				
				// collect and save frontier information
				#ifdef ___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___
				if(___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___BOOL___ == 1){
				{% include '___ENABLE___COLLECT_AND_SAVE_FRONTIER_PROPERTIES___.template' %}	
				}
				#endif 
				
				// save destination properties
				#ifdef ___ENABLE___SAVE_DEST_PROPERTIES___
				if(___ENABLE___SAVE_DEST_PROPERTIES___BOOL___ == 1){	
				{% include '___ENABLE___SAVE_DEST_PROPERTIES___.template' %}	
				}
				#endif 
			}
		} // p_v
		}
		#endif 
		
		// end of GAS iteration - gathering frontier information
		unsigned int totalactvvs2 = 0; 
		#ifdef ___ENABLE___EXCHANGEFRONTIERINFOS___
		if(___ENABLE___EXCHANGEFRONTIERINFOS___BOOL___ == 1){
		{% include '___ENABLE___EXCHANGEFRONTIERINFOS___.template' %}	
		}
		#endif 
		
		#ifdef ___ENABLE___REPORT_STATISTICS___
		{% include '___ENABLE___REPORT_STATISTICS___.template' %}	
		#endif 
			
		#ifndef HW // _DEBUGMODE_KERNELPRINTS4
		for(unsigned int t=0; t<__NUM_UPARTITIONS; t++){ if(hybrid_map[GraphIter][t] == 0){ std::cout<<"V, "; } else if(hybrid_map[GraphIter][t] == 1){ std::cout<<"E, "; } else { std::cout<<"-, "; }} std::cout<<std::endl;
		std::cout<<""<<std::endl;
		std::cout<< TIMINGRESULTSCOLOR <<"### GAS iteration: "<<GraphIter + 1<<" ["<<totalactvvs2<<" active vertices]"<< RESET << std::endl; 
		for(unsigned int p_u=0; p_u<__NUM_UPARTITIONS; p_u++){ if(upartition_vertices[p_u].count > 0){ std::cout<<"1, "; } else { std::cout<<"0, "; }} std::cout<<std::endl;
		if(totalactvvs2 == 0 || GraphIter >= MAXNUMGRAPHITERATIONS){ std::cout<<"no more active vertices to process. breaking out... "<<std::endl; }
		#endif 
		total_num_actvvs += totalactvvs2;
		if(totalactvvs2 == 0 || GraphIter >= MAXNUMGRAPHITERATIONS){ maxGraphIter = GraphIter; break; }
		for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ for(unsigned int p_u=0; p_u<__NUM_UPARTITIONS; p_u++){ nfrontier_dram___size[inst][p_u] = 0; }}
	} // NUM_ITs

	#ifdef _DEBUGMODE_CHECKS3
	float time_lapse = (total_cycles * _NUMNANOSECONDS_PER_CLOCKCYCLE_) / 1000000;
	float million_edges_per_sec = ((globalparams[GLOBALPARAMSCODE__PARAM__NUM_EDGES] / 1000000) / time_lapse) * 1000;
	float billion_edges_per_sec = million_edges_per_sec / 1000;
	cout<<"acts_kernel SUMMARY:: total number of active vertices processed / HBM CHANNEL: "<<total_num_actvvs<<endl;
	cout<<"acts_kernel SUMMARY:: total number of edges processed: "<<globalparams[GLOBALPARAMSCODE__PARAM__NUM_EDGES]<<endl;
	cout<<"acts_kernel SUMMARY:: number of DRAM clock cycles seen: "<<total_cycles<<" ("<<(total_cycles * _NUMNANOSECONDS_PER_CLOCKCYCLE_) / 1000000<<" milliseconds)"<<endl;
	cout<< TIMINGRESULTSCOLOR << ">>> acts_kernel SUMMARY:: TIME ELAPSE: "<<time_lapse<<" ms. THROUGHPUT: "<<million_edges_per_sec<<" MTEPS; THROUGHPUT: "<<billion_edges_per_sec<<" BTEPS"<< RESET << endl;
	#endif
	return;
}
}
