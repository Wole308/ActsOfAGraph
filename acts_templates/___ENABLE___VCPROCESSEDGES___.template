#ifndef HW
hybrid_map[GraphIter][p_u] = 0;
#endif 

// reset buffers [done]
for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ 
#pragma HLS UNROLL
	vptrbuffer___size[inst] = 0; edges_buffer___size[inst] = 0; // reset
} 

// distribute vptrs [done]
for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ cummtv2[inst] = 0; }
for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cfrontier_bufferREAL___size[n] = 0; }
VC_READVPTRS_LOOP1: for(unsigned int pingpong=0; pingpong<cfrontier_dram___size[p_u] * EDGE_PACK_SIZE; pingpong++){
#pragma HLS PIPELINE II=1
	frontier_t actvv = retrieve_cfrontierbuffer_tmp(pingpong % EDGE_PACK_SIZE, pingpong / EDGE_PACK_SIZE, cfrontier_buffer_tmp); // NEW
	if(actvv.key != INVALIDDATA){
		unsigned int inst_ = actvv.key % NUM_VALID_PEs;
		cfrontier_buffer[inst_][cfrontier_bufferREAL___size[inst_]] = actvv;
		cfrontier_bufferREAL___size[inst_] += 1;
		update_bramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___VCPROCESSEDGES___, 1);
		#ifndef FPGA_IMPL
		checkoutofbounds("acts_kernel::ERROR 073::", cfrontier_bufferREAL___size[inst_], MAX_APPLYPARTITION_VECSIZE, NAp, NAp, NAp);
		#endif 
	}
} 

// load vptrs [done]
max_limit = 0; MY_LOOP167: for(unsigned int n=0; n<NUM_VALID_PEs; n++){ if(max_limit < cfrontier_bufferREAL___size[n]){ max_limit = cfrontier_bufferREAL___size[n]; }} 
// cout<<"--------------------- max_limit: "<<max_limit<<endl;
VC_READVPTRS_LOOP2: for(unsigned int t=0; t<max_limit; t++){ // FIXME_HARDWARE. CAUSE OF POOR FREQUENCY?
	unsigned int begins_u32[NUM_VALID_PEs]; 
	unsigned int ends_u32[NUM_VALID_PEs];
	frontier_t actvvs[NUM_VALID_PEs];
	
	VC_READVPTRS_LOOP2B: for(unsigned int n=0; n<NUM_VALID_PEs; n++){
	#pragma HLS UNROLL
		actvvs[n] = cfrontier_buffer[n][t];
		unsigned int hvid = 0;
		if(t < cfrontier_bufferREAL___size[n]){ hvid = actvvs[n].key / NUM_PEs; } 
		#ifdef ___FORCE_SUCCESS___
		if((t < cfrontier_bufferREAL___size[n]) && (hvid / HBM_CHANNEL_PACK_SIZE < globalparams[GLOBALPARAMSCODE__WWSIZE__CSRVPTRS])){ ens[n][0] = true; } else { ens[n][0] = false; hvid = 0; }
		#endif
		#ifdef _DEBUGMODE_CHECKS3
		checkoutofbounds("acts_kernel::ERROR 901ccc::", (hvid / HBM_CHANNEL_PACK_SIZE), globalparams_debug[GLOBALPARAMSCODE__WWSIZE__CSRVPTRS], hvid, HBM_CHANNEL_PACK_SIZE, hvid / HBM_CHANNEL_PACK_SIZE);
		#endif 
		offsets[n] = hvid; 
	}
	dretrievemany_vptrdram(globalparams[GLOBALPARAMSCODE__BASEOFFSET__CSRVPTRS], offsets, begins_u32, {% include 'arguments_allchannelsinslr.template' %});
	update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___VCPROCESSEDGES___, 1 + DRAM_ACCESS_LATENCY);
	
	VC_READVPTRS_LOOP2C: for(unsigned int n=0; n<NUM_VALID_PEs; n++){
	#pragma HLS UNROLL
		offsets[n] += 1; 
	}
	dretrievemany_vptrdram(globalparams[GLOBALPARAMSCODE__BASEOFFSET__CSRVPTRS], offsets, ends_u32, {% include 'arguments_allchannelsinslr.template' %});
	update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___VCPROCESSEDGES___, 1 + DRAM_ACCESS_LATENCY);
	
	#ifdef ___FORCE_SUCCESS___
	MY_LOOP10023: for(unsigned int n=0; n<NUM_VALID_PEs; n++){
	#pragma HLS UNROLL
		if(ens[n][0] == false){ begins_u32[n] = 0; ends_u32[n] = 0; }
	}
	#endif 
	
	VC_READVPTRS_LOOP2D: for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
	#pragma HLS UNROLL
		vtr_t data;
		data.begin = begins_u32[inst]; 
		data.end = ends_u32[inst]; 
		data.size = data.end - data.begin;
		if(data.end < data.begin){ data.size = 0; }
		// if(data.end < data.begin || data.size > globalparams[GLOBALPARAMSCODE__PARAM__MAXDEGREE]){ data.size = 0; }
		if(data.size >= (globalparams[GLOBALPARAMSCODE__WWSIZE__CSREDGES] * HBM_CHANNEL_PACK_SIZE)){ data.size = 0; }
		data.vid = actvvs[inst].key; 
		data.prop = actvvs[inst].value;
		
		#ifndef FPGA_IMPL
		checkoutofbounds("acts_kernel::ERROR 0034::", vptrbuffer___size[inst], VPTR_BUFFER_SIZE, data.size, data.begin, data.end);
		#endif 
		insert_vptrbuffer(vptrbuffer___size[inst], data, vptr_buffer[inst]);
		#ifdef ___FORCE_SUCCESS___
		vptrbuffer___size[inst] += 1; // if(vptrbuffer___size[inst] < VPTR_BUFFER_SIZE-1){ vptrbuffer___size[inst] += 1; }
		#else 
		vptrbuffer___size[inst] += 1;		
		#endif 
		cummtv2[inst] += data.size;
	}
}

// calculate batches [done]
max_limit = 0; MY_LOOP166: for(unsigned int in=0; in<NUM_VALID_PEs; in++){ if(max_limit < cummtv2[in]){ max_limit = cummtv2[in]; }} 
unsigned int num_batches = 1; unsigned int cummtv2_ = max_limit / EDGE_PACK_SIZE;
if(cummtv2_ >= EDGE_BUFFER_SIZE){
	if(cummtv2_ / 4 < EDGE_BUFFER_SIZE){ num_batches = 4; }
	else if(cummtv2_ / 8 < EDGE_BUFFER_SIZE){ num_batches = 8; } 
	else if(cummtv2_ / 16 < EDGE_BUFFER_SIZE){ num_batches = 16; }
	#ifndef FPGA_IMPL
	else { cout<<"acts_kernel:: ERROR 2367: suitable n not found. EXITING..."<<endl; cout<<"----- max_limit: "<<max_limit<<",  cummtv2_: "<<cummtv2_<<endl; for(unsigned int in=0; in<NUM_VALID_PEs; in++){ cout<<"----- cummtv2["<<in<<"]: "<<cummtv2[in]<<endl; } exit(EXIT_FAILURE); }
	#endif 
}
max_limit = 0; for(unsigned int in=0; in<NUM_VALID_PEs; in++){ if(max_limit < vptrbuffer___size[in]){ max_limit = vptrbuffer___size[in]; }}
unsigned int batch_size = (max_limit + (num_batches - 1)) / num_batches;

// read and process edges 
VC_READANDPROCESS_EDGES_LOOP1: for(unsigned int n=0; n<num_batches; n++){
	MY_LOOP163: for(unsigned int in=0; in<NUM_VALID_PEs; in++){ 
	#pragma HLS UNROLL
		edges_buffer___size[in] = 0; // reset
	} 
	
	// load edges
	VC_READ_EDGES_LOOP1: for(unsigned int k=0; k<batch_size; k++){ 
		{%for i in context['NUM_VALID_PEs_seq']%}	
		load_edges({{i}}, ((n * batch_size) + k), globalparams[GLOBALPARAMSCODE__BASEOFFSET__CSREDGES], vptrbuffer___size[{{i}}], vptr_buffer[{{i}}], &edges_buffer___size[{{i}}], edges_buffer[{{i}}], HBM_channelA{{i}}, HBM_channelB{{i}});
		{%endfor%}	
	}			

	// process & partition edges [done]
	max_limit = 0; for(unsigned int in=0; in<NUM_VALID_PEs; in++){ if(max_limit < edges_buffer___size[in]){ max_limit = edges_buffer___size[in]; }} 
	VC_PROCESS_EDGES_LOOP1: for(unsigned int t=0; t<max_limit; t++){
		VC_PROCESS_EDGES_LOOP1B: for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
		#pragma HLS PIPELINE II=2
			VC_PROCESS_EDGES_LOOP1C: for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ 
			#pragma HLS UNROLL
				edge3_type edge = retrieve_edgesbuffer(v, t, edges_buffer[inst]); // NEW
				if(edge.dstvid != INVALIDDATA){
					unsigned int uprop = edge.srcvid; // edge.srcvid has uprop information
					unsigned int res = process_funcG(uprop, 1, globalparams[GLOBALPARAMSCODE__PARAM__ALGORITHM]);
					#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3 
					std::cout<<"VC - PROCESS EDGE SEEN @: inst: ["<<inst<<"], [edge.srcvid: "<<edge.srcvid<<", edge.dstvid: "<<edge.dstvid<<", uprop: "<<uprop<<", res: "<<res<<"]"<<std::endl;
					std::cout<<"VC - PROCESS EDGE SEEN @: inst: ["<<inst<<"], [local partition: "<<p_u<<", vid: "<<NAp<<"]"<<std::endl;
					#endif 
					
					#ifdef ___FORCE_SUCCESS_SINGLE_CHANNEL___
					edge.dstvid = get_local(edge.dstvid); 
					unsigned int inst_mirror = 0;												
					#else 
					unsigned int inst_mirror = get_H(edge.dstvid);	
					#endif
					keyvalue_t update; update.key = edge.dstvid; update.value = res;
					#ifndef FPGA_IMPL
					checkoutofbounds("acts_kernel::ERROR 813a::", inst_mirror, NUM_PEs,  edge.dstvid, inst_mirror, NAp);
					#endif 
					
					bool save;
					#ifdef ___FORCE_SUCCESS___
					if(inst_mirror < NUM_VALID_PEs){ if(t < edges_buffer___size[inst] && updates_tmpbuffer___size[inst][inst_mirror] < UPDATES_BUFFER_SIZE){ save = true; } else { save = false; }} else { save = false; }
					#else 
					if(t < edges_buffer___size[inst]){ save = true; } else { save = false; }
					#endif 
					if(save){
						#ifdef _DEBUGMODE_CHECKS3
						checkoutofbounds("acts_kernel::ERROR 8134a::", inst_mirror, NUM_VALID_PEs,  edge.dstvid, inst_mirror, NAp);
						#endif 
						#if not defined(___FORCE_SUCCESS___) && not defined(FPGA_IMPL)
						checkoutofbounds("acts_kernel::ERROR 813a::", inst_mirror, NUM_VALID_PEs,  edge.dstvid, inst_mirror, NAp);
						checkoutofbounds("acts_kernel::ERROR 813b::", updates_tmpbuffer___size[inst][inst_mirror], UPDATES_BUFFER_SIZE, NAp, NAp, NAp);
						#endif 
						insert_updatestmpbuffer(inst_mirror, updates_tmpbuffer___size[inst][inst_mirror], update, updates_buffer2[inst]); //
						updates_tmpbuffer___size[inst][inst_mirror] += 1;	
					}
				}
			}
			update_bramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___VCPROCESSEDGES___, 2); 
		}
	}
}

// exchange updates between HBMs [done]
VC_EXCHANGE_UPDATES_LOOP1: for(unsigned int inst_mirror=0; inst_mirror<NUM_VALID_PEs; inst_mirror++){
	VC_EXCHANGE_UPDATES_LOOP1B: for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
		VC_EXCHANGE_UPDATES_LOOP1C: for(unsigned int t=0; t<updates_tmpbuffer___size[inst][inst_mirror]; t++){
		#pragma HLS PIPELINE II=3 
			keyvalue_t update = retrieve_updatestmpbuffer(inst_mirror, t, updates_buffer2[inst]);
			
			unsigned int vid_l = get_local(update.key); // NEW**
			unsigned int vid_lp = get_local_to_vpartition(vid_l);
			unsigned int p_v = vid_l / MAX_APPLYPARTITION_SIZE;
			keyvalue_t update_local = update; update_local.key = vid_lp;// / EDGE_PACK_SIZE; // CRITICAL NEWCHANGE.
			// unsigned int v = update_local.key % EDGE_PACK_SIZE;
			unsigned int v = vid_lp % EDGE_PACK_SIZE; 
			#ifdef _DEBUGMODE_KERNELPRINTS//4
			cout<<"VC - EXCHANGE UPDATE SEEN @: [inst: "<<inst<<", inst_mirror: "<<inst_mirror<<"], [update.key: "<<update.key<<", update.value: "<<update.value<<"]"<<endl;
			#endif 
			
			#ifdef _DEBUGMODE_CHECKS3
			if((vid_lp % EDGE_PACK_SIZE) != v){ cout<<"acts_kernel 12347:: vid_lp("<<vid_lp<<") % v("<<v<<") != 0. EXITING..."<<endl; for(unsigned int v1=0; v1<EDGE_PACK_SIZE; v1++){ cout<<"update_local.key ("<<(update_local.key % EDGE_PACK_SIZE)<<"): "<<update_local.key<<""<<endl; } exit(EXIT_FAILURE); }				
			#endif 
			
			#ifdef _DEBUGMODE_CHECKS3
			checkoutofbounds("acts_kernel::ERROR 1232::", p_v, __NUM_APPLYPARTITIONS, update.key, get_local(update.key), MAX_APPLYPARTITION_SIZE);
			checkoutofbounds("acts_kernel::ERROR 1222::", (p_v * MAX_CSRUPDATES_VECSIZE_PER__APPLYPARTITION) + updates_buffer___size[inst_mirror][v][p_v], MAX_APPLYPARTITION_VECSIZE, updates_buffer___size[inst_mirror][v][p_v], inst_mirror, p_v);
			#endif 
			vprop_t tmp; tmp.prop = update_local.key; tmp.mask = update_local.value;
			insert_vdatabuffer(v, (p_v * MAX_CSRUPDATES_VECSIZE_PER__APPLYPARTITION) + updates_buffer___size[inst_mirror][v][p_v], tmp, vdata_buffer[inst_mirror]); 
			#ifdef ___FORCE_SUCCESS___
			if(updates_buffer___size[inst_mirror][v][p_v] + 8 < MAX_APPLYPARTITION_VECSIZE){ updates_buffer___size[inst_mirror][v][p_v] += 1; } 
			#else 
			updates_buffer___size[inst_mirror][v][p_v] += 1;
			#endif 
			vpartition_vertices[0][p_v].count = 1;
			
			unsigned int dstvid_lpv = vid_lp / EDGE_PACK_SIZE; 
			#ifndef FPGA_IMPL
			checkoutofbounds("acts_kernel::ERROR 171::", dstvid_lpv / ACTVUPDATESBLOCK_VECSIZE, BLOCKRAM_SIZE, NAp, NAp, NAp);
			checkoutofbounds("acts_kernel::ERROR 172::", p_v, __NUM_APPLYPARTITIONS, NAp, NAp, NAp);
			#endif
			insert_statsbuffer(dstvid_lpv / ACTVUPDATESBLOCK_VECSIZE, p_v, 1, statsbuffer_maskbased[inst_mirror]);
			if(inst==0){ update_bramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___VCPROCESSEDGES___, 3); }
		}
	}
}
				