void {{context['classname__mem_access']}}MEMACCESS{{context['id']}}_readV(bool_type enable, uint512_dt * kvdram, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VDESTDATA_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs, batch_type bufferoffset_kvs, buffer_type size_kvs, globalposition_t globalposition, globalparams_t globalparams){
	if(enable == OFF){ return; }

	keyvalue_vbuffer_t vdata[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=vdata complete
	value_t datas[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=datas complete
	value_t datas2[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=datas2 complete
	
	READVDATA_LOOP1: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS PIPELINE II=1
		UTIL{{context['id']}}_ReadDatas(kvdram, baseoffset_kvs + offset_kvs + i, datas);
	
		#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
		for(unsigned int v=0; v<VECTOR2_SIZE; v++){ 
			value_t vdata = datas[v] >> 1; value_t mask = datas[v] & 0x1;
			if(vdata < 1000){ cout<<"readV: ACTIVE VDATA SEEN: @ i: "<<i<<" v: "<<v<<", vdata: "<<vdata<<", mask: "<<mask<<endl; }}
		#endif
		
		// clear masks
		for(unsigned int v=0; v<VECTOR2_SIZE; v++){ 
		#pragma HLS UNROLL
			datas2[v] = datas[v] & 0xFFFFFFFE; 
			// datas2[v] = datas[v]; // CRITICAL REMOVEME.
		}
		// for(unsigned int v=0; v<VECTOR2_SIZE; v++){ datas2[v] = datas[v]; }
		
		#ifdef BIT_TRAVERSAL_ALGORITHM
		{%for v in context['VECTOR2_SIZE_seq']%} {%for v2 in context['16_seq']%} vdata[{{v}}].data[{{v2}}] = datas2[{{v}}]; {%endfor%} {%endfor%} // FIXME.
		#else 
		{%for v in context['VECTOR2_SIZE_seq']%} vdata[{{v}}].data = datas2[{{v}}]; {%endfor%}	
		#endif 
		
		#ifdef _DEBUGMODE_CHECKS3
		actsutilityobj->checkoutofbounds("MEMACCESSRRR{{context['id']}}_readV 21", bufferoffset_kvs + i, MAX_BLOCKRAM_VDESTDATA_SIZE, size_kvs, bufferoffset_kvs, i);
		#endif
		{%for v in context['VECTOR2_SIZE_seq']%}
		buffer[{{v}}][bufferoffset_kvs + i] = vdata[{{v}}];
		{%endfor%}
	}
	return;
}

void {{context['classname__mem_access']}}MEMACCESS{{context['id']}}_saveV(bool_type enable, uint512_dt * kvdram, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VDESTDATA_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs, batch_type bufferoffset_kvs, buffer_type size_kvs, globalposition_t globalposition, globalparams_t globalparams){				
	if(enable == OFF){ return; }
	
	keyvalue_vbuffer_t vdata[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=vdata complete
	value_t datas[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=datas complete
	
	SAVEVDATA_LOOP1: for(buffer_type i=0; i<size_kvs; i++){
	#pragma HLS PIPELINE II=1
		{%for v in context['VECTOR2_SIZE_seq']%}	
		vdata[{{v}}] = vbuffer[{{v}}][bufferoffset_kvs + i];
		{%endfor%}
		
		#ifdef BIT_TRAVERSAL_ALGORITHM
		{%for v in context['VECTOR2_SIZE_seq']%} {%for v2 in context['16_seq']%} datas[{{v}}] = vdata[{{v}}].data[{{v2}}]; {%endfor%} {%endfor%} // FIXME.
		#else 
		{%for v in context['VECTOR2_SIZE_seq']%} datas[{{v}}] = vdata[{{v}}].data; {%endfor%}	
		#endif
		
		#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
		for(unsigned int v=0; v<VECTOR2_SIZE; v++){ 
			value_t vdata = datas[v] >> 1; value_t mask = datas[v] & 0x1;
			if(vdata < 1000){ cout<<"saveV: ACTIVE VDATA SEEN: @ i: "<<i<<" v: "<<v<<", vdata: "<<vdata<<", mask: "<<mask<<endl; }}
		#endif
		
		#ifdef _DEBUGMODE_CHECKS3
		actsutilityobj->checkoutofbounds("MEMACCESS{{context['id']}}_saveV 23", baseoffset_kvs + offset_kvs + i, globalparams.ACTSPARAMS_MAXHBMCAPACITY_KVS, NAp, NAp, NAp);
		#endif
		UTIL{{context['id']}}_WriteDatas(kvdram, baseoffset_kvs + offset_kvs + i, datas);
	}
	return;
}

{%for n in context['T_seq']%}{%if(n>=1)%}
void {{context['classname__mem_access']}}MEMACCESS{{context['id']}}_readANDRVchunks{{n}}(bool_type enable, uint512_dt * vdram, {%for i in context['T_seq']%}{%if(i<n)%}keyvalue_vbuffer_t vbuffer{{i}}[VDATA_PACKINGSIZE][MAX_BLOCKRAM_VSRCDATA_SIZE],{%endif%}{%endfor%} batch_type vbaseoffset_kvs, batch_type voffset_kvs, batch_type vsz_kvs, globalposition_t globalposition, globalparams_t globalparamsV){			
	// return;//
	keyvalue_vbuffer_t vdata[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=vdata complete
	value_t datas[VECTOR2_SIZE]; 
	#pragma HLS ARRAY_PARTITION variable=datas complete
	
	unsigned int depth = (globalparamsV.NUM_REDUCEPARTITIONS * globalparamsV.SIZEKVS2_REDUCEPARTITION) / VDATA_SHRINK_RATIO; // NEWCHANGE.
	unsigned int depth_i = 0;
	unsigned int limit = globalparamsV.SIZE_SRCVERTICESDATA / VECTOR2_SIZE;
	
	READANDRVCHUNKS_LOOP2: for(unsigned int s=0; s<NUM_PEs; s++){
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<"MEMACCESS{{context['id']}}_readANDRVchunks:: size loaded @ s("<<s<<"): vsz_kvs: "<<vsz_kvs<<", voffset_kvs: "<<voffset_kvs<<", depth: "<<depth<<", depth_i: "<<depth_i<<endl;
		#endif
		unsigned int index = 0;
		// unsigned int index = s;
		READANDRVCHUNKS_LOOP2B: for (buffer_type i=0; i<vsz_kvs; i++){
		#pragma HLS PIPELINE II=1
		
			// unsigned int offset_kvs; if(voffset_kvs + depth_i + i >= limit){ offset_kvs = 0; } else { offset_kvs = voffset_kvs + depth_i + i; } // CRITICAL FIXME. 
			unsigned int offset_kvs = voffset_kvs + depth_i + i;
			UTIL{{context['id']}}_ReadDatas(vdram, vbaseoffset_kvs + offset_kvs, datas);	
			
			#ifdef BIT_TRAVERSAL_ALGORITHM
			{%for v in context['VECTOR2_SIZE_seq']%} {%for v2 in context['16_seq']%} vdata[{{v}}].data[{{v2}}] = datas[{{v}}]; {%endfor%} {%endfor%} // FIXME.
			#else 
			{%for v in context['VECTOR2_SIZE_seq']%} vdata[{{v}}].data = datas[{{v}}]; {%endfor%}	
			#endif
			
			#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
			for(unsigned int v=0; v<VECTOR2_SIZE; v++){ if(datas[v] == 1 || datas[v] < 1000){ cout<<"readANDRVchunks: ACTIVE MASK SEEN: @ s: "<<s<<", i: "<<i<<" v: "<<v<<", voffset_kvs: "<<voffset_kvs<<", index + s: "<<index + s<<", datas["<<v<<"]: "<<datas[v]<<endl; }}
			#endif
			
			#ifdef _DEBUGMODE_CHECKS3
			actsutilityobj->checkoutofbounds("MEMACCESS{{context['id']}}_readANDRVchunks{{n}} 25", index + s, MAX_BLOCKRAM_VSRCDATA_SIZE, vsz_kvs, index, i);
			#endif
			{%for i in context['T_seq']%}{%if(i<n)%}{%for v in context['VECTOR2_SIZE_seq']%}
			vbuffer{{i}}[{{v}}][index + s] = vdata[{{v}}];
			{%endfor%}{%endif%}{%endfor%}
			index += NUM_PEs;

			#ifdef _DEBUGMODE_STATS
			actsutilityobj->globalstats_countvsread(VECTOR2_SIZE);
			#endif
		}
		depth_i += depth;
	}
	// exit(EXIT_SUCCESS); /////////
	return;
}
{%endif%}{%endfor%}

// -------------------- stats -------------------- //
void {{context['classname__mem_access']}}MEMACCESS{{context['id']}}_readglobalstats(bool_type enable, uint512_dt * kvdram, keyvalue_t globalstatsbuffer[BLOCKRAM_GLOBALSTATS_SIZE], batch_type offset_kvs, globalparams_t globalparams){ 
	if(enable == OFF){ return; }
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("readglobalstats", offset_kvs + globalparams.ACTSPARAMS_NUM_PARTITIONS, globalparams.ACTSPARAMS_MAXHBMCAPACITY_KVS + 1, NAp, NAp, NAp);
	#endif
	
	READGLOBALSTATS_LOOP: for (buffer_type i=0; i<1 + globalparams.NUM_REDUCEPARTITIONS; i++){
	#pragma HLS PIPELINE II=1
		uint512_vec_dt vec;
		#ifdef _WIDEWORD
		{%for v in context['8_seq']%}
		vec.data[{{v}}].key = kvdram[offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		vec.data[{{v}}].value = kvdram[offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
		{%endfor%}
		#else 
		{%for v in context['8_seq']%}
		vec.data[{{v}}].key = kvdram[offset_kvs + i].data[{{v}}].key; 
		vec.data[{{v}}].value = kvdram[offset_kvs + i].data[{{v}}].value; 
		{%endfor%}
		#endif 
		globalstatsbuffer[i] = vec.data[globalparams.VARS_WORKBATCH];
	}
	
	#ifdef _DEBUGMODE_CHECKS3
	for (buffer_type i=0; i<globalparams.NUM_REDUCEPARTITIONS; i++){ actsutilityobj->checkoutofbounds("saveglobalstats", globalstatsbuffer[i].key + globalstatsbuffer[i].value, globalparams.SIZE_KVDRAM, NAp, NAp, NAp); }
	#endif
	#ifdef _DEBUGMODE_KERNELPRINTS
	actsutilityobj->printkeyvalues("mem_access:: readglobalstats.globalstatsbuffer", globalstatsbuffer, 1 + globalparams.NUM_REDUCEPARTITIONS); 
	#endif
	// exit(EXIT_SUCCESS); 
	return;
}

#ifdef NOTUSED____________________________________
unsigned int {{context['classname__mem_access']}}MEMACCESS{{context['id']}}_getvptr(uint512_dt * kvdram, unsigned int baseoffset_kvs, unsigned int offset){
	keyvalue_t vptr_kv;
	
	uint512_dt V = kvdram[baseoffset_kvs + (offset / VECTOR2_SIZE)];
	unsigned int M = (offset % VECTOR2_SIZE) / 2;
	// cout<<"-----------+++++++++++++++++++---MEMACCESS{{context['id']}}_getvptr: baseoffset_kvs: "<<baseoffset_kvs<<", offset: "<<offset<<", baseoffset_kvs + (offset / VECTOR2_SIZE): "<<baseoffset_kvs + (offset / VECTOR2_SIZE)<<endl;
	
	#ifdef _WIDEWORD
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<context['VECTOR_SIZE']-1)%}if(M == {{v}}){%endif%}{
		vptr_kv.key = V.range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		vptr_kv.value = V.range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
	}
	{%endfor%}
	#else 
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<context['VECTOR_SIZE']-1)%}if(M == {{v}}){%endif%}{
		vptr_kv.key = V.data[{{v}}].key; 
		vptr_kv.value = V.data[{{v}}].value; 
	}
	{%endfor%}
	#endif
	
	if(offset % 2 == 0){ return vptr_kv.key; }
	else { return vptr_kv.value; }
}

tuple_t {{context['classname__mem_access']}}MEMACCESS{{context['id']}}_getvptrs_opt(uint512_dt * kvdram, unsigned int baseoffset_kvs, unsigned int beginoffset, unsigned int endoffset, unsigned int edgebankID, globalparams_t globalparams){
	#pragma HLS INLINE 
	keyy_t beginvptr = 0;
	keyy_t endvptr = 0;
	
	beginoffset = beginoffset / globalparams.ACTSPARAMS_VPTR_SHRINK_RATIO; // convert-to-appropriate-skip-format
	endoffset = endoffset / globalparams.ACTSPARAMS_VPTR_SHRINK_RATIO;
	// cout<<"-----------+++++++++++++++++++---MEMACCESS{{context['id']}}_getvptrs_opt: baseoffset_kvs: "<<baseoffset_kvs<<", beginoffset: "<<beginoffset<<", endoffset: "<<endoffset<<", VPTR_SHRINK_RATIO: "<<NAp<<endl;
	
	beginvptr = MEMACCESS{{context['id']}}_getvptr(kvdram, baseoffset_kvs, beginoffset);
	endvptr = MEMACCESS{{context['id']}}_getvptr(kvdram, baseoffset_kvs, endoffset);

	tuple_t t; t.A = beginvptr; t.B = endvptr;
	return t;
}
#endif 

unsigned int {{context['classname__mem_access']}}MEMACCESS{{context['id']}}_getdata(uint512_dt * kvdram, unsigned int baseoffset_kvs, unsigned int loc){
	keyvalue_t data;
	
	uint512_dt V = kvdram[baseoffset_kvs + (loc / VECTOR2_SIZE)];
	unsigned int index = (loc % VECTOR2_SIZE) / 2;
	
	#ifdef _WIDEWORD
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<context['VECTOR_SIZE']-1)%}if(index == {{v}}){%endif%}{
		data.key = V.range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		data.value = V.range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
	}
	{%endfor%}
	#else 
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<context['VECTOR_SIZE']-1)%}if(index == {{v}}){%endif%}{
		data.key = V.data[{{v}}].key; 
		data.value = V.data[{{v}}].value; 
	}
	{%endfor%}
	#endif
	
	if(loc % 2 == 0){ return data.key; }
	else { return data.value; }
}

void {{context['classname__mem_access']}}MEMACCESS{{context['id']}}_setdata(uint512_dt * kvdram, unsigned int baseoffset_kvs, unsigned int loc, unsigned int data){
	uint512_dt V = kvdram[baseoffset_kvs + (loc / VECTOR2_SIZE)];
	unsigned int index = (loc % VECTOR2_SIZE);
	
	#ifdef _WIDEWORD
	{%for v in context['VECTOR2_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<context['VECTOR2_SIZE']-1)%}if(index == {{v}}){%endif%}{
		V.range({{32 * ((v * 1) + 1) - 1}}, {{(v * 1) * 32}}) = data; 
	}
	{%endfor%}
	#else 
	if(index % 2 == 0){ V.data[index/2].key = data; } else { V.data[index/2].value = data; }
	#endif
}

void {{context['classname__mem_access']}}MEMACCESS{{context['id']}}_commitkvstats(uint512_dt * kvdram, value_t * buffer, globalparams_t globalparams){
	unsigned int totalnumpartitionsb4last = 0;
	RETRIEVEKVSTATS_LOOP1: for(unsigned int k=0; k<globalparams.ACTSPARAMS_TREEDEPTH; k++){ totalnumpartitionsb4last += (1 << (globalparams.ACTSPARAMS_POW_PARTITIONS * k)); }
	for(unsigned int k=0; k<totalnumpartitionsb4last; k++){
		#ifdef _WIDEWORD
		kvdram[globalparams.BASEOFFSETKVS_STATSDRAM + k].range(63, 32) = buffer[k]; 
		#else
		kvdram[globalparams.BASEOFFSETKVS_STATSDRAM + k].data[0].value = buffer[k]; 
		#endif
	}
	
	#ifdef _WIDEWORD
	kvdram[BASEOFFSET_MESSAGESDATA_KVS + MESSAGES_ALGORITHMINFO_GRAPHITERATIONID].range(31, 0) = globalparams.ALGORITHMINFO_GRAPHITERATIONID + 1; // CRITICAL NOTEME: Graph Iteration is incremented here
	#else
	kvdram[BASEOFFSET_MESSAGESDATA_KVS + MESSAGES_ALGORITHMINFO_GRAPHITERATIONID].data[0].key = globalparams.ALGORITHMINFO_GRAPHITERATIONID + 1;
	#endif 
	return;
}

// -------------------- multiple accesses -------------------- //
void {{context['classname__mem_access']}}MEMACCESS{{context['id']}}_readhelperstats(uint512_dt * vdram, pmask_dt pmask[BLOCKRAM_CURRPMASK_SIZE], batch_type offset_kvs, batch_type size_kvs, unsigned int GraphIter, globalparams_t globalparams){
	
	value_t datas[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=datas complete
	
	READMANYPMASKS_LOOP1: for (buffer_type i=0; i<size_kvs; i++){	
	#pragma HLS PIPELINE II=1
		UTIL{{context['id']}}_ReadDatas(vdram, offset_kvs + i, datas);
		
		#ifdef _DEBUGMODE_CHECKS3
		actsutilityobj->checkoutofbounds("readhelperstats. ERROR.", GraphIter, MAXNUMGRAPHITERATIONS, NAp, NAp, NAp);
		#endif
		
		pmask[i] = datas[GraphIter];
	}
	
	#ifdef _DEBUGMODE_KERNELPRINTS3
	cout<< TIMINGRESULTSCOLOR << ">>> readpmasks: printing active vertex partitions: GraphIter: "<<GraphIter<<": ";
	unsigned int num_actvps = 0;
	for(unsigned int t=0; t<BLOCKRAM_CURRPMASK_SIZE; t++){
		if(pmask[t] > 0  && t < 16){ cout<<t<<", "; }
		if(pmask[t] > 0){ num_actvps += 1; }
	}
	cout<<" ("<<num_actvps<<" active partitions, "<<size_kvs<<" total partitions)"<< RESET << endl;
	#endif 
	return;
}










