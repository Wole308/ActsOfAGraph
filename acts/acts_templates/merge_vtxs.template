#include "merge_vtxs.h"
using namespace std;

#ifdef SW
merge_vtxs::merge_vtxs(){ actsutilityobj = new actsutility(); acts_utilobj = new acts_util(); }
merge_vtxs::~merge_vtxs(){}
#endif

// functions (merge_vtxs)
unsigned int
	#ifdef SW 
	merge_vtxs::
	#endif 
MERGE_amin(unsigned int val1, unsigned int val2){
	if(val1 < val2){ return val1; }
	else { return val2; }
}

value_t 
	#ifdef SW 
	merge_vtxs::
	#endif 
MERGE_mergefunc(value_t value1, value_t value2, unsigned int GraphAlgo){
	return MERGE_amin(value1, value2);
}

{%for n in context['T_seq']%}
{%if(n>=1)%}
void // 
	#ifdef SW 
	merge_vtxs::
	#endif 
MERGE_readandreplicate{{n}}vdata(bool_type enable, uint512_dt * vdram, batch_type dramoffset_kvs, {%for i in context['T_seq']%}{%if(i<n)%}keyvalue_vbuffer_t buffer{{i}}[VDATA_PACKINGSIZE][BLOCKRAM_SIZE],{%endif%}{%endfor%} unsigned int begincol, batch_type bufferoffset_kvs, buffer_type size_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount = BLOCKRAM_SIZE;
		
	READVDATA_LOOP: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
	#pragma HLS PIPELINE II=1
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t mykeyvalue{{v}};
		{%endfor%}
		
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
		mykeyvalue{{v}}.key = vdram[dramoffset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		mykeyvalue{{v}}.value = vdram[dramoffset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		mykeyvalue{{v}}.key = vdram[dramoffset_kvs + i].data[{{v}}].key; 
		mykeyvalue{{v}}.value = vdram[dramoffset_kvs + i].data[{{v}}].value; 
		{%endfor%}
		#endif 
		
		{%for i in context['T_seq']%}
		{%if(i<n)%}
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer{{i}}[begincol + {{v}}][bufferoffset_kvs + i] = acts_utilobj->UTIL_GETKV2(mykeyvalue{{v}});
		{%endfor%}
		{%endif%}
		{%endfor%}
		
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvsread(VECTOR_SIZE);
		#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<< TIMINGRESULTSCOLOR<<"readvdata:: vertices read: offset: "<<dramoffset_kvs * VECTOR_SIZE<<"-"<<(dramoffset_kvs + size_kvs) * VECTOR_SIZE<<", number of vertex datas read: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<< RESET<<endl;
	#endif
	#ifdef _DEBUGMODE_KERNELPRINTS
	if(dramoffset_kvs >= globalparams.BASEOFFSETKVS_VERTEXPTR_ && dramoffset_kvs < globalparams.BASEOFFSETKVS_VERTEXPTR + VERTEXPTRSSZ_KVS){ cout<< TIMINGRESULTSCOLOR<<"readvdata:: vertices read: offset: "<<(dramoffset_kvs - globalparams.BASEOFFSETKVS_VERTEXPTR) * VECTOR_SIZE<<"-"<<(dramoffset_kvs + size_kvs - globalparams.BASEOFFSETKVS_VERTEXPTR) * VECTOR_SIZE<<", number of vertex datas read: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<< RESET<<endl; }
	if(dramoffset_kvs >= globalparams.BASEOFFSETKVS_VERTICESDATA_ && dramoffset_kvs < globalparams.BASEOFFSETKVS_DESTVERTICESDATA + VERTICESDATASZ_KVS){ cout<< TIMINGRESULTSCOLOR<<"readvdata:: vertices read: offset: "<<(dramoffset_kvs - globalparams.BASEOFFSETKVS_DESTVERTICESDATA) * VECTOR_SIZE<<"-"<<(dramoffset_kvs + size_kvs - globalparams.BASEOFFSETKVS_DESTVERTICESDATA) * VECTOR_SIZE<<", number of vertex datas read: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<< RESET<<endl; }				
	#endif
	return;
}
{%endif%}
{%endfor%}

{%for n in context['T_seq']%}
{%if(n>=1)%}
void
	#if defined(SW)
	merge_vtxs::
	#endif
MERGE_merge{{n}}andsavevdata(bool_type enable, uint512_dt * vdram, {%for i in context['T_seq']%}{%if(i<n)%}keyvalue_vbuffer_t vbuffer{{i}}[VDATA_PACKINGSIZE][BLOCKRAM_SIZE],{%endif%}{%endfor%} unsigned int begincol, batch_type bufferoffset_kvs, unsigned int dramoffset_kvs){
	if(enable == OFF){ return; }
	keyvalue_t dummykv;
	dummykv.key = 0xFFFFFFFF; dummykv.value = 0xFFFFFFFF;
	
	{%for v in context['VECTOR_SIZE_seq']%}
	{%for i,c in zip(context['Tplus2_seq'], context['T_charseq'])%}
	keyy_t key{{c}}{{v}} = dummykv.key;
	value_t val{{c}}{{v}} = dummykv.key;
	{%endfor%}
	{%endfor%}
	
	MERGE{{n}}_LOOP1: for (buffer_type j=0; j<BLOCKRAM_SIZE; j++){
	#pragma HLS PIPELINE II=1
		{%for i in context['Tplus2_seq']%}
		{%if(i<n)%}
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t mykeyvalue{{i}}{{v}} = acts_utilobj->UTIL_GETKV2(vbuffer{{i}}[begincol + {{v}}][bufferoffset_kvs + j]);	
		{%endfor%}
		{%else%}
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t mykeyvalue{{i}}{{v}} = dummykv;
		{%endfor%}
		{%endif%}
		{%endfor%}
		
		//((n)/2)
		{%for v in context['VECTOR_SIZE_seq']%}
		{%for i,c in zip(context['T_seq'], context['T_charseq'])%}
		{%if(i<((n+1)/2))%}
		key{{c}}{{v}} = MERGE_mergefunc(mykeyvalue{{2*i}}{{v}}.key, mykeyvalue{{2*i+1}}{{v}}.key, NAp);
		{%endif%}
		{%endfor%}
		{%endfor%}
		{%for v in context['VECTOR_SIZE_seq']%}
		keyy_t keyPA{{v}} = MERGE_mergefunc(keyA{{v}}, keyB{{v}}, NAp);
		keyy_t keyPB{{v}} = MERGE_mergefunc(keyC{{v}}, keyD{{v}}, NAp);
		keyy_t keyPC{{v}} = MERGE_mergefunc(keyE{{v}}, keyF{{v}}, NAp);
		keyy_t keyRA{{v}} = MERGE_mergefunc(keyPA{{v}}, keyPB{{v}}, NAp);
		keyy_t keyRB{{v}} = MERGE_mergefunc(keyPC{{v}}, keyF{{v}}, NAp);
		keyy_t keyRZ{{v}} = MERGE_mergefunc(keyRA{{v}}, keyRB{{v}}, NAp);
		{%endfor%}
		
		//((n)/2)
		{%for v in context['VECTOR_SIZE_seq']%}
		{%for i,c in zip(context['T_seq'], context['T_charseq'])%}
		{%if(i<((n+1)/2))%}
		val{{c}}{{v}} = MERGE_mergefunc(mykeyvalue{{2*i}}{{v}}.value, mykeyvalue{{2*i+1}}{{v}}.value, NAp);
		{%endif%}
		{%endfor%}
		{%endfor%}
		{%for v in context['VECTOR_SIZE_seq']%}
		value_t valPA{{v}} = MERGE_mergefunc(valA{{v}}, valB{{v}}, NAp);
		value_t valPB{{v}} = MERGE_mergefunc(valC{{v}}, valD{{v}}, NAp);
		value_t valPC{{v}} = MERGE_mergefunc(valE{{v}}, valF{{v}}, NAp);
		value_t valRA{{v}} = MERGE_mergefunc(valPA{{v}}, valPB{{v}}, NAp);
		value_t valRB{{v}} = MERGE_mergefunc(valPC{{v}}, valF{{v}}, NAp);
		value_t valRZ{{v}} = MERGE_mergefunc(valRA{{v}}, valRB{{v}}, NAp);
		{%endfor%}
		
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
		vdram[dramoffset_kvs + j].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = keyRZ{{v}};
		vdram[dramoffset_kvs + j].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = valRZ{{v}};
		{%endfor%}
		#else
		{%for v in context['VECTOR_SIZE_seq']%}
		vdram[dramoffset_kvs + j].data[{{v}}].key = keyRZ{{v}};
		vdram[dramoffset_kvs + j].data[{{v}}].value = valRZ{{v}};
		{%endfor%}
		#endif
	}
	return;
}
{%endif%}
{%endfor%}




