// primitives
unsigned int {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READVDATA(keyvalue_vbuffer_t wideword){
	#pragma HLS INLINE
	return UTIL{{context['id']}}_READBITSFROM_UINTV(wideword, OFFSETOF_VDATA, SIZEOF_VDATA);
}
unsigned int {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READVMASK(keyvalue_vbuffer_t wideword){
	#pragma HLS INLINE
	return UTIL{{context['id']}}_READBITSFROM_UINTV(wideword, OFFSETOF_VMASK, SIZEOF_VMASK);
}
unsigned int {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READVDATA2(keyvalue_vbuffer_t wideword, unsigned int offsetof_vdata){
	#pragma HLS INLINE
	return UTIL{{context['id']}}_READBITSFROM_UINTV(wideword, offsetof_vdata, SIZEOF_VDATA);
}
unsigned int {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READVMASK2(keyvalue_vbuffer_t wideword, unsigned int offsetof_vmask){
	#pragma HLS INLINE
	return UTIL{{context['id']}}_READBITSFROM_UINTV(wideword, offsetof_vmask, SIZEOF_VMASK);
}

void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITEVDATA(keyvalue_vbuffer_t * wideword, value_t vdata){
	#pragma HLS INLINE
	UTIL{{context['id']}}_WRITEBITSTO_UINTV(wideword, OFFSETOF_VDATA, SIZEOF_VDATA, vdata);
	return;
}
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITEVMASK(keyvalue_vbuffer_t * wideword, unit1_type vmask){
	#pragma HLS INLINE
	UTIL{{context['id']}}_WRITEBITSTO_UINTV(wideword, OFFSETOF_VMASK, SIZEOF_VMASK, vmask);
	return;
}
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITEVDATA2(keyvalue_vbuffer_t * wideword, value_t vdata, unsigned int offsetof_vdata){
	#pragma HLS INLINE
	UTIL{{context['id']}}_WRITEBITSTO_UINTV(wideword, offsetof_vdata, SIZEOF_VDATA, vdata);
	return;
}
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITEVMASK2(keyvalue_vbuffer_t * wideword, unit1_type vmask, unsigned int offsetof_vmask){
	#pragma HLS INLINE
	UTIL{{context['id']}}_WRITEBITSTO_UINTV(wideword, offsetof_vmask, SIZEOF_VMASK, vmask);
	return;
}

tuple_t {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READVDATAWITHVMASK(keyvalue_vbuffer_t wideword){
	#pragma HLS INLINE
	tuple_t res;
	res.A = MEMCA{{context['id']}}_READVDATA(wideword); 
	res.B = MEMCA{{context['id']}}_READVMASK(wideword); 
	return res;
}
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITEVDATAWITHVMASK(keyvalue_vbuffer_t * wideword, value_t vdata, unit1_type vmask){
	#pragma HLS INLINE
	MEMCA{{context['id']}}_WRITEVDATA(wideword, vdata);
	MEMCA{{context['id']}}_WRITEVMASK(wideword, vmask);
	return;
}
tuple_t {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READVDATAWITHVMASK2(keyvalue_vbuffer_t wideword, unsigned int offsetof_vdata, unsigned int offsetof_vmask){
	#pragma HLS INLINE
	tuple_t res;
	res.A = MEMCA{{context['id']}}_READVDATA2(wideword, offsetof_vdata); 
	res.B = MEMCA{{context['id']}}_READVMASK2(wideword, offsetof_vmask); 
	return res;
}
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITEVDATAWITHVMASK2(keyvalue_vbuffer_t * wideword, value_t vdata, unit1_type vmask, unsigned int offsetof_vdata, unsigned int offsetof_vmask){
	#pragma HLS INLINE
	MEMCA{{context['id']}}_WRITEVDATA2(wideword, vdata, offsetof_vdata);
	MEMCA{{context['id']}}_WRITEVMASK2(wideword, vmask, offsetof_vmask);
	return;
}

// non-primitives
// any data 
uint32_type {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READDATAFROMBUFFER(unsigned int index, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READDATAFROMBUFFER:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif
	
	return buffer[index % VECTOR2_SIZE][bufferoffset_kvs + (index / VECTOR2_SIZE)];
}

void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITEDATATOBUFFER(unsigned int index, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], uint32_type data, batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITEDATATOBUFFER:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif
	
	buffer[index % VECTOR2_SIZE][bufferoffset_kvs + (index / VECTOR2_SIZE)] = data;
	return;
}

keyvalue_vbuffer_t {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READDATAFROMDRAM(unsigned int index, uint512_dt * kvdram, batch_type baseoffset_kvs, batch_type offset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READDATAFROMDRAM:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif
	
	keyvalue_vbuffer_t data[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=data complete
	
	#ifdef _WIDEWORD // CRITICAL FIXME.
	{%for v in context['VECTOR_SIZE_seq']%}
	data[{{2*v}}] = kvdram[baseoffset_kvs + offset_kvs + (index / VECTOR2_SIZE)].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
	data[{{2*v+1}}] = kvdram[baseoffset_kvs + offset_kvs + (index / VECTOR2_SIZE)].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
	{%endfor%}
	#else 
	{%for v in context['VECTOR_SIZE_seq']%}
	data[{{2*v}}] = kvdram[baseoffset_kvs + offset_kvs + (index / VECTOR2_SIZE)].data[{{v}}].key;
	data[{{2*v+1}}] = kvdram[baseoffset_kvs + offset_kvs + (index / VECTOR2_SIZE)].data[{{v}}].value; 
	{%endfor%}
	#endif
	
	return data[index % VECTOR2_SIZE];
}

void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITEDATATODRAM(unsigned int index, uint512_dt * kvdram, uint32_type data, batch_type baseoffset_kvs, batch_type offset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITEDATATODRAM:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif

	{%for v in context['VECTOR2_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} if((index % VECTOR2_SIZE) == {{v}}){
		#ifdef _WIDEWORD
		kvdram[offset_kvs + (index/VECTOR2_SIZE)].range({{32 * ((v * 1) + 1) - 1}}, {{(v * 1) * 32}}) = data;
		#else 
		if((index % VECTOR2_SIZE) % 2 == 0){ kvdram[offset_kvs + (index/VECTOR2_SIZE)].data[{{v}}].key = data; } 
		else { kvdram[offset_kvs + (index/VECTOR2_SIZE)].data[{{v}}].value = data;  }
		#endif 
	}
	{%endfor%}
	else {
		#ifdef _DEBUGMODE_CHECKS3
		cout<<"MEMCA{{context['id']}}_WRITEDATATODRAM: NOT IMPLEMENTED. EXITING..."<<endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	return;
}

// vdata 
// vdata:: used in {reduceupdates.cpp} 
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATA(unsigned int index, keyvalue_vbuffer_t buffer[BLOCKRAM_VDATA_SIZE], value_t vdata, batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATA:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif
	
	MEMCA{{context['id']}}_WRITEVDATA(&buffer[bufferoffset_kvs + index], vdata);
	return;
}

// vdata:: used in {dispatch_reduce -> mem_access_splitdstvxs.cpp -> MEMACCESS{{context['id']}}_readV} 
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATAS(unsigned int index, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], value_t vdatas[VECTOR2_SIZE], batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATAS:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	MEMCA{{context['id']}}_WRITEVDATAWITHVMASK(&buffer[{{v}}][bufferoffset_kvs + index], vdatas[{{v}}], 0);
	{%endfor%}
	return;
}

// vdata:: used in {reduceupdates.cpp, processedges_splitdstvxs.cpp} 
value_t {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READFROMBUFFER_VDATA(unsigned int index, keyvalue_vbuffer_t buffer[BLOCKRAM_VDATA_SIZE], batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READFROMBUFFER_VDATA:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif
	
	value_t vdata = MEMCA{{context['id']}}_READVDATA(buffer[bufferoffset_kvs + index]);
	return vdata;
}

// vdata:: used in {processedges_splitdstvxs.cpp} // soon obsolete 
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READFROMBUFFER_VDATAS(unsigned int index, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], value_t vdatas[VECTOR2_SIZE], batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READFROMBUFFER_VDATAS:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	vdatas[{{v}}] = MEMCA{{context['id']}}_READVDATA(buffer[{{v}}][bufferoffset_kvs + index]);
	{%endfor%}
	return;
}

// vdata & vmasks 
// used in {classname__processedges_splitdstvxs.cpp}
vmdata_t {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK(unsigned int index, keyvalue_vbuffer_t buffer[BLOCKRAM_VDATA_SIZE], batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READFROMBUFFER_VDATASWITHVMASKS:", bufferoffset_kvs + index/2, BLOCKRAM_VDATA_SIZE, index, NAp, NAp);
	#endif
	
	vmdata_t vmdata;
	tuple_t tup;
	tup = MEMCA{{context['id']}}_READVDATAWITHVMASK(buffer[bufferoffset_kvs + index]);
	vmdata.vdata = tup.A;
	vmdata.vmask = tup.B;
	
	#ifdef _DEBUGMODE_KERNELPRINTS_TRACE
	if(vmdata.vmask == 1){ cout<<">>> MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK:: ACTIVE VERTEX READ: @ bufferoffset_kvs: "<<bufferoffset_kvs<<", index: "<<index<<endl; }
	#endif
	return vmdata;
}
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATAWITHVMASK(unsigned int index, keyvalue_vbuffer_t buffer[BLOCKRAM_VDATA_SIZE], value_t vdata, unit1_type vmdata, batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATAWITHVMASK:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif

	MEMCA{{context['id']}}_WRITEVDATAWITHVMASK(&buffer[bufferoffset_kvs + index], vdata, vmdata);
	return;
}

// #define HWBITACCESSTYPE
vmdata_t {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK2(unsigned int index, unsigned int bitoffset, keyvalue_vbuffer_t buffer[BLOCKRAM_VDATA_SIZE], batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	// {1st 16 is masks}{2nd 16 is vdatas}
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK2(220):", bufferoffset_kvs + index/VDATA_SHRINK_RATIO, BLOCKRAM_VDATA_SIZE, index, bufferoffset_kvs, NAp);
	#endif
	
	vmdata_t vmdata;
	tuple_t tup;
	unsigned int offsetof_vdata = (index % VDATA_SHRINK_RATIO);
	keyvalue_vbuffer_t bits_vector = buffer[bufferoffset_kvs + (index / VDATA_SHRINK_RATIO)];
	
	#ifdef HWBITACCESSTYPE
	tup.A = MEMCA{{context['id']}}_READVDATA2(bits_vector, offsetof_vdata); 
	tup.B = MEMCA{{context['id']}}_READVMASK2(bits_vector, BEGINOFFSETOF_VMASK + offsetof_vdata); 
	vmdata.vdata = tup.A;
	vmdata.vmask = tup.B;
	#else
	vmdata.vdata = UTIL{{context['id']}}_SWREADBITSFROM_UINTV(bits_vector, offsetof_vdata, SIZEOF_VDATA);
	vmdata.vmask = UTIL{{context['id']}}_SWREADBITSFROM_UINTV(bits_vector, BEGINOFFSETOF_VMASK + offsetof_vdata, SIZEOF_VMASK);
	#endif 
	
	#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
	if(vmdata.vmask == 1){ cout<<">>> MEMCA{{context['id']}}_VDATAWITHVMASK2(224):: ACTIVE VERTEX READ: @ bufferoffset_kvs: "<<bufferoffset_kvs<<", offsetof_vdata: "<<offsetof_vdata<<", vmdata.vdata: "<<vmdata.vdata<<", vmdata.vmask: "<<vmdata.vmask<<", sub_chunk_height: "<<(index / VDATA_SHRINK_RATIO)<<", index: "<<index<<endl; }
	#endif
	return vmdata;
}
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATAWITHVMASK2(unsigned int index, keyvalue_vbuffer_t buffer[BLOCKRAM_VDATA_SIZE], value_t vdata, unit1_type vmdata, batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	// {1st 16 is masks}{2nd 16 is vdatas}
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATAWITHVMASK:", index/VDATA_SHRINK_RATIO, BLOCKRAM_VDATA_SIZE, index, NAp, NAp);
	#endif

	unsigned int offsetof_vdata = (index % VDATA_SHRINK_RATIO);
	keyvalue_vbuffer_t bits_vector = buffer[bufferoffset_kvs + (index / VDATA_SHRINK_RATIO)];
	
	#ifdef HWBITACCESSTYPE
	MEMCA{{context['id']}}_WRITEVDATA2(&bits_vector, vdata, offsetof_vdata);
	MEMCA{{context['id']}}_WRITEVMASK2(&bits_vector, vmdata, BEGINOFFSETOF_VMASK + offsetof_vdata);
	#else
	UTIL{{context['id']}}_SWWRITEBITSTO_UINTV(&bits_vector, offsetof_vdata, SIZEOF_VDATA, vdata);
	UTIL{{context['id']}}_SWWRITEBITSTO_UINTV(&bits_vector, BEGINOFFSETOF_VMASK + offsetof_vdata, SIZEOF_VMASK, vmdata);	
	#endif 
	
	buffer[bufferoffset_kvs + (index / VDATA_SHRINK_RATIO)] = bits_vector;
	return;
}

void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATASANDVMASKS(unsigned int index, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], keyvalue_vbuffer_t datas[VECTOR2_SIZE], batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATASANDVMASKS:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	buffer[{{v}}][bufferoffset_kvs + index] = datas[{{v}}];
	{%endfor%}
	return;
}

void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFERWITHDEPTHS_VDATASANDVMASKS(unsigned int indexes[VDATA_PACKINGSIZE], keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], keyvalue_vbuffer_t vdatas[VDATA_PACKINGSIZE], batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	{%for v in context['VECTOR2_SIZE_seq']%}
	actsutilityobj->checkoutofbounds("{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFERWITHDEPTHS_VDATAS:", bufferoffset_kvs + indexes[{{v}}]/2, BLOCKRAM_VDATA_SIZE, indexes[{{v}}], NAp, NAp);
	{%endfor%}
	#endif
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	buffer[{{v}}][bufferoffset_kvs + indexes[{{v}}]] = vdatas[{{v}}];
	{%endfor%}	
	return;
}

{%for n in context['T_seq']%}{%if(n>=1)%}
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATASANDVMASKS{{n}}_ANDREPLICATE(unsigned int index, {%for i in context['T_seq']%}{%if(i<n)%}keyvalue_vbuffer_t buffer{{i}}[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE],{%endif%}{%endfor%} keyvalue_vbuffer_t vdatas[VECTOR2_SIZE], batch_type bufferoffset_kvs){
	#pragma HLS INLINE
	
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFER_VDATASANDVMASKS:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif
	
	{%for i in context['T_seq']%}{%if(i<n)%}
	{%for v in context['VECTOR2_SIZE_seq']%}
	buffer{{i}}[{{v}}][bufferoffset_kvs + index] = vdatas[{{v}}];
	{%endfor%}
	{%endif%}{%endfor%}
	return;
}
{%endif%}{%endfor%}

{%for n in context['T_seq']%}{%if(n>=1)%}
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFERWITHDEPTHS_VDATASANDVMASKS{{n}}_ANDREPLICATE(unsigned int indexes[VDATA_PACKINGSIZE], {%for i in context['T_seq']%}{%if(i<n)%}keyvalue_vbuffer_t buffer{{i}}[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE],{%endif%}{%endfor%} keyvalue_vbuffer_t vdatas[VECTOR2_SIZE], batch_type bufferoffset_kvs){			
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	{%for v in context['VECTOR2_SIZE_seq']%}
	actsutilityobj->checkoutofbounds("{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOBUFFERWITHDEPTHS_VDATAS:", bufferoffset_kvs + indexes[{{v}}]/2, BLOCKRAM_VDATA_SIZE, indexes[{{v}}], NAp, NAp);
	{%endfor%}
	#endif
	
	{%for i in context['T_seq']%}{%if(i<n)%}
	{%for v in context['VECTOR2_SIZE_seq']%}
	buffer{{i}}[{{v}}][bufferoffset_kvs + indexes[{{v}}]] = vdatas[{{v}}];
	{%endfor%}	
	{%endif%}{%endfor%}
	return;
}
{%endif%}{%endfor%}

// kvdram 
void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READFROMKVDRAM_VDATASANDVMASKS(unsigned int index, uint512_dt * kvdram, keyvalue_vbuffer_t vdatas[VECTOR2_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs){
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_READFROMKVDRAM_VDATASANDVMASKS:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif
	
	#ifdef _WIDEWORD // CRITICAL FIXME.
	{%for v in context['VECTOR_SIZE_seq']%}
	vdatas[{{2*v}}] = kvdram[baseoffset_kvs + offset_kvs + index].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
	vdatas[{{2*v+1}}] = kvdram[baseoffset_kvs + offset_kvs + index].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
	{%endfor%}
	#else 
	{%for v in context['VECTOR_SIZE_seq']%}
	vdatas[{{2*v}}] = kvdram[baseoffset_kvs + offset_kvs + index].data[{{v}}].key;
	vdatas[{{2*v+1}}] = kvdram[baseoffset_kvs + offset_kvs + index].data[{{v}}].value; 
	{%endfor%}
	#endif
	return;
}

void {{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOKVDRAM_VDATASANDVMASKS(unsigned int index, uint512_dt * kvdram, keyvalue_vbuffer_t vdatas[VECTOR2_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs){			
	#pragma HLS INLINE
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("{{context['classname__mem_convert_and_access']}}MEMCA{{context['id']}}_WRITETOKVDRAM_VDATASANDVMASKS:", index/2, BLOCKRAM_SIZE, index, NAp, NAp);
	#endif

	#ifdef _WIDEWORD // CRITICAL FIXME.
	{%for v in context['VECTOR_SIZE_seq']%}
	kvdram[baseoffset_kvs + offset_kvs + index].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = vdatas[{{2*v}}];
	kvdram[baseoffset_kvs + offset_kvs + index].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = vdatas[{{2*v+1}}];
	{%endfor%}
	#else 
	{%for v in context['VECTOR_SIZE_seq']%}
	kvdram[baseoffset_kvs + offset_kvs + index].data[{{v}}].key = vdatas[{{2*v}}];
	kvdram[baseoffset_kvs + offset_kvs + index].data[{{v}}].value = vdatas[{{2*v+1}}];
	{%endfor%}
	#endif
	return;
}
