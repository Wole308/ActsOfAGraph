#include "processedges_unslicedgraph.h"
using namespace std;

#ifdef SW
processedges_unslicedgraph::processedges_unslicedgraph(){ 
	actsutilityobj = new actsutility(); 
	acts_utilobj = new acts_util();
	mem_accessobj = new mem_access();
}
processedges_unslicedgraph::~processedges_unslicedgraph(){}
#endif

value_t 
	#ifdef SW 
	processedges_unslicedgraph::
	#endif 
PROCESSU_processfunc(value_t udata, value_t edgew, unsigned int GraphAlgo){
	value_t res = 0;
	if(GraphAlgo == PAGERANK){
		res = udata;
	} else if(GraphAlgo == BFS){
		res = NAp;
	} else if(GraphAlgo == SSSP){
		res = udata + edgew;
	} else {
		res = NAp;
	}
	return res;
}

fetchmessage_t 
	#ifdef SW 
	processedges_unslicedgraph::
	#endif 
PROCESSU_readandprocess(bool_type enable, uint512_dt * edges, uint512_dt * kvdram, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], unitBRAMwidth_type vmask[BLOCKRAM_SIZE], unitBRAMwidth_type vmask_subp[BLOCKRAM_SIZE], keyvalue_buffer_t buffer[VECTOR_SIZE][SOURCEBLOCKRAM_SIZE], 
		batch_type goffset_kvs, batch_type loffset_kvs, batch_type size_kvs, travstate_t travstate, sweepparams_t sweepparams, globalparams_t globalparams){
	fetchmessage_t fetchmessage;
	fetchmessage.chunksize_kvs = -1;
	fetchmessage.nextoffset_kvs = -1;
	if(enable == OFF){ return fetchmessage; }
	
	analysis_type analysis_loop = BLOCKRAM_SIZE / 2;
	analysis_type analysis_loop1 = SUBPMASKFACTOR;
	analysis_type analysis_loop2 = 16384 / SUBPMASKFACTOR;
	
	value_t E[2][VECTOR_SIZE];
	#pragma HLS ARRAY_PARTITION variable=E complete
	bool_type en = ON;
	
	buffer_type reducebuffersz = globalparams.SIZE_REDUCE / 2;
	unsigned int validbound = reducebuffersz * FETFACTOR * VECTOR2_SIZE;
	
	travstate.i_kvs = travstate.i_kvs / 2;
	travstate.end_kvs = travstate.end_kvs / 2;
	loffset_kvs = loffset_kvs / 2;
	buffer_type edgessize_kvs = size_kvs / 2;
	
	batch_type offset_kvs = goffset_kvs + loffset_kvs;
	
	vertex_t srcvid;
	vertex_t lvid;
	vertex_t lvid_sob = INVALIDDATA;
	vertex_t lvid_eob = INVALIDDATA; 
	vertex_t firstvalidlvid = INVALIDDATA;
	vertex_t lastvalidlvid = INVALIDDATA; 
	
	batch_type vptrbaseoffset_kvs = globalparams.BASEOFFSETKVS_VERTEXPTR + (globalparams.ACTSPARAMS_SRCVOFFSET / VECTOR_SIZE);
	batch_type voffset_kvs = sweepparams.source_partition * reducebuffersz * FETFACTOR;
	keyy_t nextbeginvptr;
	keyy_t nextbeginvptr_kvs;
	
	fetchmessage.chunksize_kvs = edgessize_kvs;
	fetchmessage.nextoffset_kvs = -1;
	buffer_type loadcount = 0;
	
	unsigned int found = 0;
	unsigned int found1 = 0;
	int nextactivei = -1;
	int subpidx = -1;
	unsigned int GraphAlgo = globalparams.ALGORITHMINFO_GRAPHALGORITHMID;
	
	buffer_type chunk_size = acts_utilobj->UTIL_getchunksize_kvs(edgessize_kvs, travstate, 0);
	READANDPROCESS_LOOP1: for (buffer_type i=0; i<chunk_size; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loop avg=analysis_loop	
	#pragma HLS PIPELINE II=1

		#ifdef _WIDEWORD
		{%for v in context['4_seq']%}
		E[0][{{2*v}}] = edges[offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		E[0][{{2*v+1}}] = edges[offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
		{%endfor%}
		{%for v in context['4_seq']%}
		E[1][{{2*v}}] = edges[offset_kvs + i].range({{32 * (((4+v) * 2) + 1) - 1}}, {{((4+v) * 2) * 32}}); 
		E[1][{{2*v+1}}] = edges[offset_kvs + i].range({{32 * ((((4+v) * 2) + 1) + 1) - 1}}, {{((4+v) * 2 + 1) * 32}}); 
		{%endfor%}
		#else 
		{%for v in context['4_seq']%}
		E[0][{{2*v}}] = edges[offset_kvs + i].data[{{v}}].key; 
		E[0][{{2*v+1}}] = edges[offset_kvs + i].data[{{v}}].value; 
		{%endfor%}
		{%for v in context['4_seq']%}
		E[1][{{2*v}}] = edges[offset_kvs + i].data[4+{{v}}].key; 
		E[1][{{2*v+1}}] = edges[offset_kvs + i].data[4+{{v}}].value; 
		{%endfor%}
		#endif
		
		en = ON;
		
		srcvid = E[0][0];
		lvid = srcvid - travstate.i2;
		
		if(i == 0){ lvid_sob = lvid; } 
		if(i == chunk_size-1){ lvid_eob = lvid; } 
		
		if(lvid >= validbound || srcvid == UNUSEDDATA){ en = OFF; lvid = 0; }
		#ifdef _DEBUGMODE_CHECKS2
		if(srcvid < travstate.i2){ cout<<"readandprocess: INVALID srcvid. this is an error. i: "<<i<<", srcvid: "<<srcvid<<", travstate.i2: "<<travstate.i2<<" offset_kvs: "<<offset_kvs<<". exiting..."<<endl; 
			for(unsigned int v=0; v<VECTOR_SIZE; v++){ cout<<"readandprocess: E[0]["<<v<<"]: "<<E[0][v]<<", E[1]["<<v<<"]: "<<E[1][v]<<endl; }
			exit(EXIT_FAILURE); }
		actsutilityobj->checkoutofbounds("readandprocess.1", lvid, reducebuffersz * FETFACTOR * VECTOR2_SIZE, srcvid, travstate.i2, NAp);
		#endif
		
		value_t udata = acts_utilobj->UTIL_GETVTXDATA(vbuffer, lvid, globalparams);
		unsigned int mask;
		if(GraphAlgo == PAGERANK){ mask = 1; } 
		else { mask = acts_utilobj->UTIL_GETVTXMASK(vmask, lvid, globalparams); }
		value_t res = PROCESSU_processfunc(udata, 1, globalparams.ALGORITHMINFO_GRAPHALGORITHMID); 
		
		if(en == ON && mask == 1 && firstvalidlvid == INVALIDDATA){ firstvalidlvid = lvid; } // NEWCHANGE.
		if(en == ON && mask == 1){ lastvalidlvid = lvid; }
		
		#ifdef _DEBUGMODE_CHECKS2
		actsutilityobj->checkoutofbounds("readandprocess.1", mask, 2, NAp, NAp, NAp);
		#endif
		
		#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
		if(en == ON && mask == 1){
			if(true){ cout<<"readandprocess: i: "<<i<<", mask: "<<mask<<", srcvid: "<<srcvid<<", travstate.i2: "<<travstate.i2<<", lvid: "<<lvid<<", udata: "<<udata<<endl; }
			for(unsigned int v=0; v<VECTOR_SIZE; v++){ cout<<"readandprocess: udata: "<<udata<<", E[0]["<<v<<"]: "<<E[0][v]<<", sweepparams.source_partition: "<<sweepparams.source_partition<<endl; }
			for(unsigned int v=0; v<VECTOR_SIZE; v++){ cout<<"readandprocess: udata: "<<udata<<", E[1]["<<v<<"]: "<<E[1][v]<<", sweepparams.source_partition: "<<sweepparams.source_partition<<endl; }
		}
		#endif
		
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t mykeyvalue0{{v}};
		{%endfor%}
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t mykeyvalue1{{v}};
		{%endfor%}
		
		if(en == ON && mask == 1){
			{%for v in context['VECTOR_SIZE_seq']%}
			mykeyvalue0{{v}}.key = E[0][{{v}}]; 
			mykeyvalue0{{v}}.value = res; 
			{%endfor%}
			{%for v in context['VECTOR_SIZE_seq']%}
			mykeyvalue1{{v}}.key = E[1][{{v}}]; 
			mykeyvalue1{{v}}.value = res; 
			{%endfor%}
		} else {
			{%for v in context['VECTOR_SIZE_seq']%}
			mykeyvalue0{{v}}.key = INVALIDDATA; 
			mykeyvalue0{{v}}.value = INVALIDDATA; 
			{%endfor%}
			{%for v in context['VECTOR_SIZE_seq']%}
			mykeyvalue1{{v}}.key = INVALIDDATA; 
			mykeyvalue1{{v}}.value = INVALIDDATA; 
			{%endfor%}
		}
		
		mykeyvalue00.key = INVALIDDATA;
		mykeyvalue00.value = INVALIDDATA;
		
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer[{{v}}][loadcount] = acts_utilobj->UTIL_GETKV(mykeyvalue0{{v}});
		buffer[{{v}}][loadcount + 1] = acts_utilobj->UTIL_GETKV(mykeyvalue1{{v}});
		{%endfor%}
		if(en == ON && mask == 1){ loadcount += 2; }
		
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvsprocessed(VECTOR_SIZE*2);
		if(en == ON && mask == 1){ actsutilityobj->globalstats_processedges_countvalidkvsprocessed(VECTOR_SIZE*2); }
		#endif 
	}
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"readandprocess:: lvid_sob: "<<lvid_sob<<", lvid_eob: "<<lvid_eob<<""<<endl;
	#endif
	
	fetchmessage.chunksize_kvs = loadcount;
	return fetchmessage;
}




