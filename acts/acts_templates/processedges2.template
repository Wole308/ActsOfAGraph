void {{context['classname__processedges']}}PROCESS{{context['id']}}_processvector(bool enx, unsigned int v, unsigned int loc, keyvalue_t edata, keyvalue_vbuffer_t vbuffer[BLOCKRAM_VDATA_SIZE], keyvalue_buffer_t buffer[SOURCEBLOCKRAM_SIZE], unsigned int bufferoffset_kvs, unsigned int * loadcount, unsigned int GraphAlgoClass, globalposition_t globalposition, globalparams_t globalparams	
		#ifdef CONFIG_COLLECT_DATAS1_DURING_RUN
		,collection_t collections[COLLECTIONS_BUFFERSZ]
		#endif 
		){				
	#pragma HLS INLINE
	bool en = true; if(edata.key == INVALIDDATA || edata.value == INVALIDDATA || enx == false){ en = false; } else { en = true; }

	if(loc >= globalparams.SIZEKVS2_PROCESSEDGESPARTITION && en == true){
		#ifdef _DEBUGMODE_CHECKS
		if(true){ cout<<"PROCESS{{context['id']}}_processvector::ERROR SEEN @ loc("<<loc<<") >= globalparams.SIZE_REDUCE("<<globalparams.SIZE_REDUCE<<"). edata.key: "<<edata.key<<", edata.value: "<<edata.value<<", v: "<<v<<". EXITING... "<<endl; exit(EXIT_FAILURE); }
		#endif 
		loc = 0; }
	
	// read 
	vmdata_t vmdata;
	#ifdef ALGORITHMTYPE_REPRESENTVDATASASBITS				
		if(en == true){ vmdata = MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK2(loc, NAp, vbuffer, bufferoffset_kvs); } else { vmdata.vmask = 0; }
			#else 
				if(en == true){ vmdata = MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK(loc, vbuffer, 0); } else { vmdata.vmask = 0; }
					#endif 
	if(GraphAlgoClass == ALGORITHMCLASS_ALLVERTEXISACTIVE){ vmdata.vmask = 1; }
	#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
	if(vmdata.vmask == 1){ cout<<">>> PROCESS VECTOR:: ACTIVE VERTEX PROCESSED: SEEN: @ v: "<<v<<", loc: "<<loc<<", edata.key: "<<edata.key<<", edata.value(srcvid): "<<edata.value<<", vid: "<<UTIL{{context['id']}}_GETREALVID(edata.key, globalparams.ACTSPARAMS_INSTID)<<endl; }
	#endif
			
	// process
	value_t res = PROCESS{{context['id']}}_processfunc(vmdata.vdata, 1, globalparams.ALGORITHMINFO_GRAPHALGORITHMID);
	keyvalue_t mykeyvalue; mykeyvalue.key = edata.key; mykeyvalue.value = res;
	
	// write
	if(en == true && vmdata.vmask == 1 && *loadcount < WORKBUFFER_SIZE-2){ buffer[*loadcount] = UTIL{{context['id']}}_GETKV(mykeyvalue); }
	if(en == true && vmdata.vmask == 1 && *loadcount < WORKBUFFER_SIZE-2){ *loadcount += 1; } // CRITICAL FIXME. WORKBUFFER_SIZE
	
	#ifdef CONFIG_COLLECT_DATAS1_DURING_RUN
	collections[0].data1 += 1;
	#endif 
	#ifdef _DEBUGMODE_STATS
	actsutilityobj->globalstats_countkvsprocessed(globalparams.ACTSPARAMS_INSTID, 1);
	if(en == true && vmdata.vmask == 1 && *loadcount < WORKBUFFER_SIZE-2){ actsutilityobj->globalstats_processedges_countvalidkvsprocessed(globalparams.ACTSPARAMS_INSTID, 1); } // mask0? FIXME.
	#endif 
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("PROCESS{{context['id']}}_processvector::DEBUG CODE 14::1", *loadcount, SRCBUFFER_SIZE, SOURCEBLOCKRAM_SIZE, SRCBUFFER_SIZE, NAp); // SOURCEBLOCKRAM_SIZE
	#endif
	return;
}

void {{context['classname__processedges']}}PROCESS{{context['id']}}_GetXYLayoutV(unsigned int s, unsigned int depths[VECTOR_SIZE], unsigned int basedepth){
	unsigned int s_ = s % VECTOR_SIZE;
	
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<context['VECTOR_SIZE']-1)%}if(s_=={{v}}){%endif%}{ 
		{%for v2 in context['VECTOR_SIZE_seq']%}{%if(v2<v)%}
		depths[{{v2}}] = {{context['VECTOR_SIZE']-v+v2}}; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR_SIZE_seq']%}{%if(v2>=v)%}
		depths[{{v2}}] = {{v2-v}}; 
		{%endif%}{%endfor%}
	}
	{%endfor%}
	return;
}

void {{context['classname__processedges']}}PROCESS{{context['id']}}_RearrangeLayoutV(unsigned int s, uint32_type vdata[VECTOR_SIZE], uint32_type vdata2[VECTOR_SIZE]){
	unsigned int s_ = s;// % VECTOR_SIZE;
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<context['VECTOR_SIZE']-1)%}if(s_=={{v}}){%endif%}{ 
		{%for v2 in context['VECTOR_SIZE_seq']%}{%if(v2<v)%}
		vdata2[{{context['VECTOR_SIZE']-v+v2}}] = vdata[{{v2}}]; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR_SIZE_seq']%}{%if(v2>=v)%}
		vdata2[{{v2-v}}] = vdata[{{v2}}]; 
		{%endif%}{%endfor%}
	}
	{%endfor%}
	return;
}

void {{context['classname__reduceupdates']}}PROCESS{{context['id']}}_RearrangeLayoutEn(unsigned int s, bool en[VECTOR_SIZE], bool en2[VECTOR_SIZE]){
	unsigned int s_ = s;// % VECTOR_SIZE;
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<context['VECTOR_SIZE']-1)%}if(s_=={{v}}){%endif%}{ 
		{%for v2 in context['VECTOR_SIZE_seq']%}{%if(v2<v)%}
		en2[{{context['VECTOR_SIZE']-v+v2}}] = en[{{v2}}]; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR_SIZE_seq']%}{%if(v2>=v)%}
		en2[{{v2-v}}] = en[{{v2}}]; 
		{%endif%}{%endfor%}
	}
	{%endfor%}
	return;
}

parsededge_t {{context['classname__processedges']}}PROCESS{{context['id']}}_PARSEEDGE(uint32_type data){ 
	parsededge_t parsededge;
	parsededge.incr = UTIL{{context['id']}}_READFROM_UINT(data, OFFSETOF_SRCV_IN_EDGEDSTVDATA, SIZEOF_SRCV_IN_EDGEDSTVDATA);
	parsededge.dstvid = UTIL{{context['id']}}_READFROM_UINT(data, OFFSETOF_DSTV_IN_EDGEDSTVDATA, SIZEOF_DSTV_IN_EDGEDSTVDATA);
	return parsededge; 
}

void {{context['classname__processedges']}}PROCESS{{context['id']}}_calculateoffsets(keyvalue_capsule_t * buffer){
	buffer[0].key = 0;
	for(buffer_type i=1; i<NUM_PARTITIONS; i++){ 
	#pragma HLS PIPELINE II=2	
		buffer[i].key = buffer[i-1].key + buffer[i-1].value; 
	}
	return;
}

#ifdef CONFIG_ACTS_MEMORYLAYOUT
fetchmessage_t {{context['classname__processedges']}}PROCESS{{context['id']}}_readandprocess(bool_type enable, uint512_dt * edges, uint512_dt * kvdram, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], keyvalue_buffer_t buffer[VECTOR_SIZE][SOURCEBLOCKRAM_SIZE], 
		batch_type goffset_kvs, batch_type loffset_kvs, batch_type size_kvs, travstate_t travstate, sweepparams_t sweepparams, globalposition_t globalposition, globalparams_t globalparams, collection_t collections[NUM_COLLECTIONS][COLLECTIONS_BUFFERSZ]){
	fetchmessage_t fetchmessage;
	fetchmessage.chunksize_kvs = -1;
	fetchmessage.nextoffset_kvs = -1;
	if(enable == OFF){ return fetchmessage; }
	analysis_type analysis_loopcount = (DESTBLOCKRAM_SIZE / (NUM_PARTITIONS / 2));
	
	uint32_type E[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=E complete
	uint32_type E2[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=E2 complete

	buffer_type reducebuffersz = globalparams.SIZE_REDUCE / 2;
	unsigned int validbound = reducebuffersz * FETFACTOR * VECTOR2_SIZE;
	
	travstate_t mytravstate = travstate;
	mytravstate.i_kvs = travstate.i_kvs / 2;
	mytravstate.end_kvs = travstate.end_kvs / 2;
	
	loffset_kvs = loffset_kvs / 2; //
	buffer_type edgessize_kvs = size_kvs / 2;
	
	batch_type offset_kvs = goffset_kvs + loffset_kvs;
	
	value_t res[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=res complete
	unsigned int loadcount[VECTOR_SIZE];
	#pragma HLS ARRAY_PARTITION variable=loadcount complete
	unsigned int depths[VECTOR_SIZE];
	#pragma HLS ARRAY_PARTITION variable=depths complete
	unsigned int d_kvs[VECTOR_SIZE];
	#pragma HLS ARRAY_PARTITION variable=d_kvs complete
	bool enx[VECTOR_SIZE];
	#pragma HLS ARRAY_PARTITION variable=enx complete
	bool enx2[VECTOR_SIZE];
	#pragma HLS ARRAY_PARTITION variable=enx2 complete

	fetchmessage.chunksize_kvs = edgessize_kvs;
	fetchmessage.nextoffset_kvs = -1;
	
	unsigned int GraphAlgo = globalparams.ALGORITHMINFO_GRAPHALGORITHMID;
	unsigned int GraphAlgoClass = globalparams.ALGORITHMINFO_GRAPHALGORITHMCLASS;
	
	keyvalue_t edata[VECTOR_SIZE];
	#pragma HLS ARRAY_PARTITION variable=edata complete
	value_t tempbuffer[VECTOR2_SIZE][SOURCEBLOCKRAM_SIZE]; // OPTIMIZEME
	#pragma HLS array_partition variable = tempbuffer
	keyvalue_capsule_t localcapsule[MAX_NUM_PARTITIONS];
	keyvalue_capsule_t localcapsule_kvs[MAX_NUM_PARTITIONS];
	
	buffer_type chunk_size = UTIL{{context['id']}}_getchunksize_kvs(edgessize_kvs, mytravstate, 0);
	for(unsigned int t=0; t<VECTOR_SIZE; t++){ loadcount[t] = 0; }
	buffer_type maxsize_kvs[2]; 
	buffer_type height_kvs = 0;
	
	unsigned int MYINVALIDDATA = UTIL{{context['id']}}_GETV(INVALIDDATA);
	unsigned int bufferoffset_kvs = 0;
	#ifdef ALGORITHMTYPE_REPRESENTVDATASASBITS
	bufferoffset_kvs = (globalposition.source_partition % VDATA_SHRINK_RATIO) * (UTIL{{context['id']}}_GET_PROCESSEDGESPARTITIONSIZEKVS2(globalparams) / VDATA_SHRINK_RATIO); //  ((BLOCKRAM_VDATA_SIZE / (NUM_PEs)) / 16) * NUM_PEs; // (3 * 24); // 0; BLOCKRAM_VDATA_SIZE
	#endif 
	
	#ifdef _DEBUGMODE_KERNELPRINTS_TRACE
	for (buffer_type i=0; i<globalparams.SIZEKVS2_REDUCEPARTITION; i++){
		{%for v in context['VECTOR2_SIZE_seq']%}
		if(MEMCA{{context['id']}}_READVMASK(vbuffer[{{v}}][i]) == 1){ cout<<"READANDPROCESS: ACTIVE MASK SEEN: @ i: "<<i<<", v: {{v}}"<<", vbuffer[{{v}}]["<<i<<"]: "<<vbuffer[{{v}}][i]<<endl; }
		{%endfor%}
	}
	#endif
	
	// read edge block
	#ifdef DEBUGME_PROCESSEDGES2
	cout<<"processedges2: FIRST: offset_kvs: "<<offset_kvs<<", loffset_kvs: "<<loffset_kvs<<", goffset_kvs: "<<goffset_kvs<<", edgessize_kvs: "<<edgessize_kvs<<", mytravstate.i_kvs: "<<mytravstate.i_kvs<<", mytravstate.end_kvs: "<<mytravstate.end_kvs<<endl;
	#endif 
	PROCESSBUFFERPARTITIONS_LOOP1: for(buffer_type i=0; i<chunk_size; i++){
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		{%for v in context['VECTOR2_SIZE_seq']%}
		tempbuffer[{{v}}][i] = edges[offset_kvs + i].range({{((v + 1) * 32) - 1}}, {{v * 32}}); 
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		tempbuffer[{{2*v}}][i] = edges[offset_kvs + i].data[{{v}}].key; 
		tempbuffer[{{2*v+1}}][i] = edges[offset_kvs + i].data[{{v}}].value;	
		{%endfor%}
		#endif
		
		#ifdef DEBUGME_PROCESSEDGES
		{%for v in context['VECTOR_SIZE_seq']%}
		if(i<4){ cout<<"processedges2: +++ sample edge: edges["<<offset_kvs + i<<"].data[{{v}}].key: "<<edges[offset_kvs + i].data[{{v}}].key<<", edges["<<offset_kvs + i<<"].data[{{v}}].value: "<<edges[offset_kvs + i].data[{{v}}].value<<endl; }
		{%endfor%}
		#endif 
	}
	
	// read edge block stats  
	// bool statsiscorrect = true;
	#ifdef CONFIG_PROCESSEDGES_READOFFLINESTATS
	unsigned int sum_values = 0;
	for(unsigned int p=0; p<NUM_PARTITIONS; p++){ localcapsule[p].key = 0; localcapsule[p].value = tempbuffer[p][0]; if(p<NUM_PARTITIONS-1){ sum_values += tempbuffer[p][0]; }}
	localcapsule[NUM_PARTITIONS-1].value = (chunk_size * VECTOR2_SIZE) - sum_values;
	if(tempbuffer[NUM_PARTITIONS-1][0] != 8888888 || sum_values > chunk_size * VECTOR2_SIZE){
		#if defined(_DEBUGMODE_CHECKS) && defined(CONFIG_INSERTSTATSMETADATAINEDGES) // CRITICAL FIXME.
		if(sum_values > chunk_size * VECTOR2_SIZE && chunk_size > 0){ cout<<"processedges2: ERROR: sum_values("<<sum_values<<") > chunk_size("<<chunk_size<<") * VECTOR2_SIZE. EXITING... "<<endl; actsutilityobj->printkeyvalues("processandbuffer.localcapsule", (keyvalue_t *)localcapsule, NUM_PARTITIONS); exit(EXIT_FAILURE); } 
		if(tempbuffer[NUM_PARTITIONS-1][0] != 8888888){ cout<<"processedges2: ERROR: tempbuffer[NUM_PARTITIONS-1][0] != 8888888. EXITING... "<<endl; for(unsigned int v=0; v<VECTOR2_SIZE; v++){ cout<<"tempbuffer["<<v<<"][0]: "<<tempbuffer[v][0]<<endl; } exit(EXIT_FAILURE); }
		#endif 
		unsigned int modelsz = chunk_size / NUM_PARTITIONS; // mock it
		for(unsigned int i=0; i<NUM_PARTITIONS; i++){ localcapsule[i].key = (i * modelsz) * VECTOR2_SIZE; localcapsule[i].value = modelsz * VECTOR2_SIZE; } 
	}
	#else 
	unsigned int modelsz = chunk_size / NUM_PARTITIONS;
	for(unsigned int i=0; i<NUM_PARTITIONS; i++){ localcapsule[i].key = (i * modelsz) * VECTOR2_SIZE; localcapsule[i].value = modelsz * VECTOR2_SIZE; } 
	#endif 
	PROCESS{{context['id']}}_calculateoffsets(localcapsule);
	#ifdef DEBUGME_PROCESSEDGES2
	actsutilityobj->printkeyvalues("processedges2(14).localcapsule", (keyvalue_t *)localcapsule, NUM_PARTITIONS); 
	cout<<"processedges2(15): "<<"chunk_size * VECTOR2_SIZE: "<<chunk_size * VECTOR2_SIZE<<", edgessize_kvs * VECTOR2_SIZE: "<<edgessize_kvs * VECTOR2_SIZE<<", WORKBUFFER_SIZE * VECTOR2_SIZE: "<<(WORKBUFFER_SIZE * VECTOR2_SIZE)<<endl;
	#endif
	
	// process edge block stats 
	maxsize_kvs[0] = 0; maxsize_kvs[1] = 0;
	unsigned int _poff = 0;
	PROCESSBUFFERPARTITIONS_LOOP3: for(unsigned int cid=0; cid<2; cid++){
		PROCESSBUFFERPARTITIONS_LOOP3B: for(partition_type p=0; p<NUM_PARTITIONS/2; p++){
		#pragma HLS PIPELINE II=2
			unsigned int ssize_kvs = localcapsule[_poff + p].value / VECTOR2_SIZE;
			if(maxsize_kvs[cid] < ssize_kvs){ maxsize_kvs[cid] = ssize_kvs; }
		}
		_poff += NUM_PARTITIONS/2;
	}
	height_kvs = (localcapsule[NUM_PARTITIONS-1].key + localcapsule[NUM_PARTITIONS-1].value) / VECTOR2_SIZE;

	for(partition_type p=0; p<NUM_PARTITIONS; p++){
		localcapsule_kvs[p].key = localcapsule[p].key / VECTOR2_SIZE;
		localcapsule_kvs[p].value = (localcapsule[p].value + (VECTOR2_SIZE-1)) / VECTOR2_SIZE;
	}
	
	// process edge block
	unsigned int readoffset = 0; if(globalparams.ACTSCONFIG_INSERTSTATSMETADATAINEDGES == 1){ readoffset = 1; }
	PROCESSBUFFERPARTITIONS_LOOP4: for(buffer_type capsule_offset=0; capsule_offset<NUM_PARTITIONS; capsule_offset+=VECTOR_SIZE){ // processing next capsule set
		unsigned int mmaxsz_kvs = maxsize_kvs[capsule_offset / VECTOR_SIZE];
		PROCESSBUFFERPARTITIONS_LOOP4B: for(buffer_type block_offset=0; block_offset<VECTOR2_SIZE; block_offset+=VECTOR_SIZE){ // processing next block set 
			PROCESSBUFFERPARTITIONS_LOOP4C: for(unsigned int r=0; r<VECTOR_SIZE; r++){ // interchanging columns
				PROCESSBUFFERPARTITIONS_LOOP4D: for(buffer_type i=0; i<mmaxsz_kvs; i++){ // processing a column data
				#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
				#pragma HLS PIPELINE II=1
					#ifdef _DEBUGMODE_CHECKS2
					actsutilityobj->checkoutofbounds("readandprocess2(12)::DEBUG CODE 12::1", i, SOURCEBLOCKRAM_SIZE, NAp, NAp, NAp);
					#endif
					
					// get layout
					PROCESS{{context['id']}}_GetXYLayoutV(r, depths, 0);
					#ifdef _DEBUGMODE_CHECKS3
					{%for v in context['VECTOR_SIZE_seq']%}
					actsutilityobj->checkoutofbounds("readandprocess2(13)::DEBUG CODE 13::1", capsule_offset + depths[{{v}}], NUM_PARTITIONS, capsule_offset, depths[{{v}}], NAp);
					{%endfor%} 
					#endif
					
					// calculate enable
					{%for v in context['VECTOR_SIZE_seq']%}
					enx[{{v}}] = true;	
					{%endfor%}
					
					// read 
					{%for v in context['VECTOR_SIZE_seq']%}
					unsigned int tdepth{{v}} = capsule_offset + depths[{{v}}];	
					d_kvs[{{v}}] = readoffset + localcapsule_kvs[tdepth{{v}}].key + i; 
					{%endfor%} 	
					{%for v in context['VECTOR_SIZE_seq']%} // FIXME.
					if(d_kvs[{{v}}] < height_kvs && i < localcapsule_kvs[tdepth{{v}}].value){ E[{{v}}] = tempbuffer[block_offset + {{v}}][d_kvs[{{v}}]]; } else { enx[{{v}}] = false; E[{{v}}] = INVALIDDATA; }	
					{%endfor%} 	
					
					// re-arrange 
					PROCESS{{context['id']}}_RearrangeLayoutV(r, E, E2);
					PROCESS{{context['id']}}_RearrangeLayoutEn(r, enx, enx2); // NEWCHANGE.
					{%for v in context['VECTOR_SIZE_seq']%} if(E2[{{v}}]==8888888){ E2[{{v}}] = 0; } {%endfor%}	
					#ifdef _DEBUGMODE_CHECKS3
					{%for v in context['VECTOR_SIZE_seq']%}
					if(E2[{{v}}]==8888888){ cout<<"processedges2: ERROR 65. E2==8888888. EXITING..."<<endl; exit(EXIT_FAILURE); }
					{%endfor%}
					#endif 
					
					// parse
					{%for v in context['VECTOR_SIZE_seq']%}
					parsededge_t parsed_edge{{v}} = PROCESS{{context['id']}}_PARSEEDGE(E2[{{v}}]); // FIXME.
					edata[{{v}}].value = parsed_edge{{v}}.incr; // source info
					edata[{{v}}].key = parsed_edge{{v}}.dstvid;	
					{%endfor%}
					#ifdef _DEBUGMODE_KERNELPRINTS
					{%for v in context['VECTOR_SIZE_seq']%}
					if(edata[{{v}}].value==42 && enx[{{v}}] == true){ cout<<"processedges2: edata[{{v}}].value("<<edata[{{v}}].value<<")==42. edata[{{v}}].key: "<<edata[{{v}}].key<<endl; }
					{%endfor%}
					#endif 
					
					// process
					{%for v in context['VECTOR_SIZE_seq']%}
					PROCESS{{context['id']}}_processvector(enx2[{{v}}], {{v}}, edata[{{v}}].value, edata[{{v}}], vbuffer[capsule_offset + {{v}}], buffer[{{v}}], bufferoffset_kvs, &loadcount[{{v}}], GraphAlgoClass, globalposition, globalparams
						#ifdef CONFIG_COLLECT_DATAS1_DURING_RUN
						,collections[capsule_offset + {{v}}]
						#endif
						);
					{%endfor%}	
					#ifdef _DEBUGMODE_CHECKS2
					{%for v in context['VECTOR_SIZE_seq']%}
					actsutilityobj->checkoutofbounds("readandprocess2(14)::DEBUG CODE 14::1", loadcount[{{v}}], SOURCEBLOCKRAM_SIZE, NAp, NAp, NAp);
					{%endfor%} 
					#endif
				}
			}
		}
	}
	
	// for(unsigned int t=0; t<VECTOR_SIZE; t++){ cout<<"--- loadcount["<<t<<"]: "<<loadcount[t]<<endl; }
	// actsutilityobj->printglobalvars();
	// exit(EXIT_SUCCESS); ////
	
	unsigned int maxsz_kvs = 0;
	for(unsigned int t=0; t<VECTOR_SIZE; t++){ if(loadcount[t] > maxsz_kvs){ maxsz_kvs = loadcount[t]; }}
	fetchmessage.chunksize_kvs = maxsz_kvs;//chunk_size * 2; // loadcount; // CRITICAL FIXME
	return fetchmessage;
}
#endif 
#ifdef CONFIG_TRADITIONAL_MEMORYLAYOUT
fetchmessage_t {{context['classname__processedges']}}PROCESS{{context['id']}}_readandprocess(bool_type enable, uint512_dt * edges, uint512_dt * kvdram, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], keyvalue_buffer_t buffer[VECTOR_SIZE][SOURCEBLOCKRAM_SIZE], 
		batch_type goffset_kvs, batch_type loffset_kvs, batch_type size_kvs, travstate_t travstate, sweepparams_t sweepparams, globalposition_t globalposition, globalparams_t globalparams, collection_t collections[NUM_COLLECTIONS][COLLECTIONS_BUFFERSZ]){
	fetchmessage_t fetchmessage;
	fetchmessage.chunksize_kvs = -1;
	fetchmessage.nextoffset_kvs = -1;
	if(enable == OFF){ return fetchmessage; }
	analysis_type analysis_loopcount = (DESTBLOCKRAM_SIZE / (NUM_PARTITIONS / 2));
	
	uint32_type E[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=E complete
	uint32_type E2[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=E2 complete

	buffer_type reducebuffersz = globalparams.SIZE_REDUCE / 2;
	unsigned int validbound = reducebuffersz * FETFACTOR * VECTOR2_SIZE;
	
	travstate_t mytravstate = travstate;
	mytravstate.i_kvs = travstate.i_kvs / 2;
	mytravstate.end_kvs = travstate.end_kvs / 2;
	
	loffset_kvs = loffset_kvs / 2; //
	buffer_type edgessize_kvs = size_kvs / 2;
	
	batch_type offset_kvs = goffset_kvs + loffset_kvs;
	
	unsigned int loadcount;

	fetchmessage.chunksize_kvs = edgessize_kvs;
	fetchmessage.nextoffset_kvs = -1;
	
	unsigned int GraphAlgo = globalparams.ALGORITHMINFO_GRAPHALGORITHMID;
	unsigned int GraphAlgoClass = globalparams.ALGORITHMINFO_GRAPHALGORITHMCLASS;
	
	keyvalue_t tempbuffer[VECTOR_SIZE][SOURCEBLOCKRAM_SIZE]; // OPTIMIZEME
	#pragma HLS array_partition variable = tempbuffer
	keyvalue_capsule_t localcapsule[MAX_NUM_PARTITIONS];
	keyvalue_capsule_t localcapsule_kvs[MAX_NUM_PARTITIONS];
	
	buffer_type chunk_size = UTIL{{context['id']}}_getchunksize_kvs(edgessize_kvs, mytravstate, 0);
	loadcount = 0;
	buffer_type maxsize_kvs[2]; 
	buffer_type height_kvs = 0;
	
	unsigned int MYINVALIDDATA = UTIL{{context['id']}}_GETV(INVALIDDATA);
	unsigned int bufferoffset_kvs = 0;
	#ifdef ALGORITHMTYPE_REPRESENTVDATASASBITS
	bufferoffset_kvs = (globalposition.source_partition % VDATA_SHRINK_RATIO) * (UTIL{{context['id']}}_GET_PROCESSEDGESPARTITIONSIZEKVS2(globalparams) / VDATA_SHRINK_RATIO); //  ((BLOCKRAM_VDATA_SIZE / (NUM_PEs)) / 16) * NUM_PEs; // (3 * 24); // 0; BLOCKRAM_VDATA_SIZE
	#endif
	
	// read edge block
	#ifdef DEBUGME_PROCESSEDGES2
	cout<<"processedges2: FIRST: offset_kvs: "<<offset_kvs<<", loffset_kvs: "<<loffset_kvs<<", goffset_kvs: "<<goffset_kvs<<", edgessize_kvs: "<<edgessize_kvs<<", mytravstate.i_kvs: "<<mytravstate.i_kvs<<", mytravstate.end_kvs: "<<mytravstate.end_kvs<<endl;
	#endif 
	PROCESSBUFFERPARTITIONS_LOOP1: for(buffer_type i=0; i<chunk_size; i++){
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		{%for v in context['VECTOR2_SIZE_seq']%}
		tempbuffer[{{v}}][i] = edges[offset_kvs + i].range({{((v + 1) * 32) - 1}}, {{v * 32}}); 
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		tempbuffer[{{2*v}}][i] = edges[offset_kvs + i].data[{{v}}].key; 
		tempbuffer[{{2*v+1}}][i] = edges[offset_kvs + i].data[{{v}}].value;	
		{%endfor%}
		#endif
		
		#ifdef DEBUGME_PROCESSEDGES
		{%for v in context['VECTOR_SIZE_seq']%}
		if(i<4){ cout<<"processedges2: +++ sample edge: edges["<<offset_kvs + i<<"].data[{{v}}].key: "<<edges[offset_kvs + i].data[{{v}}].key<<", edges["<<offset_kvs + i<<"].data[{{v}}].value: "<<edges[offset_kvs + i].data[{{v}}].value<<endl; }
		{%endfor%}
		#endif 
	}
	
	// read edge block stats  
	// bool statsiscorrect = true;
	#ifdef CONFIG_PROCESSEDGES_READOFFLINESTATS
	unsigned int sum_values = 0;
	for(unsigned int p=0; p<NUM_PARTITIONS; p++){ localcapsule[p].key = 0; localcapsule[p].value = tempbuffer[p][0]; if(p<NUM_PARTITIONS-1){ sum_values += tempbuffer[p][0]; }}
	localcapsule[NUM_PARTITIONS-1].value = (chunk_size * VECTOR2_SIZE) - sum_values;
	if(tempbuffer[NUM_PARTITIONS-1][0] != 8888888 || sum_values > chunk_size * VECTOR2_SIZE){
		#if defined(_DEBUGMODE_CHECKS) && defined(CONFIG_INSERTSTATSMETADATAINEDGES) // CRITICAL FIXME.
		if(sum_values > chunk_size * VECTOR2_SIZE && chunk_size > 0){ cout<<"processedges2: ERROR: sum_values("<<sum_values<<") > chunk_size("<<chunk_size<<") * VECTOR2_SIZE. EXITING... "<<endl; actsutilityobj->printkeyvalues("processandbuffer.localcapsule", (keyvalue_t *)localcapsule, NUM_PARTITIONS); exit(EXIT_FAILURE); } 
		if(tempbuffer[NUM_PARTITIONS-1][0] != 8888888){ cout<<"processedges2: ERROR: tempbuffer[NUM_PARTITIONS-1][0] != 8888888. EXITING... "<<endl; for(unsigned int v=0; v<VECTOR2_SIZE; v++){ cout<<"tempbuffer["<<v<<"][0]: "<<tempbuffer[v][0]<<endl; } exit(EXIT_FAILURE); }
		#endif 
		unsigned int modelsz = chunk_size / NUM_PARTITIONS; // mock it
		for(unsigned int i=0; i<NUM_PARTITIONS; i++){ localcapsule[i].key = (i * modelsz) * VECTOR2_SIZE; localcapsule[i].value = modelsz * VECTOR2_SIZE; } 
	}
	#else 
	unsigned int modelsz = chunk_size / NUM_PARTITIONS;
	for(unsigned int i=0; i<NUM_PARTITIONS; i++){ localcapsule[i].key = (i * modelsz) * VECTOR2_SIZE; localcapsule[i].value = modelsz * VECTOR2_SIZE; } 
	#endif 
	PROCESS{{context['id']}}_calculateoffsets(localcapsule);
	#ifdef DEBUGME_PROCESSEDGES2
	actsutilityobj->printkeyvalues("processedges2(14).localcapsule", (keyvalue_t *)localcapsule, NUM_PARTITIONS); 
	cout<<"processedges2(15): "<<"chunk_size * VECTOR2_SIZE: "<<chunk_size * VECTOR2_SIZE<<", edgessize_kvs * VECTOR2_SIZE: "<<edgessize_kvs * VECTOR2_SIZE<<", WORKBUFFER_SIZE * VECTOR2_SIZE: "<<(WORKBUFFER_SIZE * VECTOR2_SIZE)<<endl;
	#endif

	for(partition_type p=0; p<NUM_PARTITIONS; p++){
		PROCESSBUFFERPARTITIONS_LOOP1: for(buffer_type i=localcapsule[p].key; i<localcapsule[p].key + localcapsule[p].value; i++){
		#pragma HLS PIPELINE II=1
			value_t E = tempbuffer[i / VECTOR2_SIZE][i % VECTOR2_SIZE];
			
			parsededge_t parsed_edge = PROCESS{{context['id']}}_PARSEEDGE(E);
			keyvalue_t edata; edata.value = parsed_edge.incr; edata.key = parsed_edge.dstvid;	
	
			// read 
			vmdata_t vmdata;
			unsigned int loc = edata.value; //  - sweepparams.upperlimit;
			if(loc >= globalparams.SIZEKVS2_PROCESSEDGESPARTITION){
				#ifdef _DEBUGMODE_CHECKS
				if(true){ cout<<"PROCESS{{context['id']}}_processvector::ERROR SEEN @ loc("<<loc<<") >= globalparams.SIZE_REDUCE("<<globalparams.SIZE_REDUCE<<"). edata.key: "<<edata.key<<", edata.value: "<<edata.value<<", v: "<<v<<". EXITING... "<<endl; exit(EXIT_FAILURE); }
				#endif 
				loc = 0; }
		
			#ifdef ALGORITHMTYPE_REPRESENTVDATASASBITS				
				if(en == true){ vmdata = MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK2(loc, NAp, vbuffer[p], bufferoffset_kvs); } else { vmdata.vmask = 0; }
					#else 
						if(en == true){ vmdata = MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK(loc, vbuffer[p], 0); } else { vmdata.vmask = 0; }
							#endif 
			if(GraphAlgoClass == ALGORITHMCLASS_ALLVERTEXISACTIVE){ vmdata.vmask = 1; }
			#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
			if(vmdata.vmask == 1){ cout<<">>> PROCESS VECTOR:: ACTIVE VERTEX PROCESSED: SEEN: @ loc: "<<loc<<", edata.key: "<<edata.key<<", edata.value(srcvid): "<<edata.value<<", vid: "<<UTIL{{context['id']}}_GETREALVID(edata.key, globalparams.ACTSPARAMS_INSTID)<<endl; }
			#endif
					
			// process
			value_t res = PROCESS{{context['id']}}_processfunc(vmdata.vdata, 1, globalparams.ALGORITHMINFO_GRAPHALGORITHMID);
			keyvalue_t mykeyvalue; mykeyvalue.key = edata.key; mykeyvalue.value = res;
			
			// write
			if(en == true && vmdata.vmask == 1 && loadcount < WORKBUFFER_SIZE-2){ buffer[loadcount % VECTOR_SIZE][loadcount / VECTOR_SIZE] = UTIL{{context['id']}}_GETKV(mykeyvalue); }
			if(en == true && vmdata.vmask == 1 && loadcount < WORKBUFFER_SIZE-2){ loadcount += 1; }
		}
	}
	
	fetchmessage.chunksize_kvs = loadcount / VECTOR_SIZE;
	return fetchmessage;
}
#endif











