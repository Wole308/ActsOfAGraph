#include "processedges_splitdstvxs.h"
using namespace std;

// => VDATA (to read)
// 16:[0,32,...,480] | [1,33,...,481] | ... | [31,63,...,511]

// => VMASK (to read)
// 32:[0,32,...,480,...,992] | [1,33,...,481,...,993] | ... | [31,63,...,511,...,1023]

// int programglobalvar_numvtxsprocessed = 0; // program global variables

#ifdef SW
processedges_splitdstvxs::processedges_splitdstvxs(mydebug * _mydebugobj){ 
	actsutilityobj = new actsutility(); 
	acts_utilobj = new acts_util(_mydebugobj); 
	mem_accessobj = new mem_access(_mydebugobj);
	mydebugobj = _mydebugobj;
}
processedges_splitdstvxs::~processedges_splitdstvxs(){}
#endif

//
value_t {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL_processfunc(value_t udata, value_t edgew, unsigned int GraphAlgo){
	value_t res = 0;
	/* if(GraphAlgo == PAGERANK){
		res = udata;
	} else if(GraphAlgo == BFS){
		res = NAp;
	} else if(GraphAlgo == SSSP){
		res = udata + edgew;
	} else {
		res = NAp;
	} */
	
	res = udata + edgew;
	return res;
}

parsededge_t {{context['classname__processedges_splitdstvxs']}}PARSE_EDGE(uint32_type data){ 
	parsededge_t parsededge;
	#ifdef _WIDEWORD
	parsededge.incr = data.range(31, 28);
	parsededge.dstvid = data.range(28, 0);
	#else
	parsededge.incr = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_READFROM_UINT(data, 28, 4);
	parsededge.dstvid = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_READFROM_UINT(data, 0, 28);
	#endif
	return parsededge; 
}

void {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL_debug(unsigned int debugid,
	unsigned int i, value_t E[VECTOR2_SIZE], bool_type ens[VECTOR2_SIZE], unsigned int mask[VECTOR2_SIZE],
		value_t udataset[MAX_NUM_UNIQ_EDGES_PER_VEC], value_t maskset[VECTOR2_SIZE], value_t Vset[2][VECTOR2_SIZE], unit1_type VMset[2][VECTOR2_SIZE], vertex_t lvids[VECTOR2_SIZE],
			unsigned int incr[VECTOR2_SIZE], unsigned int lsrcvids[VECTOR2_SIZE], unsigned int ldstvids[VECTOR2_SIZE], value_t res[VECTOR2_SIZE], keyvalue_t mykeyvalue[VECTOR2_SIZE], sweepparams_t sweepparams, globalparams_t globalparams,
				unsigned int lvid_head, unsigned int srcvid_head, travstate_t travstate, unsigned int chunk_size, sliceinfos_t sliceinfos, unsigned int * activeloadcount, unsigned int * inactiveloadcount, unsigned int * debug_numinvalidheads
				){
	buffer_type reducebuffersz = globalparams.SIZE_REDUCE / 2;
	unsigned int validbound = reducebuffersz * FETFACTOR * VECTOR2_SIZE;
	
	if(debugid == 0){
		#ifdef _DEBUGMODE_KERNELPRINTS
		{%for v in context['VECTOR2_SIZE_seq']%}
		cout<<"readandprocess(1-2)::DEBUG CODE 0:: E[{{v}}]: "<<E[{{v}}]<<endl;
		{%endfor%}
		#endif
	}
	
	if(debugid == 1){
		#ifdef _DEBUGMODE_CHECKS
		if(srcvid_head < travstate.i2){ cout<<"readandprocess(12)::DEBUG CODE 1:: INVALID srcvid_head. this is an error. i: "<<i<<"(of "<<chunk_size<<"), srcvid_head: "<<srcvid_head<<", travstate.i2: "<<travstate.i2<<" offset_kvs: "<<offset_kvs<<". exiting..."<<endl;					 
			for(unsigned int v=0; v<VECTOR_SIZE; v++){ cout<<"readandprocess(12): E["<<v<<"]: "<<E[v]<<endl; }
			exit(EXIT_FAILURE); }
		if(lvid_head >= (reducebuffersz*FETFACTOR*VECTOR2_SIZE)){ cout<<"readandprocess(12)::DEBUG CODE 1:: INVALID srcvid_head. this is an error. i: "<<i<<"(of "<<chunk_size<<"), lvid_head: "<<lvid_head<<", reducebuffersz*FETFACTOR*VECTOR2_SIZE: "<<reducebuffersz*FETFACTOR*VECTOR2_SIZE<<". exiting..."<<endl;					 
			for(unsigned int v=0; v<VECTOR_SIZE; v++){ cout<<"readandprocess(12)::DEBUG CODE 1:: E["<<v<<"]: "<<E[v]<<endl; }
			exit(EXIT_FAILURE); }
		actsutilityobj->checkoutofbounds("readandprocess(12)::DEBUG CODE 1::1", lvid_head, reducebuffersz * FETFACTOR * VECTOR2_SIZE, srcvid_head, travstate.i2, i);
		#endif
	}
	
	if(debugid == 2){
		#ifdef _DEBUGMODE_KERNELPRINTS
		{%for r in context['8_seq']%}
		cout<<"readandprocess(2)::DEBUG CODE 2:: lvid_head: "<<lvid_head<<", lvid: "<<lvid_head + {{r}}<<", udataset[{{r}}]: "<<udataset[{{r}}]<<", maskset[{{r}}]: "<<maskset[{{r}}]<<endl;
		{%endfor%}
		#endif
		#ifdef _DEBUGMODE_CHECKS
		{%for r in context['8_seq']%}
		if(maskset[{{r}}] > 2){ cout<<"ERROR @ readandprocess(13)::DEBUG CODE 2::.maskset[{{r}}].1. maskset[{{r}}]: "<<maskset[{{r}}]<<endl; for(unsigned int n=0; n<8; n++){ cout<<">>> readandprocess.mask: maskset["<<n<<"]: "<<maskset[n]<<", lvid + {{r}}: "<<lvid + {{r}}<<endl; } exit(EXIT_FAILURE); }
		{%endfor%}
		#endif
	}
	
	if(debugid == 3){
		#ifdef _DEBUGMODE_KERNELPRINTS
		{%for v in context['VECTOR2_SIZE_seq']%}
		cout<<"readandprocess(3)::DEBUG CODE 3:: E[{{v}}]: "<<E[{{v}}]<<", lvid_head: "<<lvid_head<<", incr[{{v}}]: "<<incr[{{v}}]<<", lsrcvids[{{v}}]: "<<lsrcvids[{{v}}]<<", ens[{{v}}]: "<<ens[{{v}}]<<endl;
		{%endfor%}
		#endif
		#ifdef _DEBUGMODE_CHECKS2
		{%for v in context['VECTOR2_SIZE_seq']%}
		if(ens[{{v}}] == ON && incr[{{v}}] >= MAX_NUM_UNIQ_EDGES_PER_VEC){ 
			cout<<"readandprocess(12)::DEBUG CODE 3:: incr[{{v}}]("<<incr[{{v}}]<<") > MAX_NUM_UNIQ_EDGES_PER_VEC("<<MAX_NUM_UNIQ_EDGES_PER_VEC<<"). lsrcvids[{{v}}]: "<<lsrcvids[{{v}}]<<", ldstvids[{{v}}]: "<<ldstvids[{{v}}]<<endl;
			{%for n in context['VECTOR2_SIZE_seq']%} cout<<">>> readandprocess(12)::DEBUG CODE 3::mask: E[{{n}}]: "<<E[{{n}}]<<", lvid_head: "<<lvid_head<<", lsrcvids[{{n}}]: "<<lsrcvids[{{n}}]<<", ldstvids[{{n}}]: "<<ldstvids[{{n}}]<<", incr[{{n}}]: "<<incr[{{n}}]<<endl; {%endfor%} 
			for(unsigned int r=0; r<MAX_NUM_UNIQ_EDGES_PER_VEC; r++){ cout<<">>> readandprocess(12)::DEBUG CODE 3::mask: udataset["<<r<<"]: "<<udataset[r]<<", maskset["<<r<<"]: "<<maskset[r]<<endl; }
			exit(EXIT_FAILURE); 
		}
		{%endfor%}
		#endif
		#ifdef _DEBUGMODE_CHECKS2
		{%for v in context['VECTOR2_SIZE_seq']%}
		if(lsrcvids[{{v}}] >= validbound){
			if(*debug_numinvalidheads > 32){
			{%for n in context['VECTOR2_SIZE_seq']%} cout<<">>> readandprocess(17)::DEBUG CODE 3:: mask: E[{{n}}]: "<<E[{{n}}]<<", lvid_head: "<<lvid_head<<", lsrcvids[{{n}}]: "<<lsrcvids[{{n}}]<<", ldstvids[{{n}}]: "<<ldstvids[{{n}}]<<", incr[{{n}}]: "<<incr[{{n}}]<<endl; {%endfor%} 
			cout<<"readandprocess::::DEBUG CODE 3::ERROR(17): "<<*debug_numinvalidheads<<" srcv heads found (4 was limit set). i: "<<i<<" (of "<<chunk_size<<"), v: {{v}}, validbound: "<<validbound<<", *debug_numinvalidheads: "<<*debug_numinvalidheads<<". EXITING..."<<endl; exit(EXIT_FAILURE); } 
			else {
			// cout<<"readandprocess:: i: "<<i<<" (of "<<chunk_size<<"), v: {{v}}, validbound: "<<validbound<<", *debug_numinvalidheads: "<<*debug_numinvalidheads<<endl;
			*debug_numinvalidheads += 1; }}
		{%endfor%}
		#endif 
	}
	
	if(debugid == 4){
		#ifdef _DEBUGMODE_CHECKS2
		{%for v in context['VECTOR2_SIZE_seq']%}
		if(ens[{{v}}] == ON && mask[{{v}}] > 2){ 
			cout<<"ERROR @ readandprocess(14)::DEBUG CODE 4::mask[{{v}}].2. i: "<<i<<", mask[{{v}}]: "<<mask[{{v}}]<<", incr[{{v}}]: "<<incr[{{v}}]<<endl;
			{%for n in context['VECTOR2_SIZE_seq']%} cout<<">>> readandprocess(14)::DEBUG CODE 4:: mask: E[{{n}}]: "<<E[{{n}}]<<", lvid_head: "<<lvid_head<<", lsrcvids[{{n}}]: "<<lsrcvids[{{n}}]<<", ldstvids[{{n}}]: "<<ldstvids[{{n}}]<<", incr[{{n}}]: "<<incr[{{n}}]<<", mask[{{v}}]: "<<mask[{{v}}]<<endl; {%endfor%} 
			for(unsigned int r=0; r<MAX_NUM_UNIQ_EDGES_PER_VEC; r++){ cout<<">>> readandprocess(14)::DEBUG CODE 4:: mask: udataset["<<r<<"]: "<<udataset[r]<<", maskset["<<r<<"]: "<<maskset[r]<<endl; }
			cout<<"ERROR @ readandprocess(14)::DEBUG CODE 4::. sliceinfos.slice[0].beginoffset: "<<sliceinfos.slice[0].beginoffset<<", sliceinfos.slice[0].endoffset: "<<sliceinfos.slice[0].endoffset<<endl;
			cout<<"ERROR @ readandprocess(14)::DEBUG CODE 4::. sliceinfos.slice[1].beginoffset: "<<sliceinfos.slice[1].beginoffset<<", sliceinfos.slice[1].endoffset: "<<sliceinfos.slice[1].endoffset<<endl;
			exit(EXIT_FAILURE); 
		}
		{%endfor%}
		#endif
	}
	
	if(debugid == 5){
		#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
		{%for v in context['VECTOR2_SIZE_seq']%}
		if(ens[{{v}}] == ON && mask[{{v}}] == 1){ cout<<"readandprocess(15)::DEBUG CODE 5:: [i: "<<i<<", lsrcvids[{{v}}]: "<<lsrcvids[{{v}}]<<", ldstvids[{{v}}]: "<<ldstvids[{{v}}]<<", udata: "<<udataset[incr[{{v}}]]<<"], [ens[{{v}}]: "<<ens[{{v}}]<<", mask[{{v}}]: "<<mask[{{v}}]<<"]. sweepparams.source_partition: "<<sweepparams.source_partition<<endl; }			
		{%endfor%}	
		#endif
	}
	
	if(debugid == 6){
		#ifdef _DEBUGMODE_CHECKS3
		{%for v in context['VECTOR2_SIZE_seq']%}
		if(mykeyvalue[{{v}}].key == INVALIDDATA || mykeyvalue[{{v}}].value == INVALIDDATA){ *inactiveloadcount += 1; } else { *activeloadcount += 1; } 
		{%endfor%}
		#endif 
	}

	if(debugid == 7){
		#ifdef _DEBUGMODE_STATS
		{%for v in context['VECTOR2_SIZE_seq']%}
		actsutilityobj->globalstats_countkvsprocessed(1);
		if(ens[{{v}}] == ON && mask[{{v}}] == 1){ actsutilityobj->globalstats_processedges_countvalidkvsprocessed(1); } // mask0? FIXME.
		{%endfor%}
		#endif 
	}
	return;
}

void {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL_getslice(sliceinfo_t slice, int id, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], value_t Vdatas[VECTOR2_SIZE], unit1_type VMdatas[VECTOR2_SIZE], unsigned int depths[16], globalparams_t globalparams){
	// if(slice.active == false){ return; }
	int s_base_row = slice.s_base * (globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs);
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	int s_{{v}} = slice.s_base + {{v}};
	bool en{{v}}=false; if({{v}}>=slice.beginoffset && {{v}}<slice.endoffset){ en{{v}} = true; } else { en{{v}} = false; }
	int rowoffseti{{v}} = 0; if(en{{v}}==true){ rowoffseti{{v}} = s_base_row + depths[{{v}}]; } 
	// int rowoffseti{{v}} = s_base_row + depths[{{v}}];
	unsigned int row{{v}} = rowoffseti{{v}} + slice.local_rowoffset;
	#ifdef _DEBUGMODE_CHECKS2
	if(en{{v}}==true){ actsutilityobj->checkoutofbounds("PROCESS_SPL_getslicee. row{{v}}", row{{v}}, DOUBLE_BLOCKRAM_SIZE, rowoffseti{{v}}, slice.local_rowoffset, NAp); }
	#endif 
	{%endfor%}
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	VMdatas[{{v}}] = vmaskBITS[{{v}}][row{{v}}];	
	keyvalue_t V{{v}}; if(en{{v}}==true){ V{{v}} = UTIL_GETKV2(vbuffer[{{v}}][row{{v}}/2]); }
	if(en{{v}}==true){ if(s_{{v}}%2==0){ Vdatas[{{v}}] = V{{v}}.key; } else { Vdatas[{{v}}] = V{{v}}.value; }}
	{%endfor%}
	return;
}

//
value_t {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL_GETVTXDATA(keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], unsigned int loc, globalparams_t globalparams){
	#pragma HLS INLINE
	if(loc >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE){ 
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<">>> PROCESS_SPL_GETVTXDATA: ERROR DETECTED (23). loc("<<loc<<") >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE("<<globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE<<"). loc: "<<loc<<endl;
		#endif 
		loc = 0; }
	
	unsigned int instid = loc % NUM_PEs;
	unsigned int lloc = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETLOCALVID(loc, instid);
	unsigned int rowoffset = instid * (globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs); // TOO EXPENSIVE.
	
	unsigned int col = lloc % 16;
	unsigned int row = lloc / 16;
	unsigned int realcol = col;
	unsigned int realrow = (rowoffset + row) / 2;
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<">>> PROCESS_SPL_GETVTXDATA: loc: "<<loc<<", instid: "<<instid<<", lloc: "<<lloc<<", col: "<<col<<", row: "<<row<<", realrow: "<<realrow<<", rowoffset: "<<rowoffset<<", (globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs): "<<globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs<<endl;
	#endif 
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("PROCESS_SPL_GETVTXDATA.lloc", lloc, (globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs) * VECTOR2_SIZE, loc, rowoffset, NAp); 
	actsutilityobj->checkoutofbounds("PROCESS_SPL_GETVTXDATA.rowoffset", rowoffset, REDUCEPARTITIONSZ_KVS2, loc, rowoffset, NAp); 
	actsutilityobj->checkoutofbounds("PROCESS_SPL_GETVTXDATA.realcol", realcol, VDATA_PACKINGSIZE, loc, rowoffset, NAp);
	actsutilityobj->checkoutofbounds("PROCESS_SPL_GETVTXDATA.realrow", realrow, BLOCKRAM_SIZE, loc, rowoffset, NAp);
	actsutilityobj->checkoutofbounds("PROCESS_SPL_GETVTXDATA.row", rowoffset + row, REDUCEPARTITIONSZ_KVS2, loc, rowoffset, NAp);
	#endif 
	
	value_t data = 0;
	if(row % 2 == 0){ data = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV2(vbuffer[realcol][realrow]).key; } 
	else { data = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV2(vbuffer[realcol][realrow]).value; }
	return data;
}

value_t {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL_GETVTXMASK(unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], unsigned int loc, globalparams_t globalparams){
	#pragma HLS INLINE
	if(loc >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE){ 
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<">>> PROCESS_SPL_GETVTXMASK: ERROR DETECTED (23). loc("<<loc<<") >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE("<<globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE<<"). loc: "<<loc<<endl;
		#endif 
		loc = 0; }
		
	unsigned int instid = loc % NUM_PEs;
	unsigned int lloc = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETLOCALVID(loc, instid);
	unsigned int rowoffset = instid * (globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs);
	
	unsigned int col = lloc % 16;
	unsigned int row = lloc / 16;
	unsigned int realcol = col;
	unsigned int realrow = rowoffset + row;
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<">>> PROCESS_SPL_GETVTXMASK: loc: "<<loc<<", col: "<<col<<", row: "<<row<<", realcol: "<<realcol<<", realrow: "<<realrow<<endl;
	#endif 
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("UTIL_SETVTXMASK.row", row, REDUCEPARTITIONSZ_KVS2, col, row, NAp);
	actsutilityobj->checkoutofbounds("UTIL_SETVTXMASK.realcol", realcol, VDATA_PACKINGSIZE, col, row, NAp);
	actsutilityobj->checkoutofbounds("UTIL_SETVTXMASK.realrow", realrow, DOUBLE_BLOCKRAM_SIZE, col, row, NAp); 
	#endif 
	
	value_t data = vmaskBITS[realcol][realrow];
	return data;
}

value_t {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL_GETVTXDATA_SLIDED(keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], unsigned int loc, globalparams_t globalparams){
	#pragma HLS INLINE
	if(loc >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE){ 
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<">>> PROCESS_SPL_GETVTXDATA_SLIDED: ERROR DETECTED (23). loc("<<loc<<") >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE("<<globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE<<"). loc: "<<loc<<endl;
		#endif 
		loc = 0; }
	
	unsigned int s = loc % NUM_PEs;
	unsigned int lloc = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETLOCALVID(loc, s);
	unsigned int rowoffset = s * (globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs); // TOO EXPENSIVE.
	
	unsigned int col = lloc % 16;
	unsigned int row = lloc / 16;
	unsigned int realcol = col;
	unsigned int rrealcol = (s + realcol) % 16;
	unsigned int realrow = (rowoffset + row) / 2;
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<">>> PROCESS_SPL_GETVTXDATA_SLIDED: loc: "<<loc<<", instid: "<<s<<", lloc: "<<lloc<<", col: "<<col<<", row: "<<row<<", realrow: "<<realrow<<", rowoffset: "<<rowoffset<<", (globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs): "<<globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs<<endl;
	#endif 
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("PROCESS_SPL_GETVTXDATA_SLIDED.lloc", lloc, (globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs) * VECTOR2_SIZE, loc, rowoffset, NAp); 
	actsutilityobj->checkoutofbounds("PROCESS_SPL_GETVTXDATA_SLIDED.rowoffset", rowoffset, REDUCEPARTITIONSZ_KVS2, loc, rowoffset, NAp); 
	actsutilityobj->checkoutofbounds("PROCESS_SPL_GETVTXDATA_SLIDED.realcol", realcol, VDATA_PACKINGSIZE, loc, rowoffset, NAp);
	actsutilityobj->checkoutofbounds("PROCESS_SPL_GETVTXDATA_SLIDED.rrealcol", rrealcol, VDATA_PACKINGSIZE, loc, rowoffset, NAp);
	actsutilityobj->checkoutofbounds("PROCESS_SPL_GETVTXDATA_SLIDED.realrow", realrow, BLOCKRAM_SIZE, loc, rowoffset, NAp);
	actsutilityobj->checkoutofbounds("PROCESS_SPL_GETVTXDATA_SLIDED.row", rowoffset + row, REDUCEPARTITIONSZ_KVS2, loc, rowoffset, NAp);
	#endif 
	
	value_t data = 0;
	if(row % 2 == 0){ data = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV2(vbuffer[rrealcol][realrow]).key; } 
	else { data = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV2(vbuffer[rrealcol][realrow]).value; }
	return data;
}

value_t {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL_GETVTXMASK_SLIDED(unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], unsigned int loc, globalparams_t globalparams){
	#pragma HLS INLINE
	if(loc >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE){ 
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<">>> PROCESS_SPL_GETVTXMASK: ERROR DETECTED (23). loc("<<loc<<") >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE("<<globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE<<"). loc: "<<loc<<endl;
		#endif 
		loc = 0; }
		
	unsigned int s = loc % NUM_PEs;
	unsigned int lloc = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETLOCALVID(loc, s);
	unsigned int rowoffset = s * (globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs);
	
	unsigned int col = lloc % 16;
	unsigned int row = lloc / 16;
	unsigned int realcol = col;
	unsigned int rrealcol = (s + realcol) % 16;
	unsigned int realrow = rowoffset + row;
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<">>> PROCESS_SPL_GETVTXMASK: loc: "<<loc<<", col: "<<col<<", row: "<<row<<", realcol: "<<realcol<<", realrow: "<<realrow<<endl;
	#endif 
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("UTIL_SETVTXMASK.row", row, REDUCEPARTITIONSZ_KVS2, col, row, NAp);
	actsutilityobj->checkoutofbounds("UTIL_SETVTXMASK.realcol", realcol, VDATA_PACKINGSIZE, col, row, NAp);
	actsutilityobj->checkoutofbounds("UTIL_SETVTXMASK.rrealcol", rrealcol, VDATA_PACKINGSIZE, col, row, NAp);
	actsutilityobj->checkoutofbounds("UTIL_SETVTXMASK.realrow", realrow, DOUBLE_BLOCKRAM_SIZE, col, row, NAp); 
	#endif 
	
	value_t data = vmaskBITS[rrealcol][realrow];
	return data;
}

sliceinfos_t {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL_GETVTXSLICES(unsigned int loc, globalparams_t globalparams){					
	#pragma HLS INLINE
	if(loc >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE){ 
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<">>> PROCESS_SPL_GETVTXMASK: ERROR DETECTED (23). loc("<<loc<<") >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE("<<globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE<<"). loc: "<<loc<<endl;
		#endif 
		loc = 0; }

	int s_begin = loc % NUM_PEs; //
	int llocA = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETLOCALVID(loc, s_begin);
	int v_begin = llocA % 16; //
	int s_base = -1 * v_begin;
	int row = llocA / 16;

	int loc2 = ((loc / NUM_PEs) * NUM_PEs) + NUM_PEs;
	int s_beginB = 0;
	int llocB = llocA + 1;
	int v_beginB = llocB % 16;
	int s_baseB = -1 * v_beginB;
	int rowB = llocB / 16;
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"PROCESS_SPL_GETVTXSLICES(A): loc: "<<loc<<", s_begin: "<<s_begin<<", llocA: "<<llocA<<", v_begin: "<<v_begin<<", s_base: "<<s_base<<", row: "<<row<<endl;
	cout<<"PROCESS_SPL_GETVTXSLICES(B): loc2: "<<loc2<<", s_beginB: "<<s_beginB<<", llocB: "<<llocB<<", v_beginB: "<<v_beginB<<", s_baseB: "<<s_baseB<<", rowB: "<<rowB<<" "<<endl;
	#endif 
	
	sliceinfo_t sliceX; sliceX.active = false; sliceX.beginoffset = 0; sliceX.endoffset = NUM_PEs;
	sliceinfo_t sliceY; sliceY.active = false; sliceY.beginoffset = 0; sliceY.endoffset = NUM_PEs;

	int s_baseX; 
	int s_baseY;
	
	int rowX; 
	int rowY;
	
	int s_baseA0 = s_base+0;
	int s_baseA1 = s_base+VECTOR2_SIZE;
	int s_baseA2 = s_base+VECTOR2_SIZE+VECTOR2_SIZE;
	
	int s_baseB0 = s_baseB+0;
	int s_baseB1 = s_baseB+VECTOR2_SIZE;
	int s_baseB2 = s_baseB+VECTOR2_SIZE+VECTOR2_SIZE;

	if(s_begin>=s_baseA0 && s_begin<s_baseA0+VECTOR2_SIZE){
		sliceX.active = true; sliceX.s_base = s_baseA0; sliceX.beginoffset = s_begin - s_baseA0; if(s_baseA0 + VECTOR2_SIZE > NUM_PEs){ sliceX.endoffset = NUM_PEs - s_baseA0; } else{ sliceX.endoffset = VECTOR2_SIZE; } sliceX.local_rowoffset = row; 
		sliceY.active = true; sliceY.s_base = s_baseA1; sliceY.beginoffset = 0; if(s_baseA1 + VECTOR2_SIZE > NUM_PEs){ sliceY.endoffset = NUM_PEs - s_baseA1; } else{ sliceY.endoffset = VECTOR2_SIZE; } sliceY.local_rowoffset = row; 
	} else if(s_begin>=s_baseA1 && s_begin<s_baseA1+VECTOR2_SIZE){
		sliceX.active = true; sliceX.s_base = s_baseA1; sliceX.beginoffset = s_begin - s_baseA1; if(s_baseA1 + VECTOR2_SIZE > NUM_PEs){ sliceX.endoffset = NUM_PEs - s_baseA1; } else { sliceX.endoffset = VECTOR2_SIZE; } sliceX.local_rowoffset = row; 
		sliceY.active = true; sliceY.s_base = s_baseA2; sliceY.beginoffset = 0; if(s_baseA2 + VECTOR2_SIZE > NUM_PEs){ sliceY.endoffset = NUM_PEs - s_baseA2; } else{ sliceY.endoffset = VECTOR2_SIZE; } sliceY.local_rowoffset = row; 
	} else if(s_begin>=s_baseA2 && s_begin<s_baseA2+VECTOR2_SIZE){
		sliceX.active = true; sliceX.s_base = s_baseA2; sliceX.beginoffset = s_begin - s_baseA2; if(s_baseA2 + VECTOR2_SIZE > NUM_PEs){ sliceX.endoffset = NUM_PEs - s_baseA2; } else { sliceX.endoffset = VECTOR2_SIZE; } sliceX.local_rowoffset = row; 
		sliceY.active = true; sliceY.s_base = s_baseB0; sliceY.beginoffset = s_beginB - s_baseB0; if(s_baseB0 + VECTOR2_SIZE > NUM_PEs){ sliceY.endoffset = NUM_PEs - s_baseB0; } else{ sliceY.endoffset = VECTOR2_SIZE; } sliceY.local_rowoffset = rowB; 
	} else {
		#ifdef _DEBUGMODE_CHECKS2
		cout<<"PROCESS_SPL_GETVTXSLICES:: SHOULD NOT BE SEEN. 23 EXITING..."<<endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	
	sliceinfos_t sliceinfos; sliceinfos.slice[0] = sliceX; sliceinfos.slice[1] = sliceY;
	return sliceinfos;
}

sliceinfo_t {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL_GETVTXSLICE(unsigned int id, unsigned int loc, globalparams_t globalparams){					
	#pragma HLS INLINE
	if(loc >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE){ 
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<">>> PROCESS_SPL_GETVTXMASK: ERROR DETECTED (23). loc("<<loc<<") >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE("<<globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE<<"). loc: "<<loc<<endl;
		#endif 
		loc = 0; }

	int s_begin = loc % NUM_PEs; //
	int llocA = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETLOCALVID(loc, s_begin);
	int v_begin = llocA % 16; //
	int s_base = -1 * v_begin;
	int row = llocA / 16;

	int loc2 = ((loc / NUM_PEs) * NUM_PEs) + NUM_PEs;
	int s_beginB = 0;
	int llocB = llocA + 1;
	int v_beginB = llocB % 16;
	int s_baseB = -1 * v_beginB;
	int rowB = llocB / 16;
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"PROCESS_SPL_GETVTXSLICES(A): loc: "<<loc<<", s_begin: "<<s_begin<<", llocA: "<<llocA<<", v_begin: "<<v_begin<<", s_base: "<<s_base<<", row: "<<row<<endl;
	cout<<"PROCESS_SPL_GETVTXSLICES(B): loc2: "<<loc2<<", s_beginB: "<<s_beginB<<", llocB: "<<llocB<<", v_beginB: "<<v_beginB<<", s_baseB: "<<s_baseB<<", rowB: "<<rowB<<" "<<endl;
	#endif 
	
	sliceinfo_t sliceX; sliceX.active = false; sliceX.beginoffset = 0; sliceX.endoffset = NUM_PEs;
	sliceinfo_t sliceY; sliceY.active = false; sliceY.beginoffset = 0; sliceY.endoffset = NUM_PEs;

	int s_baseX; 
	int s_baseY;
	
	int rowX; 
	int rowY;
	
	int s_baseA0 = s_base+0;
	int s_baseA1 = s_base+VECTOR2_SIZE;
	int s_baseA2 = s_base+VECTOR2_SIZE+VECTOR2_SIZE;
	
	int s_baseB0 = s_baseB+0;
	int s_baseB1 = s_baseB+VECTOR2_SIZE;
	int s_baseB2 = s_baseB+VECTOR2_SIZE+VECTOR2_SIZE;

	if(s_begin>=s_baseA0 && s_begin<s_baseA0+VECTOR2_SIZE){
		sliceX.active = true; sliceX.s_base = s_baseA0; sliceX.beginoffset = s_begin - s_baseA0; if(s_baseA0 + VECTOR2_SIZE > NUM_PEs){ sliceX.endoffset = NUM_PEs - s_baseA0; } else{ sliceX.endoffset = VECTOR2_SIZE; } sliceX.local_rowoffset = row; 
		sliceY.active = true; sliceY.s_base = s_baseA1; sliceY.beginoffset = 0; if(s_baseA1 + VECTOR2_SIZE > NUM_PEs){ sliceY.endoffset = NUM_PEs - s_baseA1; } else{ sliceY.endoffset = VECTOR2_SIZE; } sliceY.local_rowoffset = row; 
	} else if(s_begin>=s_baseA1 && s_begin<s_baseA1+VECTOR2_SIZE){
		sliceX.active = true; sliceX.s_base = s_baseA1; sliceX.beginoffset = s_begin - s_baseA1; if(s_baseA1 + VECTOR2_SIZE > NUM_PEs){ sliceX.endoffset = NUM_PEs - s_baseA1; } else { sliceX.endoffset = VECTOR2_SIZE; } sliceX.local_rowoffset = row; 
		sliceY.active = true; sliceY.s_base = s_baseA2; sliceY.beginoffset = 0; if(s_baseA2 + VECTOR2_SIZE > NUM_PEs){ sliceY.endoffset = NUM_PEs - s_baseA2; } else{ sliceY.endoffset = VECTOR2_SIZE; } sliceY.local_rowoffset = row; 
	} else if(s_begin>=s_baseA2 && s_begin<s_baseA2+VECTOR2_SIZE){
		sliceX.active = true; sliceX.s_base = s_baseA2; sliceX.beginoffset = s_begin - s_baseA2; if(s_baseA2 + VECTOR2_SIZE > NUM_PEs){ sliceX.endoffset = NUM_PEs - s_baseA2; } else { sliceX.endoffset = VECTOR2_SIZE; } sliceX.local_rowoffset = row; 
		sliceY.active = true; sliceY.s_base = s_baseB0; sliceY.beginoffset = s_beginB - s_baseB0; if(s_baseB0 + VECTOR2_SIZE > NUM_PEs){ sliceY.endoffset = NUM_PEs - s_baseB0; } else{ sliceY.endoffset = VECTOR2_SIZE; } sliceY.local_rowoffset = rowB; 
	} else {
		#ifdef _DEBUGMODE_CHECKS2
		cout<<"PROCESS_SPL_GETVTXSLICES:: SHOULD NOT BE SEEN. 23 EXITING..."<<endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	
	sliceinfo_t sliceinfo;
	if(id==0){ sliceinfo = sliceX; } else { sliceinfo = sliceY; }
	return sliceinfo;
}

void {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL_GETVTXDATASET(sliceinfo_t slice, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], value_t Vdatas[VECTOR2_SIZE], unit1_type VMdatas[VECTOR2_SIZE], unsigned int depths[16], globalparams_t globalparams){					
	#pragma HLS INLINE
	PROCESS_SPL_getslice(slice, 0, vbuffer, vmaskBITS, Vdatas, VMdatas, depths, globalparams);
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	for(unsigned int t=0; t<VECTOR2_SIZE; t++){ cout<<"PROCESS_SPL_GETVTXDATASET:: VMdatas["<<t<<"]: "<<VMdatas[t]<<endl; }
	for(unsigned int t=0; t<VECTOR2_SIZE; t++){ cout<<"PROCESS_SPL_GETVTXDATASET:: VMdatas["<<t<<"]: "<<VMdatas[t]<<endl; }
	#endif
	return;
}

void {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL1_GETVTXDATASET(unsigned int loc, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], value_t Vdatas[MAX_NUM_UNIQ_EDGES_PER_VEC], unit1_type VMdatas[MAX_NUM_UNIQ_EDGES_PER_VEC], globalparams_t globalparams){
	#pragma HLS INLINE
	if(loc >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE){ 
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<">>> PROCESS_SPL_GETVTXDATA: ERROR DETECTED (23). loc("<<loc<<") >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE("<<globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE<<"). loc: "<<loc<<endl;
		#endif 
		loc = 0; }

	for(unsigned int v=0; v<MAX_NUM_UNIQ_EDGES_PER_VEC; v++){
		unsigned int instid = (loc+v) % NUM_PEs;
		unsigned int lloc = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETLOCALVID((loc+v), instid);
		unsigned int rowoffset = instid * (globalparams.SIZEKVS2_PROCESSEDGESPARTITION / NUM_PEs); // TOO EXPENSIVE.
		
		unsigned int col = lloc % 16;
		unsigned int row = lloc / 16;
		unsigned int realcol = col;
		unsigned int realrow = rowoffset + row;
		
		#ifdef _DEBUGMODE_CHECKS2
		actsutilityobj->checkoutofbounds("PROCESS_SPL3_GETVTXDATASET.realcol", realcol, VECTOR2_SIZE, realcol, loc, v);
		actsutilityobj->checkoutofbounds("PROCESS_SPL3_GETVTXDATASET.realrow", realrow, DOUBLE_BLOCKRAM_SIZE, realrow, loc, v);
		#endif
		if(row % 2 == 0){ Vdatas[v] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV2(vbuffer[realcol][realrow]).key; } 
		else { Vdatas[v] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV2(vbuffer[realcol][realrow]).value; }
		VMdatas[v] = vmaskBITS[realcol][realrow];
		
		VMdatas[v] = vmaskBITS[realcol][realrow];
		keyvalue_t KV = UTIL_GETKV2(vbuffer[realcol][realrow/2]);
		if(realrow%2==0){ Vdatas[v] = KV.key; } else { Vdatas[v] = KV.value; }
	}
	return;
}

/** void {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL2_GETVTXDATASET(unsigned int loc, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], value_t Vdatas[MAX_NUM_UNIQ_EDGES_PER_VEC], unit1_type VMdatas[MAX_NUM_UNIQ_EDGES_PER_VEC], globalparams_t globalparams){					
	for(unsigned int v=0; v<MAX_NUM_UNIQ_EDGES_PER_VEC; v++){
		// unsigned int index = 16369;
		// unsigned int index = 16352; // loc + v
		// unsigned int index = 16144;
		// unsigned int index = loc + v;
		unsigned int index = loc + v;
		if(index >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE){ index = 0; }
		
		#if NUM_PEs==3
		NOT IMPLEMENTED.
		#elif NUM_PEs==12
		NOT IMPLEMENTED.
		#elif NUM_PEs==22
		NOT IMPLEMENTED.
		#elif NUM_PEs==24
		NOT IMPLEMENTED.
		#elif NUM_PEs==25
		NOT IMPLEMENTED.
		#elif NUM_PEs==32
			unsigned int col_dim32 = index % NUM_PEs;
			unsigned int row_dim32 = index / NUM_PEs; // OPTIMIZE: follow with processedges_splitdstvxs
			unsigned int basecol_dim16 = 0;
			unsigned int col_dim16 = index % VECTOR2_SIZE;
			unsigned int row_dim16 = index / VECTOR2_SIZE;
			
			unsigned int block = index / 512;
			unsigned int baserow_dim16 = ((index / 512) * 512) / VECTOR2_SIZE;
			unsigned int localrow_16 = row_dim16 - baserow_dim16;
			localrow_16 = localrow_16 / 2; if(col_dim32 < 16){ localrow_16 = localrow_16; } else{ localrow_16 = localrow_16 + 16; }
			unsigned int truerow_dim16 = baserow_dim16 + localrow_16;
		#else
		NOT IMPLEMENTED.
		#endif
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<"PROCESS_SPL2_GETVTXDATASET[AFTER]:: index: "<<index<<", col_dim32: "<<col_dim32<<", row_dim32: "<<row_dim32<<", col_dim16: "<<col_dim16<<", baserow_dim16: "<<baserow_dim16<<", localrow_16: "<<localrow_16<<", truerow_dim16: "<<truerow_dim16<<endl;
		#endif 
		
		#ifdef _DEBUGMODE_CHECKS2
		actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET.col_dim16", col_dim16, VECTOR2_SIZE, col_dim16, index, loc);
		actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET.truerow_dim16", truerow_dim16, DOUBLE_BLOCKRAM_SIZE, truerow_dim16, index, loc);
		#endif 
		VMdatas[v] = vmaskBITS[col_dim16][truerow_dim16];
		keyvalue_t KV = UTIL_GETKV2(vbuffer[col_dim16][truerow_dim16/2]);
		if(truerow_dim16%2==0){ Vdatas[v] = KV.key; } else { Vdatas[v] = KV.value; }
		
		#ifdef _DEBUGMODE_KERNELPRINTS
		if(VMdatas[v] == 1){ cout<<"PROCESS_SPL2_GETVTXDATASET: MASK=1 FOUND: VMdatas["<<v<<"]: "<<VMdatas[v]<<", vmaskBITS["<<col_dim16<<"]["<<truerow_dim16<<"]: "<<vmaskBITS[col_dim16][truerow_dim16]<<", (loc + v): "<<loc + v<<", loc: "<<loc<<", v: "<<v<<endl; }
		#endif
	}
	return;
}
 */
/** void {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL2_GETVTXDATASET(unsigned int loc, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], value_t Vdatas[MAX_NUM_UNIQ_EDGES_PER_VEC], unit1_type VMdatas[MAX_NUM_UNIQ_EDGES_PER_VEC], globalparams_t globalparams){					
	// if(index >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE){ index = 0; }
	
	//
	int index = 0;
	
	//
	unsigned int col_dim32 = loc % NUM_PEs;
	unsigned int row_dim32 = loc / NUM_PEs; // OPTIMIZE: follow with processedges_splitdstvxs
	unsigned int basecol_dim16 = 0;
	unsigned int col_dim16 = loc % VECTOR2_SIZE;
	unsigned int row_dim16 = loc / VECTOR2_SIZE;
	
	unsigned int block = loc / 512;
	unsigned int baserow_dim16 = ((loc / 512) * 512) / VECTOR2_SIZE;
	unsigned int localrow_16 = row_dim16 - baserow_dim16;
	localrow_16 = localrow_16 / 2; if(col_dim32 < 16){ localrow_16 = localrow_16; } else{ localrow_16 = localrow_16 + 16; }
	unsigned int truerow_dim16 = baserow_dim16 + localrow_16;
			
	for(unsigned int v=col_dim16; v<VECTOR2_SIZE; v++){
		if(index < MAX_NUM_UNIQ_EDGES_PER_VEC && loc+v-col_dim16 < (globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE)){
			#ifdef _DEBUGMODE_CHECKS2
			actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET(A).col_dim16", col_dim16, VECTOR2_SIZE, col_dim16, v, loc);
			actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET(A).truerow_dim16", truerow_dim16, DOUBLE_BLOCKRAM_SIZE, truerow_dim16, v, loc);
			#endif
			VMdatas[index] = vmaskBITS[v][truerow_dim16];
			keyvalue_t KV = UTIL_GETKV2(vbuffer[v][truerow_dim16/2]);
			if(truerow_dim16%2==0){ Vdatas[index] = KV.key; } else { Vdatas[index] = KV.value; }
		}
		index += 1;
	}
	
	//
	loc = loc + (VECTOR2_SIZE - col_dim16);
	#ifdef _DEBUGMODE_CHECKS2
	if(loc % VECTOR2_SIZE != 0){ cout<<"PROCESS_SPL2_GETVTXDATASET:: loc("<<loc<<") % VECTOR2_SIZE != 0"<<endl; exit(EXIT_FAILURE); }
	#endif 
	
	//
	col_dim32 = loc % NUM_PEs;
	row_dim32 = loc / NUM_PEs; // OPTIMIZE: follow with processedges_splitdstvxs
	basecol_dim16 = 0;
	col_dim16 = loc % VECTOR2_SIZE;
	row_dim16 = loc / VECTOR2_SIZE;
	
	block = loc / 512;
	baserow_dim16 = ((loc / 512) * 512) / VECTOR2_SIZE;
	localrow_16 = row_dim16 - baserow_dim16;
	localrow_16 = localrow_16 / 2; if(col_dim32 < 16){ localrow_16 = localrow_16; } else{ localrow_16 = localrow_16 + 16; }
	truerow_dim16 = baserow_dim16 + localrow_16;
	
	for(unsigned int v=0; v<VECTOR2_SIZE; v++){
		if(index < MAX_NUM_UNIQ_EDGES_PER_VEC && loc+v < (globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE)){
			#ifdef _DEBUGMODE_CHECKS2
			actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET(B).col_dim16", col_dim16, VECTOR2_SIZE, col_dim16, v, loc+v);
			actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET(B).truerow_dim16", truerow_dim16, DOUBLE_BLOCKRAM_SIZE, truerow_dim16, v, loc+v);
			#endif
			VMdatas[index] = vmaskBITS[v][truerow_dim16];
			keyvalue_t KV = UTIL_GETKV2(vbuffer[v][truerow_dim16/2]);
			if(truerow_dim16%2==0){ Vdatas[index] = KV.key; } else { Vdatas[index] = KV.value; }
		}
		index += 1;
	}
	
	// for(unsigned int v=0; v<MAX_NUM_UNIQ_EDGES_PER_VEC; v++){
		// VMdatas[v] = vmaskBITS[col_dim16][truerow_dim16];
		// keyvalue_t KV = UTIL_GETKV2(vbuffer[col_dim16][truerow_dim16/2]);
		// if(truerow_dim16%2==0){ Vdatas[v] = KV.key; } else { Vdatas[v] = KV.value; }
	// }
	return;
} */
unsigned int {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL2_GETROW(unsigned int loc){					
	unsigned int col_dim32 = loc % NUM_PEs;
	unsigned int row_dim32 = loc / NUM_PEs; // OPTIMIZE: follow with processedges_splitdstvxs
	unsigned int basecol_dim16 = 0;
	unsigned int col_dim16 = loc % VECTOR2_SIZE;
	unsigned int row_dim16 = loc / VECTOR2_SIZE;
	
	unsigned int block = loc / 512;
	unsigned int baserow_dim16 = ((loc / 512) * 512) / VECTOR2_SIZE;
	unsigned int localrow_16 = row_dim16 - baserow_dim16;
	localrow_16 = localrow_16 / 2; if(col_dim32 < 16){ localrow_16 = localrow_16; } else{ localrow_16 = localrow_16 + 16; }
	unsigned int truerow_dim16 = baserow_dim16 + localrow_16;
	
	return truerow_dim16;
}
void {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL2_GETSET(keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], unit1_type VMdatas_tmp[32], value_t Vdatas_tmp[32], unsigned int row, globalparams_t globalparams){					
	for(unsigned int v=0; v<VECTOR2_SIZE; v++){
		if(row < (globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE)){
			#ifdef _DEBUGMODE_CHECKS2
			actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET(A).row", row, DOUBLE_BLOCKRAM_SIZE, row, v, NAp);
			#endif
			VMdatas_tmp[v] = vmaskBITS[v][row];
			keyvalue_t KV = UTIL_GETKV2(vbuffer[v][row/2]);
			if(row%2==0){ Vdatas_tmp[v] = KV.key; } else { Vdatas_tmp[v] = KV.value; }
		}
	}
	return;
}
void {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL2_GETVTXDATASET(unsigned int loc, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], value_t Vdatas[MAX_NUM_UNIQ_EDGES_PER_VEC], unit1_type VMdatas[MAX_NUM_UNIQ_EDGES_PER_VEC], globalparams_t globalparams){					
	// if(index >= globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE){ index = 0; }
	
	//
	unit1_type VMdatas_tmp[32];
	#pragma HLS ARRAY_PARTITION variable=VMdatas_tmp complete
	value_t Vdatas_tmp[32];
	#pragma HLS ARRAY_PARTITION variable=Vdatas_tmp complete
	
	//
	unsigned int fcol_dim16 = loc % VECTOR2_SIZE;
	unsigned int col_dim16 = loc % VECTOR2_SIZE;
	unsigned int row_dim16 = loc / VECTOR2_SIZE;
	
	/* //
	unsigned int col_dim32 = loc % NUM_PEs;
	unsigned int row_dim32 = loc / NUM_PEs; // OPTIMIZE: follow with processedges_splitdstvxs
	unsigned int basecol_dim16 = 0;
	unsigned int col_dim16 = loc % VECTOR2_SIZE;
	unsigned int row_dim16 = loc / VECTOR2_SIZE;
	
	unsigned int block = loc / 512;
	unsigned int baserow_dim16 = ((loc / 512) * 512) / VECTOR2_SIZE;
	unsigned int localrow_16 = row_dim16 - baserow_dim16;
	localrow_16 = localrow_16 / 2; if(col_dim32 < 16){ localrow_16 = localrow_16; } else{ localrow_16 = localrow_16 + 16; }
	unsigned int truerow1_dim16 = baserow_dim16 + localrow_16;
	
	for(unsigned int v=0; v<VECTOR2_SIZE; v++){
		if(loc+v-col_dim16 < (globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE)){
			#ifdef _DEBUGMODE_CHECKS2
			actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET(A).col_dim16", col_dim16, VECTOR2_SIZE, col_dim16, v, loc);
			actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET(A).truerow1_dim16", truerow1_dim16, DOUBLE_BLOCKRAM_SIZE, truerow1_dim16, v, loc);
			#endif
			VMdatas_tmp[v] = vmaskBITS[v][truerow1_dim16];
			keyvalue_t KV = UTIL_GETKV2(vbuffer[v][truerow1_dim16/2]);
			if(truerow1_dim16%2==0){ Vdatas_tmp[v] = KV.key; } else { Vdatas_tmp[v] = KV.value; }
		}
	}
	// */
	
	unsigned int truerow1_dim16 = PROCESS_SPL2_GETROW(loc);
	PROCESS_SPL2_GETSET(vbuffer, vmaskBITS, VMdatas_tmp, Vdatas_tmp, truerow1_dim16);
	
	//
	loc = loc + (VECTOR2_SIZE - col_dim16);
	#ifdef _DEBUGMODE_CHECKS2
	if(loc % VECTOR2_SIZE != 0){ cout<<"PROCESS_SPL2_GETVTXDATASET:: loc("<<loc<<") % VECTOR2_SIZE != 0"<<endl; exit(EXIT_FAILURE); }
	#endif 
	
	//
	unsigned int col_dim32 = loc % NUM_PEs;
	unsigned int row_dim32 = loc / NUM_PEs; // OPTIMIZE: follow with processedges_splitdstvxs
	unsigned int basecol_dim16 = 0;
	col_dim16 = loc % VECTOR2_SIZE;
	row_dim16 = loc / VECTOR2_SIZE;
	
	unsigned int block = loc / 512;
	unsigned int baserow_dim16 = ((loc / 512) * 512) / VECTOR2_SIZE;
	unsigned int localrow_16 = row_dim16 - baserow_dim16;
	localrow_16 = localrow_16 / 2; if(col_dim32 < 16){ localrow_16 = localrow_16; } else{ localrow_16 = localrow_16 + 16; }
	unsigned int truerow2_dim16 = baserow_dim16 + localrow_16;
	
	// unsigned int truerow2_dim16 = PROCESS_SPL2_GETROW((loc + (VECTOR2_SIZE - col_dim16)));
	
	for(unsigned int v=0; v<VECTOR2_SIZE; v++){
		if(loc+v < (globalparams.SIZEKVS2_REDUCEPARTITION * VDATA_PACKINGSIZE)){
			#ifdef _DEBUGMODE_CHECKS2
			actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET(B).col_dim16", col_dim16, VECTOR2_SIZE, col_dim16, v, loc+v);
			actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET(B).truerow2_dim16", truerow2_dim16, DOUBLE_BLOCKRAM_SIZE, truerow2_dim16, v, loc+v);
			#endif
			VMdatas_tmp[VECTOR2_SIZE + v] = vmaskBITS[v][truerow2_dim16];
			keyvalue_t KV = UTIL_GETKV2(vbuffer[v][truerow2_dim16/2]);
			if(truerow2_dim16%2==0){ Vdatas_tmp[VECTOR2_SIZE + v] = KV.key; } else { Vdatas_tmp[VECTOR2_SIZE + v] = KV.value; }
		}
	}
	
	unsigned int index = 0;
	for(unsigned int v=fcol_dim16; v<fcol_dim16 + MAX_NUM_UNIQ_EDGES_PER_VEC; v++){
		#ifdef _DEBUGMODE_CHECKS2
		actsutilityobj->checkoutofbounds("PROCESS_SPL2_GETVTXDATASET(C).fcol_dim16", index, 32, v, NAp, NAp);
		#endif
		VMdatas[index] = VMdatas_tmp[v];
		Vdatas[index] = Vdatas_tmp[v];
		index += 1;
	}
	return;
}

fetchmessage_t {{context['classname__processedges_splitdstvxs']}}PROCESS_SPL_readandprocess(bool_type enable, uint512_dt * edges, uint512_dt * kvdram, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], unit1_type vmask_subp[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], keyvalue_buffer_t buffer[VECTOR_SIZE][SOURCEBLOCKRAM_SIZE], 
		batch_type goffset_kvs, batch_type loffset_kvs, batch_type size_kvs, travstate_t travstate, sweepparams_t sweepparams, globalparams_t globalparams){
	fetchmessage_t fetchmessage;
	fetchmessage.chunksize_kvs = -1;
	fetchmessage.nextoffset_kvs = -1;
	if(enable == OFF){ return fetchmessage; }
	
	analysis_type analysis_loop = BLOCKRAM_SIZE / 2;

	uint32_type E[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=E complete
	bool_type en = ON;
	bool_type ens[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=ens complete
	unsigned int udata[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=udata complete
	unit1_type mask[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=mask complete
	
	buffer_type reducebuffersz = globalparams.SIZE_REDUCE / 2;
	unsigned int validbound = reducebuffersz * FETFACTOR * VECTOR2_SIZE;
	
	travstate.i_kvs = travstate.i_kvs / 2;
	travstate.end_kvs = travstate.end_kvs / 2;
	loffset_kvs = loffset_kvs / 2;
	buffer_type edgessize_kvs = size_kvs / 2;
	
	batch_type offset_kvs = goffset_kvs + loffset_kvs;
	
	value_t udataset[MAX_NUM_UNIQ_EDGES_PER_VEC];
	#pragma HLS ARRAY_PARTITION variable=udataset complete
	value_t maskset[MAX_NUM_UNIQ_EDGES_PER_VEC];
	#pragma HLS ARRAY_PARTITION variable=maskset complete
	vertex_t lvids[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=lvids complete
	keyvalue_t mykeyvalue[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=mykeyvalue complete
	
	unit4_type incr[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=incr complete
	unsigned int lsrcvids[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=lsrcvids complete
	unsigned int ldstvids[VECTOR2_SIZE];	
	#pragma HLS ARRAY_PARTITION variable=ldstvids complete
	value_t res[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=res complete
	
	value_t Vsets[2][VECTOR2_SIZE]; // DEPRECIATED.
	#pragma HLS ARRAY_PARTITION variable=Vset complete
	unit1_type VMsets[2][VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=VMset complete
	
	value_t Vset[MAX_NUM_UNIQ_EDGES_PER_VEC];
	#pragma HLS ARRAY_PARTITION variable=Vset complete
	unit1_type VMset[MAX_NUM_UNIQ_EDGES_PER_VEC];
	#pragma HLS ARRAY_PARTITION variable=VMset complete
	
	sliceinfos_t sliceinfos;
	
	vertex_t srcvid_head;
	vertex_t lvid_head;
	
	batch_type vptrbaseoffset_kvs = globalparams.BASEOFFSETKVS_VERTEXPTR + (globalparams.ACTSPARAMS_SRCVOFFSET / VECTOR_SIZE);
	batch_type voffset_kvs = sweepparams.source_partition * reducebuffersz * FETFACTOR;
	keyy_t nextbeginvptr;
	keyy_t nextbeginvptr_kvs;
	
	fetchmessage.chunksize_kvs = edgessize_kvs;
	fetchmessage.nextoffset_kvs = -1;
	buffer_type loadcount = 0;
	buffer_type activeloadcount = 0;
	buffer_type inactiveloadcount = 0;
	
	unsigned int debug_numinvalidheads = 0;
	unsigned int GraphAlgo = globalparams.ALGORITHMINFO_GRAPHALGORITHMID;

	unsigned int num_passes = 1;
	buffer_type chunk_size = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_getchunksize_kvs(edgessize_kvs, travstate, 0);
	READANDPROCESS_SPL_LOOP3A:  for(buffer_type part=0; part<1; part++){
		READANDPROCESS_SPL_LOOP3B:  for(buffer_type m=0; m<num_passes; m++){
			loadcount = 0;
			debug_numinvalidheads = 0;
			READANDPROCESS_SPL_LOOP3C: for (buffer_type i=0; i<chunk_size; i++){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loop avg=analysis_loop	
			#pragma HLS PIPELINE II=1
				#ifdef _DEBUGMODE_KERNELPRINTS
				cout<<"--- PROCESS_SPL_readandprocess: m: "<<m<<", i: "<<i<<" (of "<<chunk_size<<")"<<endl;
				#endif

				#ifdef _WIDEWORD
				{%for v in context['MQ_seq']%}
				E[{{v}}] = edges[offset_kvs + i].range({{((v + 1) * 32) - 1}}, {{v * 32}}); 
				{%endfor%}
				#else 
				{%for v in context['VECTOR_SIZE_seq']%}
				E[{{2*v}}] = edges[offset_kvs + i].data[{{v}}].key; 
				E[{{2*v+1}}] = edges[offset_kvs + i].data[{{v}}].value;
				{%endfor%}
				#endif
				#ifdef _DEBUGMODE_CHECKS3
				PROCESS_SPL_debug(0, i, E, ens, mask, udataset, maskset, Vsets, VMsets, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
				#endif 
					
				srcvid_head = E[0];
				lvid_head = srcvid_head - travstate.i2;	
				{%for v in context['MQ_seq']%}
				parsededge_t parsed_edge{{v}} = PARSE_EDGE(E[{{v}}]);
				incr[{{v}}] = parsed_edge{{v}}.incr;
				lsrcvids[{{v}}] = lvid_head + incr[{{v}}];
				ldstvids[{{v}}] = parsed_edge{{v}}.dstvid;	
				{%endfor%}
				
				bool_type en = ON;
				#ifdef _DEBUGMODE_CHECKS3
				PROCESS_SPL_debug(1, i, E, ens, mask, udataset, maskset, Vsets, VMsets, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
				#endif
				
				#ifdef CONFIG_READVDATA_SLIDE
					#ifdef CONFIG_READVDATA_SLIDEANDREARRANGE
					PROCESS_SPL2_GETVTXDATASET(lvid_head, vbuffer, vmaskBITS, Vset, VMset, globalparams);
					#else 
					NOT IMPLEMENTED.
					#endif 
				#else 
					PROCESS_SPL1_GETVTXDATASET(lvid_head, vbuffer, vmaskBITS, Vset, VMset, globalparams);
				#endif 
				#ifdef _DEBUGMODE_CHECKS3
				PROCESS_SPL_debug(2, i, E, ens, mask, udataset, maskset, Vsets, VMsets, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
				#endif 
				
				{%for v in context['MQ_seq']%}
				ens[{{v}}] = ON; if(E[{{v}}] == INVALIDDATA || lsrcvids[{{v}}] >= validbound){ ens[{{v}}] = OFF; }
				{%endfor%}
				#ifdef _DEBUGMODE_CHECKS3
				PROCESS_SPL_debug(3, i, E, ens, mask, udataset, maskset, Vsets, VMsets, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
				#endif 
				
				{%for v in context['MQ_seq']%} mask[{{v}}] = 0; {%endfor%}
				if(GraphAlgo == PAGERANK){ {%for v in context['MQ_seq']%} mask[{{v}}] = 1; {%endfor%} } 
				else {
					{%for v in context['MQ_seq']%}
					udata[{{v}}] = Vset[incr[{{v}}]]; 
					mask[{{v}}] = VMset[incr[{{v}}]];
					{%endfor%}
				}
				mask[0] = 0; 
				ens[0] = OFF;
				#ifdef _DEBUGMODE_CHECKS3
				PROCESS_SPL_debug(4, i, E, ens, mask, udataset, maskset, Vsets, VMsets, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
				#endif
				
				{%for v in context['MQ_seq']%}
				res[{{v}}] = PROCESS_SPL_processfunc(udata[{{v}}], 1, globalparams.ALGORITHMINFO_GRAPHALGORITHMID); 
				{%endfor%}
				{%for v in context['MQ_seq']%}
				if(ens[{{v}}] == ON && mask[{{v}}] == 1){ mykeyvalue[{{v}}].key = ldstvids[{{v}}]; mykeyvalue[{{v}}].value = res[{{v}}]; } else { mykeyvalue[{{v}}].key = INVALIDDATA; mykeyvalue[{{v}}].value = INVALIDDATA;  }
				{%endfor%}
				mykeyvalue[0].key = INVALIDDATA;
				mykeyvalue[0].value = INVALIDDATA;
				#ifdef _DEBUGMODE_CHECKS3
				PROCESS_SPL_debug(5, i, E, ens, mask, udataset, maskset, Vsets, VMsets, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
				#endif 
		
				{%for v in context['VECTOR_SIZE_seq']%}
				buffer[{{v}}][loadcount] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV(mykeyvalue[{{v}}]);
				{%endfor%}	
				{%for v in context['VECTOR_SIZE_seq']%}
				buffer[{{v}}][loadcount + 1] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV(mykeyvalue[{{8+v}}]);
				{%endfor%}	
				if(ens[1] == ON && mask[1] == 1){ loadcount += 2; }
				#ifdef _DEBUGMODE_CHECKS3
				PROCESS_SPL_debug(6, i, E, ens, mask, udataset, maskset, Vsets, VMsets, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
				#endif 
			}
		}
	}
	// cout<<">>> readandprocess: loadcount: "<<loadcount<<", activeloadcount: "<<activeloadcount<<", inactiveloadcount: "<<inactiveloadcount<<endl;
	// exit(EXIT_SUCCESS); ///
	fetchmessage.chunksize_kvs = loadcount;
	return fetchmessage;
}


