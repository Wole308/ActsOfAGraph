// => VDATA (to read)
// 16:[0,32,...,480] | [1,33,...,481] | ... | [31,63,...,511]

// => VMASK (to read)
// 32:[0,32,...,480,...,992] | [1,33,...,481,...,993] | ... | [31,63,...,511,...,1023]

// int programglobalvar_numvtxsprocessed = 0; // program global variables

#define VSETSZ 32
#define VMSETSZ 32
#define PE_SETSZ {{context['PE_SETSZ']}}

//
value_t {{context['classname__processedges_splitdstvxs']}}PROCESS{{context['id']}}_SPL_processfunc(value_t udata, value_t edgew, unsigned int GraphAlgo){
	value_t res = 0;
	#ifdef CUSTOMLOGICFOREACHALGORITHM
		#if defined(PR_ALGORITHM)
			res = udata + edgew;
		#elif defined(CF_ALGORITHM)
			// source: https://mrmgroup.cs.princeton.edu/papers/taejun_micro16.pdf (Graphicionado)
			// process edge & reduce combined here (source: graphicionado paper)
			/* --- Collaborative Filtering ---:
			Process Edges: Executed in Reduce. ({Ew, Uprop} from source is sent to destination vertex)
			Reduce: Function of (uprop, Ew, Vprop) is executed 
			Apply: Function of (Vprop, Vtemp) is executed 
			Finish: */
			res = udata;
		#elif defined(CC_ALGORITHM)
			// source: https://www.baeldung.com/cs/graph-connected-components
			// source: https://cs.usm.maine.edu/~briggs/webPage/c161/projects/graphColoring.htmls
			// source: https://www.usenix.org/system/files/conference/osdi12/osdi12-final-126.pdf (GraphChi)
			/* --- Connected Components ---:
			Process Edges: Each vertex writes its id ("label") to its edges. 
			Reduce: Vertex chooses the minimum label of its neighbors; 
			Apply: A neighbor is scheduled only if a label in a connecting edge changes, which we implement by using selective scheduling. 
			Finish: sets of vertices with equal labels are interpreted as connected components or communities, respectively. */
			res = udata;
		#elif defined(BFS_ALGORITHM)
			res = NAp;
		#elif defined(SSSP_ALGORITHM)
			res = udata + edgew;
		#else
			NOT DEFINED.
		#endif
	#else 
	if(GraphAlgo == PAGERANK){
		res = udata + edgew;
	} else if(GraphAlgo == CF){
		res = udata;
	} else if(GraphAlgo == CC){
		res = udata;
	} else if(GraphAlgo == BFS){
		res = NAp;
	} else if(GraphAlgo == SSSP){
		res = udata + edgew;
	} else {
		res = NAp;
	}
	#endif
	return res;
}

parsededge_t {{context['classname__processedges_splitdstvxs']}}PROCESS{{context['id']}}_PARSEEDGE(uint32_type data){ 
	parsededge_t parsededge;
	#ifdef _WIDEWORD
	parsededge.incr = data.range(31, 28);
	parsededge.dstvid = data.range(28, 0);
	#else
	parsededge.incr = UTIL{{context['id']}}_READFROM_UINT(data, 28, 4);
	parsededge.dstvid = UTIL{{context['id']}}_READFROM_UINT(data, 0, 28);
	#endif
	return parsededge; 
}

void {{context['classname__processedges_splitdstvxs']}}PROCESS{{context['id']}}_SPL_debug(unsigned int debugid,
	unsigned int i, value_t E[VECTOR2_SIZE], bool_type ens[VECTOR2_SIZE], unsigned int mask[VECTOR2_SIZE],
		value_t udataset[MAX_NUM_UNIQ_EDGES_PER_VEC], value_t maskset[VECTOR2_SIZE], value_t Vset[MAX_NUM_UNIQ_EDGES_PER_VEC], unit1_type VMset[MAX_NUM_UNIQ_EDGES_PER_VEC], vertex_t lvids[VECTOR2_SIZE],
			unsigned int incr[VECTOR2_SIZE], unsigned int lsrcvids[VECTOR2_SIZE], unsigned int ldstvids[VECTOR2_SIZE], value_t res[VECTOR2_SIZE], keyvalue_t mykeyvalue[VECTOR2_SIZE], sweepparams_t sweepparams, globalparams_t globalparams,
				unsigned int lvid_head, unsigned int srcvid_head, travstate_t travstate, unsigned int chunk_size, sliceinfos_t sliceinfos, unsigned int * activeloadcount, unsigned int * inactiveloadcount, unsigned int * debug_numinvalidheads
				){
	buffer_type reducebuffersz = globalparams.SIZE_REDUCE / 2;
	unsigned int validbound = reducebuffersz * FETFACTOR * VECTOR2_SIZE;
	
	if(debugid == 0){
		#ifdef _DEBUGMODE_KERNELPRINTS
		{%for v in context['VECTOR2_SIZE_seq']%}
		cout<<"readandprocess(1-2)::DEBUG CODE 0:: E[{{v}}]: "<<E[{{v}}]<<endl;
		{%endfor%}
		#endif
	}
	
	if(debugid == 1){
		#ifdef _DEBUGMODE_CHECKS
		if(srcvid_head < travstate.i2){ cout<<"readandprocess(12)::DEBUG CODE 1:: INVALID srcvid_head. this is an error. i: "<<i<<"(of "<<chunk_size<<"), srcvid_head: "<<srcvid_head<<", travstate.i2: "<<travstate.i2<<" offset_kvs: "<<offset_kvs<<". exiting..."<<endl;					 
			for(unsigned int v=0; v<VECTOR_SIZE; v++){ cout<<"readandprocess(12): E["<<v<<"]: "<<E[v]<<endl; }
			exit(EXIT_FAILURE); }
		if(lvid_head >= (reducebuffersz*FETFACTOR*VECTOR2_SIZE)){ cout<<"readandprocess(12)::DEBUG CODE 1:: INVALID srcvid_head. this is an error. i: "<<i<<"(of "<<chunk_size<<"), lvid_head: "<<lvid_head<<", reducebuffersz*FETFACTOR*VECTOR2_SIZE: "<<reducebuffersz*FETFACTOR*VECTOR2_SIZE<<". exiting..."<<endl;					 
			for(unsigned int v=0; v<VECTOR_SIZE; v++){ cout<<"readandprocess(12)::DEBUG CODE 1:: E["<<v<<"]: "<<E[v]<<endl; }
			exit(EXIT_FAILURE); }
		actsutilityobj->checkoutofbounds("readandprocess(12)::DEBUG CODE 1::1", lvid_head, reducebuffersz * FETFACTOR * VECTOR2_SIZE, srcvid_head, travstate.i2, i);
		#endif
	}
	
	if(debugid == 2){
		#ifdef _DEBUGMODE_KERNELPRINTS
		{%for r in context['8_seq']%}
		cout<<"readandprocess(2)::DEBUG CODE 2:: lvid_head: "<<lvid_head<<", lvid: "<<lvid_head + {{r}}<<", udataset[{{r}}]: "<<udataset[{{r}}]<<", maskset[{{r}}]: "<<maskset[{{r}}]<<endl;
		{%endfor%}
		#endif
		#ifdef _DEBUGMODE_CHECKS
		{%for r in context['8_seq']%}
		if(maskset[{{r}}] > 2){ cout<<"ERROR @ readandprocess(13)::DEBUG CODE 2::.maskset[{{r}}].1. maskset[{{r}}]: "<<maskset[{{r}}]<<endl; for(unsigned int n=0; n<8; n++){ cout<<">>> readandprocess.mask: maskset["<<n<<"]: "<<maskset[n]<<", lvid + {{r}}: "<<lvid + {{r}}<<endl; } exit(EXIT_FAILURE); }
		{%endfor%}
		#endif
	}
	
	if(debugid == 3){
		#ifdef _DEBUGMODE_KERNELPRINTS
		{%for v in context['PE_SETSZ_seq']%}
		cout<<"readandprocess(3)::DEBUG CODE 3:: E[{{v}}]: "<<E[{{v}}]<<", lvid_head: "<<lvid_head<<", incr[{{v}}]: "<<incr[{{v}}]<<", lsrcvids[{{v}}]: "<<lsrcvids[{{v}}]<<", ens[{{v}}]: "<<ens[{{v}}]<<endl;
		{%endfor%}
		#endif
		#ifdef _DEBUGMODE_CHECKS2
		{%for v in context['PE_SETSZ_seq']%}
		if(ens[{{v}}] == ON && incr[{{v}}] >= MAX_NUM_UNIQ_EDGES_PER_VEC){ 
			cout<<"readandprocess(12)::DEBUG CODE 3:: incr[{{v}}]("<<incr[{{v}}]<<") > MAX_NUM_UNIQ_EDGES_PER_VEC("<<MAX_NUM_UNIQ_EDGES_PER_VEC<<"). lsrcvids[{{v}}]: "<<lsrcvids[{{v}}]<<", ldstvids[{{v}}]: "<<ldstvids[{{v}}]<<endl;
			{%for n in context['PE_SETSZ_seq']%} cout<<">>> readandprocess(12)::DEBUG CODE 3::mask: E[{{n}}]: "<<E[{{n}}]<<", lvid_head: "<<lvid_head<<", lsrcvids[{{n}}]: "<<lsrcvids[{{n}}]<<", ldstvids[{{n}}]: "<<ldstvids[{{n}}]<<", incr[{{n}}]: "<<incr[{{n}}]<<endl; {%endfor%} 
			for(unsigned int r=0; r<MAX_NUM_UNIQ_EDGES_PER_VEC; r++){ cout<<">>> readandprocess(12)::DEBUG CODE 3::mask: udataset["<<r<<"]: "<<udataset[r]<<", maskset["<<r<<"]: "<<maskset[r]<<endl; }
			exit(EXIT_FAILURE); 
		}
		{%endfor%}
		#endif
		#ifdef _DEBUGMODE_CHECKS2
		{%for v in context['PE_SETSZ_seq']%}
		if(lsrcvids[{{v}}] >= validbound){
			if(*debug_numinvalidheads > 32){
			{%for n in context['PE_SETSZ_seq']%} cout<<">>> readandprocess(17)::DEBUG CODE 3:: mask: E[{{n}}]: "<<E[{{n}}]<<", lvid_head: "<<lvid_head<<", lsrcvids[{{n}}]: "<<lsrcvids[{{n}}]<<", ldstvids[{{n}}]: "<<ldstvids[{{n}}]<<", incr[{{n}}]: "<<incr[{{n}}]<<endl; {%endfor%} 
			cout<<"readandprocess::::DEBUG CODE 3::ERROR(17): "<<*debug_numinvalidheads<<" srcv heads found (4 was limit set). i: "<<i<<" (of "<<chunk_size<<"), v: {{v}}, validbound: "<<validbound<<", *debug_numinvalidheads: "<<*debug_numinvalidheads<<". EXITING..."<<endl; exit(EXIT_FAILURE); } 
			else {
			// cout<<"readandprocess:: i: "<<i<<" (of "<<chunk_size<<"), v: {{v}}, validbound: "<<validbound<<", *debug_numinvalidheads: "<<*debug_numinvalidheads<<endl;
			*debug_numinvalidheads += 1; }}
		{%endfor%}
		#endif 
	}
	
	if(debugid == 4){
		#ifdef _DEBUGMODE_CHECKS2	
		// {%for n in context['VECTOR2_SIZE_seq']%} cout<<">>> readandprocess(14)::DEBUG CODE 4:: mask: E[{{n}}]: "<<E[{{n}}]<<", lvid_head: "<<lvid_head<<", lsrcvids[{{n}}]: "<<lsrcvids[{{n}}]<<", ldstvids[{{n}}]: "<<ldstvids[{{n}}]<<", incr[{{n}}]: "<<incr[{{n}}]<<", mask[{{n}}]: "<<mask[{{n}}]<<endl; {%endfor%} 
		// for(unsigned int r=0; r<MAX_NUM_UNIQ_EDGES_PER_VEC; r++){ cout<<">>> readandprocess(14)::DEBUG CODE 4:: mask: udataset["<<r<<"]: "<<udataset[r]<<", maskset["<<r<<"]: "<<maskset[r]<<endl; }
		// cout<<"SUCCESS? @ readandprocess(14)::DEBUG CODE 4::. sliceinfos.slice[0].beginoffset: "<<sliceinfos.slice[0].beginoffset<<", sliceinfos.slice[0].endoffset: "<<sliceinfos.slice[0].endoffset<<endl;
		// cout<<"SUCCESS? @ readandprocess(14)::DEBUG CODE 4::. sliceinfos.slice[1].beginoffset: "<<sliceinfos.slice[1].beginoffset<<", sliceinfos.slice[1].endoffset: "<<sliceinfos.slice[1].endoffset<<endl;
		
		// for(unsigned int v=0; v<VSETSZ; v++){ cout<<"readandprocess(14)::DEBUG CODE 4:: Vset["<<v<<"]: "<<Vset[v]<<", VMset["<<v<<"]: "<<VMset[v]<<endl; }
			
		
		{%for v in context['PE_SETSZ_seq']%}
		if(ens[{{v}}] == ON && mask[{{v}}] > 2){ 
			cout<<"ERROR @ readandprocess(14)::DEBUG CODE 4::mask[{{v}}].2. i: "<<i<<", mask[{{v}}]: "<<mask[{{v}}]<<", incr[{{v}}]: "<<incr[{{v}}]<<endl;
			{%for n in context['VECTOR2_SIZE_seq']%} cout<<">>> readandprocess(14)::DEBUG CODE 4:: mask: E[{{n}}]: "<<E[{{n}}]<<", lvid_head: "<<lvid_head<<", lsrcvids[{{n}}]: "<<lsrcvids[{{n}}]<<", ldstvids[{{n}}]: "<<ldstvids[{{n}}]<<", incr[{{n}}]: "<<incr[{{n}}]<<", mask[{{n}}]: "<<mask[{{n}}]<<endl; {%endfor%} 
			for(unsigned int r=0; r<MAX_NUM_UNIQ_EDGES_PER_VEC; r++){ cout<<">>> readandprocess(14)::DEBUG CODE 4:: mask: udataset["<<r<<"]: "<<udataset[r]<<", maskset["<<r<<"]: "<<maskset[r]<<endl; }
			cout<<"ERROR @ readandprocess(14)::DEBUG CODE 4::. sliceinfos.slice[0].beginoffset: "<<sliceinfos.slice[0].beginoffset<<", sliceinfos.slice[0].endoffset: "<<sliceinfos.slice[0].endoffset<<endl;
			cout<<"ERROR @ readandprocess(14)::DEBUG CODE 4::. sliceinfos.slice[1].beginoffset: "<<sliceinfos.slice[1].beginoffset<<", sliceinfos.slice[1].endoffset: "<<sliceinfos.slice[1].endoffset<<endl;
			for(unsigned int v=0; v<VSETSZ; v++){ cout<<"readandprocess(14)::DEBUG CODE 4:: Vset["<<v<<"]: "<<Vset[v]<<", VMset["<<v<<"]: "<<VMset[v]<<endl; }
			exit(EXIT_FAILURE); 
		}
		{%endfor%}
		#endif
	}
	
	if(debugid == 5){
		#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
		{%for v in context['PE_SETSZ_seq']%}
		if(ens[{{v}}] == ON && mask[{{v}}] == 1){ cout<<"PROCESS{{context['id']}}_SPL_readandprocess::PROCESS EDGE SEEN:: [i: "<<i<<", lsrcvids[{{v}}]: "<<lsrcvids[{{v}}]<<", ldstvids[{{v}}]: "<<ldstvids[{{v}}]<<", udata: "<<udataset[incr[{{v}}]]<<"], [ens[{{v}}]: "<<ens[{{v}}]<<", mask[{{v}}]: "<<mask[{{v}}]<<"]. sweepparams.source_partition: "<<sweepparams.source_partition<<endl; }			
		{%endfor%}	
		// for(unsigned int v=0; v<MAX_NUM_UNIQ_EDGES_PER_VEC; v++){ cout<<"readandprocess(15)::DEBUG CODE 5:: Vset["<<v<<"]: "<<Vset[v]<<", VMset["<<v<<"]: "<<VMset[v]<<endl; }
		#endif
	}
	
	if(debugid == 6){
		#ifdef _DEBUGMODE_CHECKS3
		{%for v in context['PE_SETSZ_seq']%}
		if(mykeyvalue[{{v}}].key == INVALIDDATA || mykeyvalue[{{v}}].value == INVALIDDATA){ *inactiveloadcount += 1; } else { *activeloadcount += 1; } 
		{%endfor%}
		#endif 
	}

	if(debugid == 7){
		#ifdef _DEBUGMODE_STATS
		{%for v in context['PE_SETSZ_seq']%}
		actsutilityobj->globalstats_countkvsprocessed(1);
		if(ens[{{v}}] == ON && mask[{{v}}] == 1){ actsutilityobj->globalstats_processedges_countvalidkvsprocessed(1); } // mask0? FIXME.
		{%endfor%}
		#endif 
	}
	return;
}

unsigned int {{context['classname__processedges_splitdstvxs']}}PROCESS{{context['id']}}_SPL3_GETROW(unsigned int loc){					
	unsigned int col_dim32 = loc % 32; // NUM_PEs;
	unsigned int row_dim32 = loc / 32; // NUM_PEs; // OPTIMIZE: follow with processedges_splitdstvxs
	unsigned int basecol_dim16 = 0;
	unsigned int col_dim16 = loc % VECTOR2_SIZE;
	unsigned int row_dim16 = loc / VECTOR2_SIZE;
	
	unsigned int block = loc / 512;
	unsigned int baserow_dim16 = ((loc / 512) * 512) / VECTOR2_SIZE;
	unsigned int localrow_16 = row_dim16 - baserow_dim16;
	localrow_16 = localrow_16 / 2; if(col_dim32 < 16){ localrow_16 = localrow_16; } else{ localrow_16 = localrow_16 + 16; }
	unsigned int truerow_dim16 = baserow_dim16 + localrow_16;
	
	return truerow_dim16;
}

unsigned int {{context['classname__processedges_splitdstvxs']}}PROCESS{{context['id']}}_SPL3_GETVTXDATASET(unsigned int loc, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], unit1_type vmaskBITS[VMASK_PACKINGSIZE][BLOCKRAM_VMASK_SIZE], value_t Vdatas[VSETSZ], unit1_type VMdatas[VMSETSZ], globalparams_t globalparams){					
	unit1_type VMdatas_tmp[32];
	unit1_type VMdatas_tmpA[VECTOR2_SIZE];
	unit1_type VMdatas_tmpB[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=VMdatas_tmp complete
	#pragma HLS ARRAY_PARTITION variable=VMdatas_tmpA complete
	#pragma HLS ARRAY_PARTITION variable=VMdatas_tmpB complete
	value_t Vdatas_tmp[32];
	value_t Vdatas_tmpA[VECTOR2_SIZE];
	value_t Vdatas_tmpB[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=Vdatas_tmp complete
	#pragma HLS ARRAY_PARTITION variable=Vdatas_tmpA complete
	#pragma HLS ARRAY_PARTITION variable=Vdatas_tmpB complete
	
	unsigned int fcol_dim16 = loc % VECTOR2_SIZE;
	unsigned int col_dim16 = loc % VECTOR2_SIZE;
	
	unsigned int truerow1_dim16 = PROCESS{{context['id']}}_SPL3_GETROW(loc);
	unsigned int truerow2_dim16 = PROCESS{{context['id']}}_SPL3_GETROW((loc + (VECTOR2_SIZE - col_dim16)));

	// CRITICAL REMOVEME.
	#ifdef CONFIG_SEPERATEVMASKFROMVDATA
	if(truerow1_dim16 < globalparams.SIZEKVS2_REDUCEPARTITION){ {%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA{{context['id']}}_READFROMBUFFER_VDATAS(truerow1_dim16, vbuffer, Vdatas_tmpA, 0); }
	if(truerow2_dim16 < globalparams.SIZEKVS2_REDUCEPARTITION){ {%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA{{context['id']}}_READFROMBUFFER_VDATAS(truerow2_dim16, vbuffer, Vdatas_tmpB, 0); }
	if(truerow1_dim16 < globalparams.SIZEKVS2_REDUCEPARTITION){ {%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA{{context['id']}}_READFROMBUFFER_VMASKS(truerow1_dim16, vmaskBITS, VMdatas_tmpA, 0); }
	if(truerow2_dim16 < globalparams.SIZEKVS2_REDUCEPARTITION){ {%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA{{context['id']}}_READFROMBUFFER_VMASKS(truerow2_dim16, vmaskBITS, VMdatas_tmpB, 0); }
	#else 
	if(truerow1_dim16 < globalparams.SIZEKVS2_REDUCEPARTITION){ {%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA{{context['id']}}_READFROMBUFFER_VDATASWITHVMASKS(truerow1_dim16, vbuffer, Vdatas_tmpA, VMdatas_tmpA, 0); }
	if(truerow2_dim16 < globalparams.SIZEKVS2_REDUCEPARTITION){ {%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA{{context['id']}}_READFROMBUFFER_VDATASWITHVMASKS(truerow2_dim16, vbuffer, Vdatas_tmpB, VMdatas_tmpB, 0); }
	#endif 

	{%for v in context['VECTOR2_SIZE_seq']%}
	Vdatas[{{v}}] = Vdatas_tmpA[{{v}}]; 
	VMdatas[{{v}}] = VMdatas_tmpA[{{v}}];	
	// if(VMdatas_tmpA[{{v}}] > 0){ cout<<"------------- PROCESS{{context['id']}}_SPL3_GETVTXDATASET:: VMdatas_tmpA[{{v}}]: "<<VMdatas_tmpA[{{v}}]<<endl; }	
	{%endfor%}
	{%for v in context['VECTOR2_SIZE_seq']%}
	Vdatas[{{context['VECTOR2_SIZE'] + v}}] = Vdatas_tmpB[{{v}}];
	VMdatas[{{context['VECTOR2_SIZE'] + v}}] = VMdatas_tmpB[{{v}}]; 	
	// if(VMdatas_tmpB[{{v}}] > 0){ cout<<"------------- PROCESS{{context['id']}}_SPL3_GETVTXDATASET:: VMdatas_tmpB[{{v}}]: "<<VMdatas_tmpB[{{v}}]<<endl; }	
	{%endfor%}
	return fcol_dim16;
}

fetchmessage_t {{context['classname__processedges_splitdstvxs']}}PROCESS{{context['id']}}_SPL_readandprocess(bool_type enable, uint512_dt * edges, uint512_dt * kvdram, keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], unit1_type vmaskBITS[VMASK_PACKINGSIZE][BLOCKRAM_VMASK_SIZE], unit1_type vmask_subp[VMASK_PACKINGSIZE][BLOCKRAM_VMASK_SIZE], keyvalue_buffer_t buffer[VECTOR_SIZE][SOURCEBLOCKRAM_SIZE], 
		batch_type goffset_kvs, batch_type loffset_kvs, batch_type size_kvs, travstate_t travstate, sweepparams_t sweepparams, globalparams_t globalparams){
	fetchmessage_t fetchmessage;
	fetchmessage.chunksize_kvs = -1;
	fetchmessage.nextoffset_kvs = -1;
	if(enable == OFF){ return fetchmessage; }
	
	analysis_type analysis_loop = BLOCKRAM_SIZE / 2;

	uint32_type E[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=E complete
	bool_type en = ON;
	bool_type ens[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=ens complete
	unsigned int udata[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=udata complete
	unit1_type mask[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=mask complete
	
	buffer_type reducebuffersz = globalparams.SIZE_REDUCE / 2;
	unsigned int validbound = reducebuffersz * FETFACTOR * VECTOR2_SIZE;
	
	travstate.i_kvs = travstate.i_kvs / 2;
	travstate.end_kvs = travstate.end_kvs / 2;
	loffset_kvs = loffset_kvs / 2;
	buffer_type edgessize_kvs = size_kvs / 2;
	
	batch_type offset_kvs = goffset_kvs + loffset_kvs;
	
	value_t udataset[MAX_NUM_UNIQ_EDGES_PER_VEC];
	#pragma HLS ARRAY_PARTITION variable=udataset complete
	value_t maskset[MAX_NUM_UNIQ_EDGES_PER_VEC];
	#pragma HLS ARRAY_PARTITION variable=maskset complete
	vertex_t lvids[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=lvids complete
	keyvalue_t mykeyvalue[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=mykeyvalue complete
	
	unit4_type incr[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=incr complete
	unsigned int lsrcvids[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=lsrcvids complete
	unsigned int ldstvids[VECTOR2_SIZE];	
	#pragma HLS ARRAY_PARTITION variable=ldstvids complete
	value_t res[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=res complete
	
	value_t Vset[VSETSZ];
	#pragma HLS ARRAY_PARTITION variable=Vset complete
	unit1_type VMset[VMSETSZ];
	#pragma HLS ARRAY_PARTITION variable=VMset complete
	
	sliceinfos_t sliceinfos;
	
	vertex_t srcvid_head;
	vertex_t lvid_head;
	
	batch_type vptrbaseoffset_kvs = globalparams.BASEOFFSETKVS_VERTEXPTR + (globalparams.ACTSPARAMS_SRCVOFFSET / VECTOR_SIZE);
	batch_type voffset_kvs = sweepparams.source_partition * reducebuffersz * FETFACTOR;
	keyy_t nextbeginvptr;
	keyy_t nextbeginvptr_kvs;
	
	fetchmessage.chunksize_kvs = edgessize_kvs;
	fetchmessage.nextoffset_kvs = -1;
	buffer_type loadcount = 0;
	buffer_type activeloadcount = 0;
	buffer_type inactiveloadcount = 0;
	
	unsigned int debug_numinvalidheads = 0;
	unsigned int GraphAlgo = globalparams.ALGORITHMINFO_GRAPHALGORITHMID;
	unsigned int GraphAlgoClass = globalparams.ALGORITHMINFO_GRAPHALGORITHMCLASS;
	for(unsigned int v=0; v<MAX_NUM_UNIQ_EDGES_PER_VEC; v++){ udataset[v] = 0; }
	unsigned int offset = 0;
	keyvalue_t dummykeyvalue; dummykeyvalue.key = INVALIDDATA; dummykeyvalue.value = INVALIDDATA;
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	incr[{{v}}] = 0;
	lsrcvids[{{v}}] = 0;
	ldstvids[{{v}}] = 0;	
	E[{{v}}] = 0;
	ens[{{v}}] = 0;
	udata[{{v}}] = 0;
	mask[{{v}}] = 0;
	{%endfor%}
	
	buffer_type chunk_size = UTIL{{context['id']}}_getchunksize_kvs(edgessize_kvs, travstate, 0);
	READANDPROCESS{{context['id']}}_SPL_LOOP3C: for(buffer_type setoffset=0; setoffset<VECTOR2_SIZE; setoffset+=PE_SETSZ){
		READANDPROCESS{{context['id']}}_SPL_LOOP3D: for (buffer_type i=0; i<chunk_size; i++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loop avg=analysis_loop	
		#pragma HLS PIPELINE II=1
			#ifdef _DEBUGMODE_KERNELPRINTS
			cout<<"--- PROCESS{{context['id']}}_SPL_readandprocess: setoffset: "<<setoffset<<", i: "<<i<<" (of setsize: "<<VECTOR2_SIZE<<", of "<<chunk_size<<")"<<endl;
			#endif

			#ifdef _WIDEWORD
			{%for v in context['VECTOR2_SIZE_seq']%}
			E[{{v}}] = edges[offset_kvs + i].range({{((v + 1) * 32) - 1}}, {{v * 32}}); 
			{%endfor%}
			#else 
			{%for v in context['VECTOR_SIZE_seq']%}
			E[{{2*v}}] = edges[offset_kvs + i].data[{{v}}].key; 
			E[{{2*v+1}}] = edges[offset_kvs + i].data[{{v}}].value;
			{%endfor%}
			#endif
			#ifdef _DEBUGMODE_CHECKS3
			PROCESS{{context['id']}}_SPL_debug(0, i, E, ens, mask, udataset, maskset, Vset, VMset, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
			#endif 
				
			srcvid_head = E[0];
			lvid_head = srcvid_head - travstate.i2;	
			
			parsededge_t parsed_edgeSTD0 = PROCESS{{context['id']}}_PARSEEDGE(E[0]); unsigned int incrSTD0 = parsed_edgeSTD0.incr; unsigned int lsrcvidsSTD0 = lvid_head + incrSTD0; unsigned int ldstvidsSTD0 = parsed_edgeSTD0.dstvid; // STD0
			parsededge_t parsed_edgeSTD1 = PROCESS{{context['id']}}_PARSEEDGE(E[1]); unsigned int incrSTD1 = parsed_edgeSTD1.incr; unsigned int lsrcvidsSTD1 = lvid_head + incrSTD1; unsigned int ldstvidsSTD1 = parsed_edgeSTD1.dstvid; // STD1
			{%for v in context['PE_SETSZ_seq']%}
			parsededge_t parsed_edge{{v}} = PROCESS{{context['id']}}_PARSEEDGE(E[setoffset + {{v}}]);
			incr[{{v}}] = parsed_edge{{v}}.incr;
			lsrcvids[{{v}}] = lvid_head + incr[{{v}}];
			ldstvids[{{v}}] = parsed_edge{{v}}.dstvid;	
			{%endfor%}
			
			bool_type en = ON;
			#ifdef _DEBUGMODE_CHECKS3
			PROCESS{{context['id']}}_SPL_debug(1, i, E, ens, mask, udataset, maskset, Vset, VMset, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
			#endif
			
			offset = PROCESS{{context['id']}}_SPL3_GETVTXDATASET(lvid_head, vbuffer, vmaskBITS, Vset, VMset, globalparams);
			#ifdef _DEBUGMODE_CHECKS3
			PROCESS{{context['id']}}_SPL_debug(2, i, E, ens, mask, udataset, maskset, Vset, VMset, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
			#endif 
			
			bool_type ensSTD0 = ON; if(E[0] == INVALIDDATA || lsrcvidsSTD0 >= validbound){ ensSTD0 = OFF; } // STD0.
			bool_type ensSTD1 = ON; if(E[1] == INVALIDDATA || lsrcvidsSTD1 >= validbound){ ensSTD1 = OFF; } // STD1.
			{%for v in context['PE_SETSZ_seq']%}
			ens[{{v}}] = ON; if(E[setoffset + {{v}}] == INVALIDDATA || lsrcvids[{{v}}] >= validbound){ ens[{{v}}] = OFF; }
			{%endfor%}
			#ifdef _DEBUGMODE_CHECKS3
			PROCESS{{context['id']}}_SPL_debug(3, i, E, ens, mask, udataset, maskset, Vset, VMset, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
			#endif 
			
			unsigned int udataSTD0 = 0; unsigned int maskSTD0 = 0; // STD0.
			unsigned int udataSTD1 = 0; unsigned int maskSTD1 = 0; // STD1.
			{%for v in context['PE_SETSZ_seq']%} mask[{{v}}] = 0; {%endfor%}
			if(GraphAlgoClass == ALGORITHMCLASS_ALLVERTEXISACTIVE){ udataSTD0=1; maskSTD0=1; udataSTD1=1; maskSTD1=1; {%for v in context['PE_SETSZ_seq']%} mask[{{v}}] = 1; {%endfor%} } 
			else {
				udataSTD0 = Vset[offset + incrSTD0]; // STD0.
				maskSTD0 = VMset[offset + incrSTD0]; // STD0.
				udataSTD1 = Vset[offset + incrSTD1]; // STD1.
				maskSTD1 = VMset[offset + incrSTD1]; // STD1.
				{%for v in context['PE_SETSZ_seq']%}
				udata[{{v}}] = Vset[offset + incr[{{v}}]]; 
				mask[{{v}}] = VMset[offset + incr[{{v}}]];
				{%endfor%}
			}
			maskSTD0 = 0; // STD0
			ensSTD0 = OFF; // STD0
			#ifdef _DEBUGMODE_CHECKS3
			PROCESS{{context['id']}}_SPL_debug(4, i, E, ens, mask, udataset, maskset, Vset, VMset, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
			#endif
			
			{%for v in context['PE_SETSZ_seq']%}
			res[{{v}}] = PROCESS{{context['id']}}_SPL_processfunc(udata[{{v}}], 1, globalparams.ALGORITHMINFO_GRAPHALGORITHMID); 
			{%endfor%}
			{%for v in context['PE_SETSZ_seq']%}
			if(ens[{{v}}] == ON && mask[{{v}}] == 1){ mykeyvalue[{{v}}].key = ldstvids[{{v}}]; mykeyvalue[{{v}}].value = res[{{v}}]; } else { mykeyvalue[{{v}}].key = INVALIDDATA; mykeyvalue[{{v}}].value = INVALIDDATA;  }
			{%endfor%}
			#ifdef _DEBUGMODE_CHECKS3
			PROCESS{{context['id']}}_SPL_debug(5, i, E, ens, mask, udataset, maskset, Vset, VMset, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
			#endif 
			
			#if PE_SETSZ==8
			{%for v in context['VECTOR_SIZEPLUS1_seq']%}
			buffer[{{v}}][loadcount] = UTIL{{context['id']}}_GETKV(mykeyvalue[{{v}}]);
			{%endfor%}	
			if(setoffset == 0){ buffer[0][loadcount] = UTIL{{context['id']}}_GETKV(dummykeyvalue); }
			else { buffer[0][loadcount] = UTIL{{context['id']}}_GETKV(mykeyvalue[0]); }
			if(ensSTD1 == ON && maskSTD1 == 1){ loadcount += 1; } 
			#else
			{%for v in context['VECTOR_SIZE_seq']%}
			buffer[{{v}}][loadcount] = UTIL{{context['id']}}_GETKV(mykeyvalue[{{v}}]);
			{%endfor%}	
			{%for v in context['VECTOR_SIZE_seq']%}
			buffer[{{v}}][loadcount + 1] = UTIL{{context['id']}}_GETKV(mykeyvalue[{{context['VECTOR_SIZE']+v}}]);
			{%endfor%}
			buffer[0][loadcount] = UTIL{{context['id']}}_GETKV(dummykeyvalue); // STD0
			if(ensSTD1 == ON && maskSTD1 == 1){ loadcount += 2; }
			#endif
	
			#ifdef _DEBUGMODE_CHECKS3
			PROCESS{{context['id']}}_SPL_debug(6, i, E, ens, mask, udataset, maskset, Vset, VMset, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
			PROCESS{{context['id']}}_SPL_debug(7, i, E, ens, mask, udataset, maskset, Vset, VMset, lvids, incr, lsrcvids, ldstvids, res, mykeyvalue, sweepparams, globalparams, lvid_head, srcvid_head, travstate, chunk_size, sliceinfos, &activeloadcount, &inactiveloadcount, &debug_numinvalidheads);
			#endif
		}
	}
	// cout<<">>> readandprocess: loadcount: "<<loadcount<<endl;
	// cout<<">>> readandprocess: loadcount: "<<loadcount<<", activeloadcount: "<<activeloadcount<<", inactiveloadcount: "<<inactiveloadcount<<endl;
	// exit(EXIT_SUCCESS); ///
	// actsutilityobj->printglobalvars(); ///////////////////////
	// exit(EXIT_SUCCESS); ///
	fetchmessage.chunksize_kvs = loadcount;
	// cout<<">>> readandprocess: fetchmessage.chunksize_kvs: "<<fetchmessage.chunksize_kvs<<endl;
	return fetchmessage;
}




