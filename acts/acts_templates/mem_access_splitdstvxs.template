#include "mem_access_splitdstvxs.h"
using namespace std;

#ifdef SW
mem_access_splitdstvxs::mem_access_splitdstvxs(mydebug * _mydebugobj){ 
	actsutilityobj = new actsutility(); 
	acts_utilobj = new acts_util(_mydebugobj); 
	mem_accessobj = new mem_access(_mydebugobj); 
	mydebugobj = _mydebugobj;
}
mem_access_splitdstvxs::~mem_access_splitdstvxs(){}
#endif

// -------------------- vdata -------------------- //
void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_GetXYLayoutV(unsigned int s, value_t vdata[VECTOR2_SIZE], value_t vdata2[VECTOR2_SIZE], unsigned int depths[VECTOR2_SIZE], unsigned int basedepth){
	#ifdef CONFIG_ACTSPROCESSEDGES_SPREADVTXREAD
	unsigned int s_ = s % VECTOR2_SIZE;
	unsigned int depths_tmp[VECTOR2_SIZE];
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<16-1)%}if(s_=={{v}}){%endif%}{ 
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2<v)%}
		vdata2[{{v2}}] = vdata[{{16-v+v2}}]; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2>=v)%}
		vdata2[{{v2}}] = vdata[{{v2-v}}]; 
		{%endif%}{%endfor%}
		
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2<v)%}
		depths_tmp[{{v2}}] = {{16-v+v2}}; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2>=v)%}
		depths_tmp[{{v2}}] = {{v2-v}}; 
		{%endif%}{%endfor%}
	}
	{%endfor%}
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	depths[{{v}}] = basedepth + depths_tmp[{{v}}]; 
	{%endfor%}
	#else 
	for(unsigned int v=0; v<VECTOR2_SIZE; v++){ vdata2[v] = vdata[v]; }
	#endif 
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readvdata(bool_type enable, uint512_dt * kvdram, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs, batch_type bufferoffset_kvs, buffer_type size_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount =  REDUCESZ / 2;
	
	unsigned int index = 0;
	value_t vdata[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=vdata complete
	{%for v in context['VECTOR2_SIZE_seq']%}
	keyvalue_t keyvalue{{v}}; keyvalue{{v}}.key = 777; keyvalue{{v}}.value = 777;
	{%endfor%}
	
	READVDATA_LOOP: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
		vdata[{{2*v}}] = kvdram[baseoffset_kvs + offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		vdata[{{2*v+1}}] = kvdram[baseoffset_kvs + offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		vdata[{{2*v}}] = kvdram[baseoffset_kvs + offset_kvs + i].data[{{v}}].key;
		vdata[{{2*v+1}}] = kvdram[baseoffset_kvs + offset_kvs + i].data[{{v}}].value;
		{%endfor%}
		#endif
		
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITEVDATASTOBUFFER(bufferoffset_kvs + i, buffer, vdata);	
		
		// unsigned int indexes[16]; for(int v=0; v<16; v++){ indexes[v] = bufferoffset_kvs + i; }
		// {%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITEVDATASTOBUFFER_WITHDEPTHS(indexes, buffer, vdata);	
		
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvswritten(VECTOR_SIZE);
		#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"savevdata:: vertices saved: offset: "<<dramoffset_kvs * VECTOR_SIZE<<"-"<<(dramoffset_kvs + size_kvs) * VECTOR_SIZE<<", number of vertex datas written: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<<endl;
	#endif
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readvdata_slide(bool_type enable, unsigned int s, uint512_dt * kvdram, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs, batch_type bufferoffset_kvs, buffer_type size_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount =  REDUCESZ / 2;
	
	unsigned int index = 0;
	value_t vdata[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=vdata complete
	value_t vdata2[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=vdata2 complete
	unsigned int depths[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=depths complete
	{%for v in context['VECTOR2_SIZE_seq']%}
	keyvalue_t keyvalue{{v}}; keyvalue{{v}}.key = 777; keyvalue{{v}}.value = 777;
	{%endfor%}
	for(unsigned int v=0; v<VECTOR2_SIZE; v++){ vdata[v] = 0; vdata2[v] = 0; }
	
	unsigned int index2 = 0;
	READVDATA_LOOP: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
		vdata[{{2*v}}] = kvdram[baseoffset_kvs + offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		vdata[{{2*v+1}}] = kvdram[baseoffset_kvs + offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		vdata[{{2*v}}] = kvdram[baseoffset_kvs + offset_kvs + i].data[{{v}}].key;
		vdata[{{2*v+1}}] = kvdram[baseoffset_kvs + offset_kvs + i].data[{{v}}].value;
		{%endfor%}
		#endif
		
		#ifdef CONFIG_READVDATA_SLIDEANDREARRANGE
		unsigned int x = index2 + s;
		unsigned int basedepth = (x / VECTOR2_SIZE) * VECTOR2_SIZE;
		MEMACCESS_SPL_GetXYLayoutV(x, vdata, vdata2, depths, basedepth);
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITEVDATASTOBUFFER_WITHDEPTHS(depths, buffer, vdata2);	
		index2 += NUM_PEs;
		#else
		MEMACCESS_SPL_GetXYLayoutV(s, vdata, vdata2, depths);
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITEVDATASTOBUFFER(bufferoffset_kvs + i, buffer, vdata2);	
		#endif 
		
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvswritten(VECTOR_SIZE);
		#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"savevdata:: vertices saved: offset: "<<dramoffset_kvs * VECTOR_SIZE<<"-"<<(dramoffset_kvs + size_kvs) * VECTOR_SIZE<<", number of vertex datas written: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<<endl;
	#endif
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readvdatachunks(bool_type enable, uint512_dt * kvdram, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type vbaseoffset_kvs, batch_type voffset_kvs, batch_type vsz_kvs, globalparams_t globalparams){
	unsigned int depth = globalparams.NUM_REDUCEPARTITIONS * globalparams.SIZEKVS2_REDUCEPARTITION;
	unsigned int bdepth = vsz_kvs / 2;
	unsigned int depth_i = 0;
	unsigned int bdepth_i = 0;
	for(unsigned int s=0; s<NUM_PEs; s++){ 
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<"MEMACCESS_SPL_readvdatachunks:: size loaded @ s("<<s<<"): offset_kvs2: "<<(s * vsz_kvs)<<", sz_kvs2: "<<vsz_kvs<<endl;
		#endif
		MEMACCESS_SPL_readvdata_slide(enable, s, kvdram, buffer, vbaseoffset_kvs, depth_i + voffset_kvs, bdepth_i, vsz_kvs, globalparams); // CRITICAL FIXME.
		depth_i += depth;
		bdepth_i += bdepth;
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"+++ MEMACCESS_SPL_readvdatachunks:: total size loaded: "<<vsz_kvs * NUM_PEs * VECTOR2_SIZE<<endl;
	#endif
	return;	
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_savevdata(bool_type enable, uint512_dt * kvdram, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs, batch_type bufferoffset_kvs, buffer_type size_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount =  REDUCESZ / 2;
	
	SAVEVDATA_LOOP: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
	#pragma HLS PIPELINE II=1
		{%for v in context['VECTOR2_SIZE_seq']%}
		keyvalue_t mykeyvalue{{v}} = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV2(buffer[{{v}}][bufferoffset_kvs + (i/2)]);
		{%endfor%}
	
		#ifdef _WIDEWORD
		if(i%2==0){
			{%for v in context['VECTOR_SIZE_seq']%}
			kvdram[baseoffset_kvs + offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = mykeyvalue{{2*v}}.key; 
			kvdram[baseoffset_kvs + offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = mykeyvalue{{2*v+1}}.key; 
			{%endfor%}
		} else {
			{%for v in context['VECTOR_SIZE_seq']%}
			kvdram[baseoffset_kvs + offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = mykeyvalue{{2*v}}.value; 
			kvdram[baseoffset_kvs + offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = mykeyvalue{{2*v+1}}.value; 
			{%endfor%}
		}
		#else 
		if(i%2==0){
			{%for v in context['VECTOR_SIZE_seq']%}
			kvdram[baseoffset_kvs + offset_kvs + i].data[{{v}}].key = mykeyvalue{{2*v}}.key;
			kvdram[baseoffset_kvs + offset_kvs + i].data[{{v}}].value = mykeyvalue{{2*v+1}}.key;
			{%endfor%}
		} else {
			{%for v in context['VECTOR_SIZE_seq']%}
			kvdram[baseoffset_kvs + offset_kvs + i].data[{{v}}].key = mykeyvalue{{2*v}}.value;
			kvdram[baseoffset_kvs + offset_kvs + i].data[{{v}}].value = mykeyvalue{{2*v+1}}.value;
			{%endfor%}
		}
		#endif
	
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvswritten(VECTOR_SIZE);
		#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"savevdata:: vertices saved: offset: "<<(offset_kvs) * VECTOR_SIZE<<"-"<<(offset_kvs + size_kvs) * VECTOR_SIZE<<", number of vertex datas written: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<<endl;
	#endif
	return;
}

// -------------------- vmasks -------------------- //
void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_GetXYLayoutVM(unsigned int s, unit1_type vmdata[VECTOR2_SIZE], unit1_type vmdata2[VECTOR2_SIZE], unsigned int depths[VECTOR2_SIZE], unsigned int basedepth){
	#ifdef CONFIG_ACTSPROCESSEDGES_SPREADVTXREAD
	unsigned int s_ = s % VECTOR2_SIZE;
	unsigned int depths_tmp[VECTOR2_SIZE];
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<16-1)%}if(s_=={{v}}){%endif%}{
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2<v)%}
		vmdata2[{{v2}}] = vmdata[{{16-v+v2}}]; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2>=v)%}
		vmdata2[{{v2}}] = vmdata[{{v2-v}}]; 
		{%endif%}{%endfor%}
		
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2<v)%}
		depths_tmp[{{v2}}] = {{16-v+v2}}; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2>=v)%}
		depths_tmp[{{v2}}] = {{v2-v}}; 
		{%endif%}{%endfor%}
	}
	{%endfor%}
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	depths[{{v}}] = basedepth + depths_tmp[{{v}}]; 
	{%endfor%}
	#else 
	for(unsigned int v=0; v<VECTOR2_SIZE; v++){ vmdata2[v] = vmdata[v]; }
	#endif 
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readvmasks_slide(bool_type enable, unsigned int s, uint512_dt * kvdram, unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], keyvalue_vbuffer_t tempbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type baseoffset_kvs, batch_type lbaseoffset_kvs, batch_type offset_kvs, buffer_type bufferoffset, buffer_type size_kvs){			
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount1 = BLOCKRAM_SIZE;
	analysis_type analysis_loopcount2 = BLOCKRAM_SIZE / 16;
	analysis_type analysis_loopcount3 = BLOCKRAM_SIZE;
	
	// vmask is essentially vdata shrinked
	unsigned int rlbaseoffset_kvs = lbaseoffset_kvs / FACTOR_REDUCEPARTITIONSZ_VMASKSZ;
	unsigned int roffset_kvs = offset_kvs / FACTOR_REDUCEPARTITIONSZ_VMASKSZ; // AUTOMATEME. 'FACTOR_REDUCEPARTITIONSZ_VMASKSZ' changes with dataset
	unsigned int rbufferoffset = bufferoffset / FACTOR_REDUCEPARTITIONSZ_VMASKSZ;
	unsigned int rsize_kvs = size_kvs / FACTOR_REDUCEPARTITIONSZ_VMASKSZ; // 32
	
	uint32_type bitsbuffer[BLOCKRAM_SIZE];
	unit1_type vmdata[VMASK_PACKINGSIZE];
	unit1_type vmdata2[VMASK_PACKINGSIZE];
	#pragma HLS ARRAY_PARTITION variable=vmdata complete
	#pragma HLS ARRAY_PARTITION variable=vmdata2 complete
	unsigned int depths[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=depths complete

	// read 
	READVMASKS_LOOP: for (buffer_type i=0; i<rsize_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount1 avg=analysis_loopcount1
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}	
		tempbuffer[{{2*v}}][i] = kvdram[baseoffset_kvs + rlbaseoffset_kvs + roffset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		tempbuffer[{{2*v+1}}][i] = kvdram[baseoffset_kvs + rlbaseoffset_kvs + roffset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}});			
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		tempbuffer[{{v}}][i].key = kvdram[baseoffset_kvs + rlbaseoffset_kvs + roffset_kvs + i].data[{{v}}].key;
		tempbuffer[{{v}}][i].value = kvdram[baseoffset_kvs + rlbaseoffset_kvs + roffset_kvs + i].data[{{v}}].value; 
		{%endfor%}
		#endif 
		#ifdef _DEBUGMODE_CHECKS2
		actsutilityobj->checkoutofbounds("MEMACCESS_SPL_readvmasks_slide:", rlbaseoffset_kvs + roffset_kvs, NUMPROCESSEDGESPARTITIONS * VMASKBUFFERSZ_KVS, baseoffset_kvs, rlbaseoffset_kvs, roffset_kvs);
		#endif
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvsread(VECTOR_SIZE);
		#endif
	}
	
	// u512 => u32s
	buffer_type index = 0;
	LOADVMASKS_LOOP1: for (buffer_type i=0; i<rsize_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount2 avg=analysis_loopcount2
	#pragma HLS PIPELINE II=8
		#ifdef _WIDEWORD
		{%for v in context['VECTOR2_SIZE_seq']%}
		bitsbuffer[index + {{v}}] = tempbuffer[{{v}}][i];
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		bitsbuffer[index + {{2*v}}] = tempbuffer[{{v}}][i].key;
		bitsbuffer[index + {{2*v}} + 1] = tempbuffer[{{v}}][i].value;
		{%endfor%}
		#endif 
		
		index += VECTOR_SIZE * 2;
	}

	// u32 => u16bits
	buffer_type i = 0;
	unsigned int index2 = 0;
	LOADVMASKS_LOOP2: for (i=0; i<size_kvs; i++){ // transfsize, reducebuffersz
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount3 avg=analysis_loopcount3
	#pragma HLS PIPELINE II=2
		#ifdef _WIDEWORD
		if(i%2==0){
			{%for v in context['16_seq']%}
			vmdata[{{v}}] = bitsbuffer[i/2].range({{v}}, {{v}});
			{%endfor%}
		} else {
			{%for v in context['16_seq']%}
			vmdata[{{v}}] = bitsbuffer[i/2].range({{16+v}}, {{16+v}});
			{%endfor%}
		}
		#else 
		if(i%2==0){
			{%for v in context['16_seq']%}
			vmdata[{{v}}] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_READFROM_UINT(bitsbuffer[i/2], {{v}}, 1);
			{%endfor%}
		} else {
			{%for v in context['16_seq']%}
			vmdata[{{v}}] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_READFROM_UINT(bitsbuffer[i/2], {{16+v}}, 1);
			{%endfor%}
		}
		#endif
		
		#ifdef CONFIG_READVDATA_SLIDEANDREARRANGE
		unsigned int x = index2 + s;
		unsigned int basedepth = (x / VECTOR2_SIZE) * VECTOR2_SIZE;
		MEMACCESS_SPL_GetXYLayoutVM(x, vmdata, vmdata2, depths, basedepth);
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITEVMASKSTOBUFFER_WITHDEPTHS(depths, vmaskBITS, vmdata2);
		index2 += NUM_PEs;
		#else 
		MEMACCESS_SPL_GetXYLayoutVM(s, vmdata, vmdata2, depths);
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITEVMASKSTOBUFFER(bufferoffset + i, vmaskBITS, vmdata2);
		#endif 
	}
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readvmaskschunks(bool_type enable, uint512_dt * kvdram, unit1_type vmaskBITS[VDATA_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type basevoffset_kvs, batch_type voffset_kvs, batch_type vsz_kvs, globalparams_t globalparams){				
	unsigned int depth = globalparams.NUM_REDUCEPARTITIONS * globalparams.SIZEKVS2_REDUCEPARTITION;
	unsigned int bdepth = vsz_kvs;
	unsigned int depth_i = 0;
	unsigned int bdepth_i = 0;
	for(unsigned int s=0; s<NUM_PEs; s++){
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<"MEMACCESS_SPL_readvmaskschunks:: size loaded @ s("<<s<<"): voffset_kvs: "<<voffset_kvs<<", sz: "<<(vsz_kvs * VECTOR2_SIZE)<<endl;
		#endif 
		MEMACCESS_SPL_readvmasks_slide(enable, s, kvdram, vmaskBITS, buffer, basevoffset_kvs, depth_i, voffset_kvs, bdepth_i, vsz_kvs); 
		depth_i += depth;
		bdepth_i += bdepth;
	}
	
	for(unsigned int i=0; i<DOUBLE_BLOCKRAM_SIZE; i++){
		
	}
	
	/* //////////////////////////////////////////////////////////////////
	#ifdef _DEBUGMODE_KERNELPRINTS3
	for(unsigned int i=0; i<DOUBLE_BLOCKRAM_SIZE; i++){
		for(unsigned int v=0; v<VECTOR2_SIZE; v++){
			if(vmaskBITS[v][i] == 1){
				cout<<"------------ MEMACCESS_SPL_readvmaskschunks: 1 SEEN: vmaskBITS["<<v<<"]["<<i<<"]("<<vmaskBITS[v][i]<<") == 1"<<endl;
			}
		}
	}
	#endif 
	////////////////////////////////////////////////////////////////// */
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"+++ MEMACCESS_SPL_readvmaskschunks:: total size (bits) loaded: "<<vsz_kvs * NUM_PEs * VECTOR2_SIZE * 32<<endl;
	#endif
	return;	
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_savemasks(bool_type enable, uint512_dt * kvdram, unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs, unsigned int vmaskp_offset_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"MEMACCESS_SPL_savemasks:: saving vmask saved: offset_kvs: "<<offset_kvs<<", vmaskp_offset_kvs: "<<vmaskp_offset_kvs<<""<<endl;
	#endif
	
	/* ///////////////////////////////////////////////// REMOVEME
	#ifdef _DEBUGMODE_CHECKS2
	for(buffer_type k=0; k<globalparams.SIZEKVS2_REDUCEPARTITION; k+=1){
		{%for v in context['VECTOR2_SIZE_seq']%}
		if(vmaskBITS[{{v}}][k]==1){ mydebugobj->increment(2, globalparams.ALGORITHMINFO_GRAPHITERATIONID, 1); }
		{%endfor%}
	}
	#endif 
	///////////////////////////////////////////////// */
	
	uint32_type tempbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE]; // CRITICAL FIXME. TOO EXPENSIVE...........................
	#pragma HLS array_partition variable = tempbuffer
	uint32_type cummvmask_sp = 0;
	
	unsigned int processpartitionsz = globalparams.SIZEKVS2_PROCESSEDGESPARTITION * VECTOR2_SIZE;
	unsigned int vpmasks_i = 0;
	unsigned int realvid = 0;
	uint32_type vpmasks[BLOCKRAM_SIZE];
	unsigned int index = 0;
	unsigned int next_chpt = processpartitionsz;
	
	SAVEVMASKS_LOOP1: for(buffer_type k=0; k<globalparams.SIZEKVS2_REDUCEPARTITION; k+=2){
	#pragma HLS PIPELINE II=1
		unsigned int X = index % 16;
		unsigned int Y = index / 16;
		
		unsigned int n_i = k;
		unsigned int n_iplus1 = k + 1;
		
		#ifdef _WIDEWORD
		{%for v in context['VECTOR2_SIZE_seq']%}
		tempbuffer[X][Y].range({{v}}, {{v}}) = vmaskBITS[{{v}}][n_i];
		{%endfor%}
		{%for v in context['VECTOR2_SIZE_seq']%}
		tempbuffer[X][Y].range({{16+v}}, {{16+v}}) = vmaskBITS[{{v}}][n_iplus1];
		{%endfor%}
		#else
		{%for v in context['VECTOR2_SIZE_seq']%}
		{%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_WRITETO_UINT(&tempbuffer[X][Y], {{v}}, 1, vmaskBITS[{{v}}][n_i]);
		{%endfor%}
		{%for v in context['VECTOR2_SIZE_seq']%}
		{%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_WRITETO_UINT(&tempbuffer[X][Y], {{16+v}}, 1, vmaskBITS[{{v}}][n_iplus1]);
		{%endfor%}
		#endif
		index += 1;
		
		uint32_type maskA = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_CONVERTVMASKTOUINT32(vmaskBITS, n_i);
		uint32_type maskB = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_CONVERTVMASKTOUINT32(vmaskBITS, n_iplus1);
		cummvmask_sp = cummvmask_sp | maskA | maskB;
		// cout<<"MEMACCESS_SPL_savemasks:: maskA: "<<maskA<<", maskB: "<<maskB<<", cummvmask_sp: "<<cummvmask_sp<<endl;
		
		realvid = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETREALVID(((k/2) * 32) + 32, globalparams.ACTSPARAMS_INSTID);
		#ifdef _DEBUGMODE_KERNELPRINTS
		if(realvid >= next_chpt){ cout<<"--- MEMACCESS_SPL_savemasks:: next checkpoint seen @ k: "<<k<<", realvid["<<k/2<<"]: "<<realvid<<", vpmasks_i: "<<vpmasks_i<<", cummvmask_sp: "<<cummvmask_sp<<endl; }
		#endif 
		if(realvid >= next_chpt){ vpmasks[vpmasks_i] = cummvmask_sp; cummvmask_sp = 0; vpmasks_i += 1; next_chpt += processpartitionsz; } // CRITICAL FIXME. TOO EXPENSIVE. CRITICAL FIXME.
	}
	#ifdef _DEBUGMODE_KERNELPRINTS2
	cout<<"--- MEMACCESS_SPL_savemasks:: FINISHED. realvid: "<<realvid<<", vpmasks_i: "<<vpmasks_i<<endl;
	#endif 
	#ifdef _DEBUGMODE_CHECKS3
	if(vpmasks_i != NUM_PEs){ cout<<"--- MEMACCESS_SPL_savemasks:: ERROR: vpmasks_i("<<vpmasks_i<<") != NUM_PEs("<<NUM_PEs<<"). EXITING...."<<endl; exit(EXIT_FAILURE); }
	#endif
	
	SAVEVMASKS_LOOP2: for(buffer_type k=0; k<globalparams.SIZEKVS_VMASKBUFFER; k++){
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
		kvdram[baseoffset_kvs + offset_kvs + k].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = tempbuffer[{{2*v}}][k];
		kvdram[baseoffset_kvs + offset_kvs + k].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = tempbuffer[{{2*v+1}}][k];
		{%endfor%}
		#else
		{%for v in context['VECTOR_SIZE_seq']%}
		kvdram[baseoffset_kvs + offset_kvs + k].data[{{v}}].key = tempbuffer[{{2*v}}][k];
		kvdram[baseoffset_kvs + offset_kvs + k].data[{{v}}].value = tempbuffer[{{2*v+1}}][k];
		{%endfor%}
		#endif
	}
	
	SAVEVMASKS_LOOP3: for(buffer_type n=0; n<NUM_PEs; n++){
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		kvdram[vmaskp_offset_kvs + n]
			#ifdef _WIDEWORD
			.range(31, 0)
			#else
			.data[0].key
			#endif
		= vpmasks[n];
		#endif
	}
	// exit(EXIT_SUCCESS); //////////////
	return;
}







