#include "mem_access_splitdstvxs.h"
using namespace std;

#ifdef SW
mem_access_splitdstvxs::mem_access_splitdstvxs(mydebug * _mydebugobj){ 
	actsutilityobj = new actsutility(); 
	acts_utilobj = new acts_util(_mydebugobj);
	mydebugobj = _mydebugobj;
}
mem_access_splitdstvxs::~mem_access_splitdstvxs(){}
#endif

// -------------------- key values -------------------- //
fetchmessage_t {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readkeyvalues(bool_type enable, uint512_dt * kvdram, keyvalue_buffer_t buffer[VECTOR_SIZE][SOURCEBLOCKRAM_SIZE], batch_type offset_kvs, batch_type size_kvs, travstate_t travstate, globalparams_t globalparams){
	fetchmessage_t fetchmessage;
	fetchmessage.chunksize_kvs = -1;
	fetchmessage.nextoffset_kvs = -1;
	if(enable == OFF){ return fetchmessage; }
	
	analysis_type analysis_loopcount = BLOCKRAM_SIZE;
	buffer_type chunk_size = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_getchunksize_kvs(size_kvs, travstate, 0);
	
	fetchmessage.chunksize_kvs = chunk_size;
	fetchmessage.nextoffset_kvs = NAp;
	
	READKEYVALUES1_LOOP: for (buffer_type i=0; i<chunk_size; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
	#pragma HLS PIPELINE II=1
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t mykeyvalue{{v}};
		{%endfor%}
		
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
		mykeyvalue{{v}}.key = kvdram[offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}});
		mykeyvalue{{v}}.value = kvdram[offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}});
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		mykeyvalue{{v}}.key = kvdram[offset_kvs + i].data[{{v}}].key; 
		mykeyvalue{{v}}.value = kvdram[offset_kvs + i].data[{{v}}].value; 
		{%endfor%}
		#endif 
		
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer[{{v}}][i] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV(mykeyvalue{{v}});
		{%endfor%}
		
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvsread(VECTOR_SIZE);
		#endif
	}
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"readkeyvalues:: keyvalues read: offset_kvs: "<<offset_kvs<<", size_kvs: "<<size_kvs<<", chunk_size: "<<chunk_size<<endl;
	#endif
	return fetchmessage;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_savekeyvalues(bool_type enable, uint512_dt * kvdram, keyvalue_buffer_t buffer[VECTOR_SIZE][DESTBLOCKRAM_SIZE], keyvalue_t * globalcapsule, keyvalue_capsule_t localcapsule[MAX_NUM_PARTITIONS], batch_type globalbaseaddress_kvs, globalparams_t globalparams){				
	if(enable == OFF){ return; }
	analysis_type analysis_destpartitionsz = DESTBLOCKRAM_SIZE / NUM_PARTITIONS;
	
	#ifdef _DEBUGMODE_CHECKS
	actsutilityobj->printkeyvalues("savekeyvalues::localcapsule", localcapsule, MAX_NUM_PARTITIONS);
	actsutilityobj->printvaluecount("savekeyvalues::localcapsule", localcapsule, MAX_NUM_PARTITIONS);
	actsutilityobj->scankeyvalues("savekeyvalues::buffer", (keyvalue_t *)buffer, localcapsule, NUM_PARTITIONS, globalparams.SIZE_BATCHRANGE / NUM_PARTITIONS, actsutilityobj->getsweepparams().upperlimit);
	#endif
	
	SAVEPARTITIONS_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){
		batch_type dramoffset_kvs = globalbaseaddress_kvs + ((globalcapsule[p].key + globalcapsule[p].value) / VECTOR_SIZE);
		buffer_type bramoffset_kvs = localcapsule[p].key / VECTOR_SIZE;
		buffer_type realsize_kvs = localcapsule[p].value / VECTOR_SIZE;
		buffer_type size_kvs = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_getpartitionwritesz(realsize_kvs, bramoffset_kvs);
		
		#ifdef _DEBUGMODE_CHECKS2
		actsutilityobj->checkoutofbounds("savekeyvalues 23", bramoffset_kvs + size_kvs, DESTBLOCKRAM_SIZE + 1, p, NAp, NAp);
		actsutilityobj->checkoutofbounds("savekeyvalues 25", ((globalcapsule[p].key + globalcapsule[p].value) / VECTOR_SIZE), globalparams.SIZE_KVDRAM + 1, p, NAp, NAp);
		#endif
		if(realsize_kvs > 0){
			SAVEPARTITIONS_LOOP1B: for(buffer_type i=0; i<size_kvs; i++){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_destpartitionsz avg=analysis_destpartitionsz
			#pragma HLS PIPELINE II=1
				{%for v in context['VECTOR_SIZE_seq']%}
				keyvalue_t mykeyvalue{{v}} = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV(buffer[{{v}}][bramoffset_kvs + i]);
				{%endfor%}
				
				#ifdef _WIDEWORD
				{%for v in context['VECTOR_SIZE_seq']%}
				kvdram[dramoffset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = mykeyvalue{{v}}.key; 
				kvdram[dramoffset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = mykeyvalue{{v}}.value; 
				{%endfor%}
				#else
				{%for v in context['VECTOR_SIZE_seq']%}
				kvdram[dramoffset_kvs + i].data[{{v}}].key = mykeyvalue{{v}}.key; 
				kvdram[dramoffset_kvs + i].data[{{v}}].value = mykeyvalue{{v}}.value; 
				{%endfor%}
				#endif 
				
				#ifdef _DEBUGMODE_STATS
				actsutilityobj->globalstats_countkvspartitionswritten_actual(VECTOR_SIZE);
				#endif
			}
			#ifdef _DEBUGMODE_STATS
			actsutilityobj->globalstats_countkvspartitionswritten(realsize_kvs * VECTOR_SIZE);
			#endif
		}
	}
	SAVEPARTITIONS_LOOP2: for(partition_type p=0; p<NUM_PARTITIONS; p++){ globalcapsule[p].value += localcapsule[p].value; }
	
	#if defined(ENABLE_PERFECTACCURACY) && defined(_DEBUGMODE_CHECKS2)
	for(unsigned int i=0; i<NUM_PARTITIONS-1; i++){ 
		if(globalcapsule[i].key + globalcapsule[i].value >= globalcapsule[i+1].key && globalcapsule[i].value > 0){ 
			cout<<"savekeyvalues::globalcapsule 33. ERROR. out of bounds. (globalcapsule["<<i<<"].key("<<globalcapsule[i].key<<") + globalcapsule["<<i<<"].value("<<globalcapsule[i].value<<") >= globalcapsule["<<i+1<<"].key("<<globalcapsule[i+1].key<<")) printing and exiting..."<<endl; 
			actsutilityobj->printkeyvalues("savekeyvalues::globalcapsule 34", (keyvalue_t *)globalcapsule, NUM_PARTITIONS); 
			exit(EXIT_FAILURE); 
		}
	}
	if(globalcapsule[NUM_PARTITIONS-1].key + globalcapsule[NUM_PARTITIONS-1].value >= globalparams.SIZE_KVDRAM){
		cout<<"savekeyvalues::globalcapsule 36. ERROR. out of bounds. (globalcapsule["<<NUM_PARTITIONS-1<<"].key("<<globalcapsule[NUM_PARTITIONS-1].key<<") + globalcapsule["<<NUM_PARTITIONS-1<<"].value("<<globalcapsule[NUM_PARTITIONS-1].value<<") >= globalparams.SIZE_KVDRAM("<<globalparams.SIZE_KVDRAM<<")) printing and exiting..."<<endl; 
		actsutilityobj->printkeyvalues("savekeyvalues::globalcapsule 37", (keyvalue_t *)globalcapsule, NUM_PARTITIONS); 
		exit(EXIT_FAILURE); 
	}
	#endif
	#ifdef _DEBUGMODE_KERNELPRINTS2
	cout<<"savekeyvalues:: keyvalues saved: offset_kvs from: "<<globalbaseaddress_kvs + ((globalcapsule[0].key + globalcapsule[0].value) / VECTOR_SIZE)<<endl;
	actsutilityobj->printkeyvalues("actsutility::savekeyvalues: globalcapsule.", (keyvalue_t *)globalcapsule, NUM_PARTITIONS);
	#endif
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readkeyvalues(bool_type enable, uint512_dt * kvdram, batch_type dramoffset_kvs, keyvalue_buffer_t buffer[VECTOR_SIZE][BLOCKRAM_SIZE], batch_type bufferoffset_kvs, buffer_type size_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount = BLOCKRAM_SIZE;
		
	READKEYVALUES2_LOOP: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
	#pragma HLS PIPELINE II=1
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t mykeyvalue{{v}};
		{%endfor%}
		
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
		mykeyvalue{{v}}.key = kvdram[dramoffset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		mykeyvalue{{v}}.value = kvdram[dramoffset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		mykeyvalue{{v}}.key = kvdram[dramoffset_kvs + i].data[{{v}}].key;
		mykeyvalue{{v}}.value = kvdram[dramoffset_kvs + i].data[{{v}}].value; 
		{%endfor%}
		
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer[{{v}}][bufferoffset_kvs + i] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV(mykeyvalue{{v}});
		{%endfor%}
		
		#endif 
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvsread(VECTOR_SIZE);
		#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<< TIMINGRESULTSCOLOR<<"readkeyvalues:: vertices read: offset: "<<dramoffset_kvs * VECTOR_SIZE<<"-"<<(dramoffset_kvs + size_kvs) * VECTOR_SIZE<<", number of vertex datas read: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<< RESET<<endl;
	#endif
	#ifdef _DEBUGMODE_KERNELPRINTS
	if(dramoffset_kvs >= globalparams.BASEOFFSETKVS_VERTEXPTR_ && dramoffset_kvs < globalparams.BASEOFFSETKVS_VERTEXPTR + VERTEXPTRSSZ_KVS){ cout<< TIMINGRESULTSCOLOR<<"readkeyvalues:: vertices read: offset: "<<(dramoffset_kvs - globalparams.BASEOFFSETKVS_VERTEXPTR) * VECTOR_SIZE<<"-"<<(dramoffset_kvs + size_kvs - globalparams.BASEOFFSETKVS_VERTEXPTR) * VECTOR_SIZE<<", number of vertex datas read: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<< RESET<<endl; }
	if(dramoffset_kvs >= globalparams.BASEOFFSETKVS_VERTICESDATA_ && dramoffset_kvs < globalparams.BASEOFFSETKVS_DESTVERTICESDATA + VERTICESDATASZ_KVS){ cout<< TIMINGRESULTSCOLOR<<"readkeyvalues:: vertices read: offset: "<<(dramoffset_kvs - globalparams.BASEOFFSETKVS_DESTVERTICESDATA) * VECTOR_SIZE<<"-"<<(dramoffset_kvs + size_kvs - globalparams.BASEOFFSETKVS_DESTVERTICESDATA) * VECTOR_SIZE<<", number of vertex datas read: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<< RESET<<endl; }
	#endif
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_savekeyvalues(bool_type enable, uint512_dt * kvdram, batch_type dramoffset_kvs, keyvalue_buffer_t buffer[VECTOR_SIZE][BLOCKRAM_SIZE], batch_type bufferoffset_kvs, buffer_type size_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount =  BLOCKRAM_SIZE;
	
	SAVEKEYVALUES2_LOOP: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
	#pragma HLS PIPELINE II=1
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t mykeyvalue{{v}} = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETKV(buffer[{{v}}][bufferoffset_kvs + i]);
		{%endfor%}
	
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
		kvdram[dramoffset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = mykeyvalue{{v}}.key; 
		kvdram[dramoffset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = mykeyvalue{{v}}.value; 
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		kvdram[dramoffset_kvs + i].data[{{v}}].key = mykeyvalue{{v}}.key;
		kvdram[dramoffset_kvs + i].data[{{v}}].value = mykeyvalue{{v}}.value;
		{%endfor%}
		#endif 
		
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvswritten(VECTOR_SIZE);
		#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"savekeyvalues:: vertices saved: offset: "<<dramoffset_kvs * VECTOR_SIZE<<"-"<<(dramoffset_kvs + size_kvs) * VECTOR_SIZE<<", number of vertex datas written: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<<endl;
	#endif
	#ifdef _DEBUGMODE_KERNELPRINTS2
	if(dramoffset_kvs >= globalparams.BASEOFFSETKVS_VERTEXPTR && dramoffset_kvs < globalparams.BASEOFFSETKVS_VERTEXPTR + VERTEXPTRSSZ_KVS){ cout<< TIMINGRESULTSCOLOR<<"savekeyvalues:: vertices saved: offset: "<<dramoffset_kvs-globalparams.BASEOFFSETKVS_VERTEXPTR * VECTOR_SIZE<<"-"<<((dramoffset_kvs + size_kvs)-globalparams.BASEOFFSETKVS_VERTEXPTR) * VECTOR_SIZE<<", number of vertex datas written: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<< RESET<<endl; }
	if(dramoffset_kvs >= globalparams.BASEOFFSETKVS_DESTVERTICESDATA && dramoffset_kvs < globalparams.BASEOFFSETKVS_DESTVERTICESDATA + VERTICESDATASZ_KVS){ cout<< TIMINGRESULTSCOLOR<<"savekeyvalues:: vertices saved: offset: "<<(dramoffset_kvs-globalparams.BASEOFFSETKVS_DESTVERTICESDATA) * VECTOR_SIZE<<"-"<<((dramoffset_kvs-globalparams.BASEOFFSETKVS_DESTVERTICESDATA) + size_kvs) * VECTOR_SIZE<<", number of vertex datas written: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<< RESET<<endl; }					
	#endif
	return;
}

// -------------------- vdata -------------------- //
void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_GetXYLayoutV(unsigned int s, value_t vdata[VECTOR2_SIZE], value_t vdata2[VECTOR2_SIZE], unsigned int depths[VECTOR2_SIZE], unsigned int basedepth){
	unsigned int s_ = s % VECTOR2_SIZE;
	unsigned int depths_tmp[VECTOR2_SIZE];
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<16-1)%}if(s_=={{v}}){%endif%}{ 
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2<v)%}
		vdata2[{{v2}}] = vdata[{{16-v+v2}}]; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2>=v)%}
		vdata2[{{v2}}] = vdata[{{v2-v}}]; 
		{%endif%}{%endfor%}
		
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2<v)%}
		depths_tmp[{{v2}}] = {{16-v+v2}}; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2>=v)%}
		depths_tmp[{{v2}}] = {{v2-v}}; 
		{%endif%}{%endfor%}
	}
	{%endfor%}
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	depths[{{v}}] = basedepth + depths_tmp[{{v}}]; 
	{%endfor%}
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_RearrangeLayoutV(unsigned int s, value_t vdata[VECTOR2_SIZE], value_t vdata2[VECTOR2_SIZE]){
	unsigned int s_ = s % VECTOR2_SIZE;
	{%for v in context['VECTOR2_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<16-1)%}if(s_=={{v}}){%endif%}{ 
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2<v)%}
		vdata2[{{16-v+v2}}] = vdata[{{v2}}]; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2>=v)%}
		vdata2[{{v2-v}}] = vdata[{{v2}}]; 
		{%endif%}{%endfor%}
	}
	{%endfor%}
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readvdata(bool_type enable, uint512_dt * kvdram, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs, batch_type bufferoffset_kvs, buffer_type size_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount =  REDUCESZ / 2;
	
	unsigned int index = 0;
	value_t vdata[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=vdata complete
	{%for v in context['VECTOR2_SIZE_seq']%}
	keyvalue_t keyvalue{{v}}; keyvalue{{v}}.key = 777; keyvalue{{v}}.value = 777;
	{%endfor%}
	
	READVDATA_LOOP: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
	#pragma HLS PIPELINE II=1	
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_READFROMKVDRAM_VDATASANDVMASKS(i, kvdram, vdata, baseoffset_kvs, offset_kvs);
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITETOBUFFER_VDATAS(bufferoffset_kvs + i, buffer, vdata, 0);	
		
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvswritten(VECTOR_SIZE);
		#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"savevdata:: vertices saved: offset: "<<dramoffset_kvs * VECTOR_SIZE<<"-"<<(dramoffset_kvs + size_kvs) * VECTOR_SIZE<<", number of vertex datas written: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<<endl;
	#endif
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readvdata_slide(bool_type enable, unsigned int s, uint512_dt * kvdram, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs, batch_type bufferoffset_kvs, buffer_type size_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount =  REDUCESZ / 2;
	
	unsigned int index = 0;
	value_t vdata[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=vdata complete
	value_t vdata2[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=vdata2 complete
	unsigned int depths[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=depths complete
	{%for v in context['VECTOR2_SIZE_seq']%}
	keyvalue_t keyvalue{{v}}; keyvalue{{v}}.key = 777; keyvalue{{v}}.value = 777;
	{%endfor%}
	for(unsigned int v=0; v<VECTOR2_SIZE; v++){ vdata[v] = 0; vdata2[v] = 0; }
	unsigned int basedepth = 0;
	
	unsigned int index2 = 0;
	READVDATA_LOOP: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
	#pragma HLS PIPELINE II=1
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_READFROMKVDRAM_VDATASANDVMASKS(i, kvdram, vdata, baseoffset_kvs, offset_kvs);
		
		#if defined(CONFIG_READVDATA_SLIDE)
		MEMACCESS_SPL_GetXYLayoutV(s, vdata, vdata2, depths, basedepth);
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITETOBUFFER_VDATASANDVMASKS(bufferoffset_kvs + i, buffer, vdata2, 0);	
		#elif defined(CONFIG_READVDATA_SLIDEANDREARRANGE)
		unsigned int x = index2 + s;
		basedepth = (x / VECTOR2_SIZE) * VECTOR2_SIZE;
		MEMACCESS_SPL_GetXYLayoutV(x, vdata, vdata2, depths, basedepth);
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITETOBUFFERWITHDEPTHS_VDATASANDVMASKS(depths, buffer, vdata2, 0);	
		index2 += NUM_PEs;
		#else
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITETOBUFFER_VDATASANDVMASKS(bufferoffset_kvs + i, buffer, vdata, 0);	
		#endif
		
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvswritten(VECTOR_SIZE);
		#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"savevdata:: vertices saved: offset: "<<dramoffset_kvs * VECTOR_SIZE<<"-"<<(dramoffset_kvs + size_kvs) * VECTOR_SIZE<<", number of vertex datas written: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<<endl;
	#endif
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readvdatachunks(bool_type enable, uint512_dt * kvdram, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type vbaseoffset_kvs, batch_type voffset_kvs, batch_type vsz_kvs, globalparams_t globalparams){
	unsigned int depth = globalparams.NUM_REDUCEPARTITIONS * globalparams.SIZEKVS2_REDUCEPARTITION;
	unsigned int bdepth = vsz_kvs / 2;
	unsigned int depth_i = 0;
	unsigned int bdepth_i = 0;
	value_t vdata[VECTOR2_SIZE];
	value_t vdata2[VECTOR2_SIZE]; 
	#pragma HLS ARRAY_PARTITION variable=vdata complete
	#pragma HLS ARRAY_PARTITION variable=vdata2 complete
	keyvalue_vbuffer_t tempbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE]; // CRITICAL REMOVEME.
	#pragma HLS array_partition variable = tempbuffer
	
	for(unsigned int s=0; s<NUM_PEs; s++){ 
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<"MEMACCESS_SPL_readvdatachunks:: size loaded @ s("<<s<<"): offset_kvs2: "<<(s * vsz_kvs)<<", sz_kvs2: "<<vsz_kvs<<endl;
		#endif
		MEMACCESS_SPL_readvdata_slide(enable, s, kvdram, tempbuffer, vbaseoffset_kvs, depth_i + voffset_kvs, bdepth_i, vsz_kvs, globalparams); // CRITICAL FIXME.
		depth_i += depth;
		bdepth_i += bdepth;
	}
	
	int limit = 0;
	for(unsigned int v=0; v<VECTOR2_SIZE; v++){ vdata[v] = 0; vdata2[v] = 0; }
	for(unsigned int i=0; i<DOUBLE_BLOCKRAM_SIZE; i++){
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_READFROMBUFFER_VDATASANDVMASKS(i, tempbuffer, vdata, 0);
		#ifdef _DEBUGMODE_KERNELPRINTS3
		if(i<limit){ mydebugobj->printvdata(vdata, 0, i); }
		#endif 
		MEMACCESS_SPL_RearrangeLayoutV(voffset_kvs + i, vdata, vdata2);
		#ifdef _DEBUGMODE_KERNELPRINTS3
		if(i<limit){ mydebugobj->printvdata(vdata2, 1, i); }
		#endif 
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITETOBUFFER_VDATASANDVMASKS(i, buffer, vdata2, 0);
	}
	
	#ifdef _DEBUGMODE_CHECKS
	for(unsigned int i=0; i<64; i++){
		cout<<"buffer row "<<2*i<<": ";
		for(unsigned int v=0; v<VECTOR2_SIZE; v++){
			cout<<buffer[v][i].key<<", ";
		}
		cout<<endl;
		cout<<"buffer row "<<2*i+1<<": ";
		for(unsigned int v=0; v<VECTOR2_SIZE; v++){
			cout<<buffer[v][i].value<<", ";
		}
		cout<<endl;
	}
	cout<<endl;
	#endif
	// exit(EXIT_SUCCESS);
	return;	
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_savevdataandmasks(bool_type enable, uint512_dt * kvdram, keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs, batch_type bufferoffset_kvs, buffer_type size_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount =  REDUCESZ / 2;
	
	unsigned int isfail = 0;
	unsigned int count = 0;
	
	value_t vdatas[VECTOR2_SIZE]; for (unsigned int v=0; v<VECTOR2_SIZE; v++){ vdatas[v] = 0; }
	SAVEVDATAANDMASKS_LOOP: for(buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
	#pragma HLS PIPELINE II=1
	
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_READFROMBUFFER_VDATASANDVMASKS(i, buffer, vdatas, bufferoffset_kvs);
		
		/* unsigned int vdata1;
		unsigned int vdata2;
		unsigned int vmdata1;
		unsigned int vmdata2;
		{%for v in context['VECTOR_SIZE_seq']%}
		vdata1 = UTIL_READBITSFROM_UINTV(vdatas[{{2*v}}], 0, SIZEOF_VDATA0);
		vdata2 = UTIL_READBITSFROM_UINTV(vdatas[{{2*v+1}}], 0, SIZEOF_VDATA0);
		vmdata1 = UTIL_READBITSFROM_UINTV(vdatas[{{2*v}}], SIZEOF_VDATA0, SIZEOF_VMASK0);
		vmdata2 = UTIL_READBITSFROM_UINTV(vdatas[{{2*v+1}}], SIZEOF_VDATA0, SIZEOF_VMASK0);
		if(vdata1 < 64){ cout<<"MEMACCESS_SPL_savevdataandmasks: vdatas[{{2*v}}]: "<<vdata1<<", mask: "<<vmdata1<<""<<endl; isfail = 1; count+=1; }
		if(vdata2 < 64){ cout<<"MEMACCESS_SPL_savevdataandmasks: vdatas[{{2*v+1}}]: "<<vdata2<<", mask: "<<vmdata2<<""<<endl; isfail = 1; count+=1; }
		{%endfor%} */
		
		
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITETOKVDRAM_VDATASANDVMASKS(i, kvdram, vdatas, baseoffset_kvs, offset_kvs);
		
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvswritten(VECTOR_SIZE);
		#endif
	}
	// if(isfail == 1 && count > 64){ exit(EXIT_FAILURE); } ////////////////////////////
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"savevdata:: vertices saved: offset: "<<(offset_kvs) * VECTOR_SIZE<<"-"<<(offset_kvs + size_kvs) * VECTOR_SIZE<<", number of vertex datas written: "<<(size_kvs * VECTOR_SIZE * 2)<<" ("<<size_kvs * VECTOR_SIZE<<" keyvalues written)"<<endl;
	#endif
	return;
}

// -------------------- vmasks -------------------- //
void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_GetXYLayoutVM(unsigned int s, unit1_type vmdata[VECTOR2_SIZE], unit1_type vmdata2[VECTOR2_SIZE], unsigned int depths[VECTOR2_SIZE], unsigned int basedepth){
	unsigned int s_ = s % VECTOR2_SIZE;
	unsigned int depths_tmp[VECTOR2_SIZE];
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<16-1)%}if(s_=={{v}}){%endif%}{
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2<v)%}
		vmdata2[{{v2}}] = vmdata[{{16-v+v2}}]; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2>=v)%}
		vmdata2[{{v2}}] = vmdata[{{v2-v}}]; 
		{%endif%}{%endfor%}
		
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2<v)%}
		depths_tmp[{{v2}}] = {{16-v+v2}}; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2>=v)%}
		depths_tmp[{{v2}}] = {{v2-v}}; 
		{%endif%}{%endfor%}
	}
	{%endfor%}
	
	{%for v in context['VECTOR2_SIZE_seq']%}
	depths[{{v}}] = basedepth + depths_tmp[{{v}}]; 
	{%endfor%} 
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_RearrangeLayoutVM(unsigned int s, unit1_type vmdata[VECTOR2_SIZE], unit1_type vmdata2[VECTOR2_SIZE]){
	unsigned int s_ = s % VECTOR2_SIZE;
	{%for v in context['VECTOR2_SIZE_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<16-1)%}if(s_=={{v}}){%endif%}{ 
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2<v)%}
		vmdata2[{{16-v+v2}}] = vmdata[{{v2}}]; 
		{%endif%}{%endfor%}
		{%for v2 in context['VECTOR2_SIZE_seq']%}{%if(v2>=v)%}
		vmdata2[{{v2-v}}] = vmdata[{{v2}}]; 
		{%endif%}{%endfor%}
	}
	{%endfor%}
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readvmasks_slide(bool_type enable, unsigned int s, uint512_dt * kvdram, unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], keyvalue_vbuffer_t tempbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type baseoffset_kvs, batch_type lbaseoffset_kvs, batch_type offset_kvs, buffer_type bufferoffset, buffer_type size_kvs){			
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount1 = BLOCKRAM_SIZE;
	analysis_type analysis_loopcount2 = BLOCKRAM_SIZE / 16;
	analysis_type analysis_loopcount3 = BLOCKRAM_SIZE;
	
	// vmask is essentially vdata shrinked
	unsigned int rlbaseoffset_kvs = lbaseoffset_kvs / FACTOR_REDUCEPARTITIONSZ_VMASKSZ;
	unsigned int roffset_kvs = offset_kvs / FACTOR_REDUCEPARTITIONSZ_VMASKSZ; // AUTOMATEME. 'FACTOR_REDUCEPARTITIONSZ_VMASKSZ' changes with dataset
	unsigned int rbufferoffset = bufferoffset / FACTOR_REDUCEPARTITIONSZ_VMASKSZ;
	unsigned int rsize_kvs = size_kvs / FACTOR_REDUCEPARTITIONSZ_VMASKSZ; // 32
	
	uint32_type bitsbuffer[BLOCKRAM_SIZE];
	unit1_type vmdata[VMASK_PACKINGSIZE];
	unit1_type vmdata2[VMASK_PACKINGSIZE];
	#pragma HLS ARRAY_PARTITION variable=vmdata complete
	#pragma HLS ARRAY_PARTITION variable=vmdata2 complete
	unsigned int depths[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=depths complete

	// read 
	READVMASKS_LOOP: for (buffer_type i=0; i<rsize_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount1 avg=analysis_loopcount1
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}	
		tempbuffer[{{2*v}}][i] = kvdram[baseoffset_kvs + rlbaseoffset_kvs + roffset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		tempbuffer[{{2*v+1}}][i] = kvdram[baseoffset_kvs + rlbaseoffset_kvs + roffset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}});			
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		tempbuffer[{{v}}][i].key = kvdram[baseoffset_kvs + rlbaseoffset_kvs + roffset_kvs + i].data[{{v}}].key;
		tempbuffer[{{v}}][i].value = kvdram[baseoffset_kvs + rlbaseoffset_kvs + roffset_kvs + i].data[{{v}}].value; 
		{%endfor%}
		#endif 
		#ifdef _DEBUGMODE_CHECKS2
		actsutilityobj->checkoutofbounds("MEMACCESS_SPL_readvmasks_slide:", rlbaseoffset_kvs + roffset_kvs, NUMPROCESSEDGESPARTITIONS * VMASKBUFFERSZ_KVS, baseoffset_kvs, rlbaseoffset_kvs, roffset_kvs);
		#endif
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvsread(VECTOR_SIZE);
		#endif
	}
	
	// u512 => u32s
	buffer_type index = 0;
	LOADVMASKS_LOOP1: for (buffer_type i=0; i<rsize_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount2 avg=analysis_loopcount2
	#pragma HLS PIPELINE II=8
		#ifdef _WIDEWORD
		{%for v in context['VECTOR2_SIZE_seq']%}
		bitsbuffer[index + {{v}}] = tempbuffer[{{v}}][i];
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		bitsbuffer[index + {{2*v}}] = tempbuffer[{{v}}][i].key;
		bitsbuffer[index + {{2*v}} + 1] = tempbuffer[{{v}}][i].value;
		{%endfor%}
		#endif 
		
		index += VECTOR_SIZE * 2;
	}

	// u32 => u16bits
	buffer_type i = 0;
	unsigned int index2 = 0;
	unsigned int basedepth = 0;
	LOADVMASKS_LOOP2: for (i=0; i<size_kvs; i++){ // transfsize, reducebuffersz
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount3 avg=analysis_loopcount3
	#pragma HLS PIPELINE II=2
		#ifdef _WIDEWORD
		if(i%2==0){
			{%for v in context['16_seq']%}
			vmdata[{{v}}] = bitsbuffer[i/2].range({{v}}, {{v}});
			{%endfor%}
		} else {
			{%for v in context['16_seq']%}
			vmdata[{{v}}] = bitsbuffer[i/2].range({{16+v}}, {{16+v}});
			{%endfor%}
		}
		#else 
		if(i%2==0){
			{%for v in context['16_seq']%}
			vmdata[{{v}}] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_READFROM_UINT(bitsbuffer[i/2], {{v}}, 1);
			{%endfor%}
		} else {
			{%for v in context['16_seq']%}
			vmdata[{{v}}] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_READFROM_UINT(bitsbuffer[i/2], {{16+v}}, 1);
			{%endfor%}
		}
		#endif
		
		#if defined(CONFIG_READVDATA_SLIDE)
		MEMACCESS_SPL_GetXYLayoutVM(s, vmdata, vmdata2, depths, basedepth);
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITETOBUFFER_VMASKS(bufferoffset + i, vmaskBITS, vmdata2, 0);
		#elif defined(CONFIG_READVDATA_SLIDEANDREARRANGE)
		unsigned int x = index2 + s;
		basedepth = (x / VECTOR2_SIZE) * VECTOR2_SIZE;
		MEMACCESS_SPL_GetXYLayoutVM(x, vmdata, vmdata2, depths, basedepth);
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITETOBUFFER_VMASKS_WITHDEPTHS(depths, vmaskBITS, vmdata2, 0);
		index2 += NUM_PEs;
		#else
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITETOBUFFER_VMASKS(bufferoffset + i, vmaskBITS, vmdata, 0);
		#endif
	}
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readvmaskschunks(bool_type enable, uint512_dt * kvdram, unit1_type vmaskBITS[VDATA_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], keyvalue_vbuffer_t buffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type basevoffset_kvs, batch_type voffset_kvs, batch_type vsz_kvs, globalparams_t globalparams){				
	unsigned int depth = globalparams.NUM_REDUCEPARTITIONS * globalparams.SIZEKVS2_REDUCEPARTITION;
	unsigned int bdepth = vsz_kvs;
	unsigned int depth_i = 0;
	unsigned int bdepth_i = 0;
	unit1_type vmdata[VECTOR2_SIZE];
	unit1_type vmdata2[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=vmdata complete
	#pragma HLS ARRAY_PARTITION variable=vmdata2 complete
	unit1_type tempvmaskBITS[VDATA_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE]; // CRITICAL REMOVEME.
	#pragma HLS array_partition variable = tempvmaskBITS
	
	for(unsigned int s=0; s<NUM_PEs; s++){
		#ifdef _DEBUGMODE_KERNELPRINTS
		cout<<"MEMACCESS_SPL_readvmaskschunks:: size loaded @ s("<<s<<"): voffset_kvs: "<<voffset_kvs<<", sz: "<<(vsz_kvs * VECTOR2_SIZE)<<endl;
		#endif 
		MEMACCESS_SPL_readvmasks_slide(enable, s, kvdram, tempvmaskBITS, buffer, basevoffset_kvs, depth_i, voffset_kvs, bdepth_i, vsz_kvs); 
		depth_i += depth;
		bdepth_i += bdepth;
	}
	
	int limit = 0;
	for(unsigned int i=0; i<DOUBLE_BLOCKRAM_SIZE; i++){
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_READFROMBUFFER_VMASKS(i, tempvmaskBITS, vmdata, 0);
		#ifdef _DEBUGMODE_KERNELPRINTS3
		if(i<limit){ cout<<"MEMACCESS_SPL_readvmaskschunks:BEFORE:["<<i<<"]: "; for(unsigned int v=0; v<VECTOR2_SIZE; v++){ cout<<vmdata[v]<<", "; } cout<<endl; }
		#endif 
		MEMACCESS_SPL_RearrangeLayoutVM(voffset_kvs + i, vmdata, vmdata2); // CRITICAL FIXME. should be 'voffset + i' instead of just 'i'
		#ifdef _DEBUGMODE_KERNELPRINTS3
		if(i<limit){ cout<<"MEMACCESS_SPL_readvmaskschunks:AFTER:["<<i<<"]: "; for(unsigned int v=0; v<VECTOR2_SIZE; v++){ cout<<vmdata2[v]<<", "; } cout<<endl; }
		#endif 
		{%if(context['XWARE']=="SW")%}mem_convert_and_accessobj->{%endif%}MEMCA_WRITETOBUFFER_VMASKS(i, vmaskBITS, vmdata2, 0);
	}
	
	#ifdef _DEBUGMODE_CHECKS
	for(unsigned int i=0; i<32; i++){
		cout<<"vmask buffer row "<<i<<": ";
		for(unsigned int v=0; v<VECTOR2_SIZE; v++){
			cout<<vmaskBITS[v][i]<<", ";
		}
		cout<<endl;
	}
	cout<<endl;
	#endif
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"+++ MEMACCESS_SPL_readvmaskschunks:: total size (bits) loaded: "<<vsz_kvs * NUM_PEs * VECTOR2_SIZE * 32<<endl;
	#endif
	return;	
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_savemasks(bool_type enable, uint512_dt * kvdram, unit1_type vmaskBITS[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], batch_type baseoffset_kvs, batch_type offset_kvs, unsigned int vmaskp_offset_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"MEMACCESS_SPL_savemasks:: saving vmask saved: offset_kvs: "<<offset_kvs<<", vmaskp_offset_kvs: "<<vmaskp_offset_kvs<<""<<endl;
	#endif
	
	/* ///////////////////////////////////////////////// REMOVEME
	#ifdef _DEBUGMODE_CHECKS2
	for(buffer_type k=0; k<globalparams.SIZEKVS2_REDUCEPARTITION; k+=1){
		{%for v in context['VECTOR2_SIZE_seq']%}
		if(vmaskBITS[{{v}}][k]==1){ mydebugobj->increment(2, globalparams.ALGORITHMINFO_GRAPHITERATIONID, 1); }
		{%endfor%}
	}
	#endif 
	///////////////////////////////////////////////// */
	
	uint32_type tempbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE]; // CRITICAL FIXME. TOO EXPENSIVE...........................
	#pragma HLS array_partition variable = tempbuffer
	uint32_type cummvmask_sp = 0;
	
	unsigned int processpartitionsz = globalparams.SIZEKVS2_PROCESSEDGESPARTITION * VECTOR2_SIZE;
	unsigned int vpmasks_i = 0;
	unsigned int realvid = 0;
	uint32_type vpmasks[BLOCKRAM_SIZE];
	unsigned int index = 0;
	unsigned int next_chpt = processpartitionsz;
	
	SAVEVMASKS_LOOP1: for(buffer_type k=0; k<globalparams.SIZEKVS2_REDUCEPARTITION; k+=2){
	#pragma HLS PIPELINE II=1
		unsigned int X = index % 16;
		unsigned int Y = index / 16;
		
		unsigned int n_i = k;
		unsigned int n_iplus1 = k + 1;
		
		#ifdef _WIDEWORD
		{%for v in context['VECTOR2_SIZE_seq']%}
		tempbuffer[X][Y].range({{v}}, {{v}}) = vmaskBITS[{{v}}][n_i];
		{%endfor%}
		{%for v in context['VECTOR2_SIZE_seq']%}
		tempbuffer[X][Y].range({{16+v}}, {{16+v}}) = vmaskBITS[{{v}}][n_iplus1];
		{%endfor%}
		#else
		{%for v in context['VECTOR2_SIZE_seq']%}
		{%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_WRITETO_UINT(&tempbuffer[X][Y], {{v}}, 1, vmaskBITS[{{v}}][n_i]);
		{%endfor%}
		{%for v in context['VECTOR2_SIZE_seq']%}
		{%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_WRITETO_UINT(&tempbuffer[X][Y], {{16+v}}, 1, vmaskBITS[{{v}}][n_iplus1]);
		{%endfor%}
		#endif
		index += 1;
		
		uint32_type maskA = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_CONVERTVMASKTOUINT32(vmaskBITS, n_i);
		uint32_type maskB = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_CONVERTVMASKTOUINT32(vmaskBITS, n_iplus1);
		cummvmask_sp = cummvmask_sp | maskA | maskB;
		// cout<<"MEMACCESS_SPL_savemasks:: maskA: "<<maskA<<", maskB: "<<maskB<<", cummvmask_sp: "<<cummvmask_sp<<endl;
		
		realvid = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_GETREALVID(((k/2) * 32) + 32, globalparams.ACTSPARAMS_INSTID);
		#ifdef _DEBUGMODE_KERNELPRINTS
		if(realvid >= next_chpt){ cout<<"--- MEMACCESS_SPL_savemasks:: next checkpoint seen @ k: "<<k<<", realvid["<<k/2<<"]: "<<realvid<<", vpmasks_i: "<<vpmasks_i<<", cummvmask_sp: "<<cummvmask_sp<<endl; }
		#endif 
		if(realvid >= next_chpt){ vpmasks[vpmasks_i] = cummvmask_sp; cummvmask_sp = 0; vpmasks_i += 1; next_chpt += processpartitionsz; } // CRITICAL FIXME. TOO EXPENSIVE. CRITICAL FIXME.
	}
	#ifdef _DEBUGMODE_KERNELPRINTS2
	cout<<"--- MEMACCESS_SPL_savemasks:: FINISHED. realvid: "<<realvid<<", vpmasks_i: "<<vpmasks_i<<endl;
	#endif 
	#ifdef _DEBUGMODE_CHECKS3
	if(vpmasks_i != NUM_PEs){ cout<<"--- MEMACCESS_SPL_savemasks:: ERROR: vpmasks_i("<<vpmasks_i<<") != NUM_PEs("<<NUM_PEs<<"). EXITING...."<<endl; exit(EXIT_FAILURE); }
	#endif
	
	SAVEVMASKS_LOOP2: for(buffer_type k=0; k<globalparams.SIZEKVS_VMASKBUFFER; k++){
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
		kvdram[baseoffset_kvs + offset_kvs + k].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = tempbuffer[{{2*v}}][k];
		kvdram[baseoffset_kvs + offset_kvs + k].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = tempbuffer[{{2*v+1}}][k];
		{%endfor%}
		#else
		{%for v in context['VECTOR_SIZE_seq']%}
		kvdram[baseoffset_kvs + offset_kvs + k].data[{{v}}].key = tempbuffer[{{2*v}}][k];
		kvdram[baseoffset_kvs + offset_kvs + k].data[{{v}}].value = tempbuffer[{{2*v+1}}][k];
		{%endfor%}
		#endif
	}
	
	SAVEVMASKS_LOOP3: for(buffer_type n=0; n<NUM_PEs; n++){
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		kvdram[vmaskp_offset_kvs + n]
			#ifdef _WIDEWORD
			.range(31, 0)
			#else
			.data[0].key
			#endif
		= vpmasks[n];
		#endif
	}
	// exit(EXIT_SUCCESS); //////////////
	return;
}

// -------------------- pmasks -------------------- //
void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readpmask(uint512_dt * kvdram, uint32_type vmask_p[BLOCKRAM_SIZE], batch_type offset_kvs, batch_type size_kvs){
	LOADACTIVEPARTITIONS_LOOP: for (buffer_type i=0; i<size_kvs; i++){
		#ifdef _WIDEWORD
		vmask_p[i] = kvdram[offset_kvs + i].range(31, 0);
		#else
		vmask_p[i] = kvdram[offset_kvs + i].data[0].key;
		#endif 
	}
	return;
}

// -------------------- stats -------------------- //
void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readglobalstats(bool_type enable, uint512_dt * kvdram, keyvalue_t globalstatsbuffer[MAX_NUM_PARTITIONS], batch_type offset_kvs, globalparams_t globalparams){ 
	if(enable == OFF){ return; }
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("readglobalstats", offset_kvs + NUM_PARTITIONS, globalparams.BASEOFFSETKVS_STATSDRAM + KVSTATSDRAMSZ_KVS + 1, NAp, NAp, NAp);
	#endif
	
	READGLOBALSTATS_LOOP: for (buffer_type i=0; i<NUM_PARTITIONS; i++){
		#if NUM_EDGE_BANKS==0
			keyvalue_t kv;
			#ifdef _WIDEWORD
			kv.key = kvdram[offset_kvs + i].range(31, 0); 
			kv.value = kvdram[offset_kvs + i].range(63, 32); 
			#else 
			kv.key = kvdram[offset_kvs + i].data[0].key;
			kv.value = kvdram[offset_kvs + i].data[0].value;
			#endif 
			globalstatsbuffer[i] = kv;
		#else 
			uint512_vec_dt vec;
			#ifdef _WIDEWORD
			{%for v in context['VECTOR_SIZE_seq']%}
			vec.data[{{v}}].key = kvdram[offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
			vec.data[{{v}}].value = kvdram[offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
			{%endfor%}
			#else 
			{%for v in context['VECTOR_SIZE_seq']%}
			vec.data[{{v}}].key = kvdram[offset_kvs + i].data[{{v}}].key; 
			vec.data[{{v}}].value = kvdram[offset_kvs + i].data[{{v}}].value; 
			{%endfor%}
			#endif 
			globalstatsbuffer[i] = vec.data[globalparams.VARS_WORKBATCH];
		#endif 
	}
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	actsutilityobj->printkeyvalues("readglobalstats.globalstatsbuffer", globalstatsbuffer, NUM_PARTITIONS); 
	#endif
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_saveglobalstats(bool_type enable, uint512_dt * kvdram, keyvalue_t globalstatsbuffer[MAX_NUM_PARTITIONS], batch_type offset_kvs, globalparams_t globalparams){ 
	if(enable == OFF){ return; }
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("saveglobalstats", offset_kvs + NUM_PARTITIONS, globalparams.BASEOFFSETKVS_STATSDRAM + KVSTATSDRAMSZ_KVS + 1, offset_kvs, NUM_PARTITIONS, KVSTATSDRAMSZ_KVS);
	#endif
	
	SAVEGLOBALSTATS_LOOP: for (buffer_type i=0; i<NUM_PARTITIONS; i++){
		#if NUM_EDGE_BANKS==0
			#ifdef _WIDEWORD
			kvdram[offset_kvs + i].range(31, 0) = globalstatsbuffer[i].key; 
			kvdram[offset_kvs + i].range(63, 32) = globalstatsbuffer[i].value; 
			#else
			kvdram[offset_kvs + i].data[0].key = globalstatsbuffer[i].key; 
			kvdram[offset_kvs + i].data[0].value = globalstatsbuffer[i].value; 
			#endif
		#else
			#ifdef _WIDEWORD
			{%for v in context['8_seq']%}
			{%if(v>0)%}else{%endif%} {%if(v<8-1)%}if(globalparams.VARS_WORKBATCH == {{v}}){%endif%}{
				kvdram[offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = globalstatsbuffer[i].key; 
				kvdram[offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = globalstatsbuffer[i].value; 
			}
			{%endfor%}
			#else 
			{%for v in context['8_seq']%}
			{%if(v>0)%}else{%endif%} {%if(v<8-1)%}if(globalparams.VARS_WORKBATCH == {{v}}){%endif%}{
				kvdram[offset_kvs + i].data[{{v}}].key = globalstatsbuffer[i].key; 
				kvdram[offset_kvs + i].data[{{v}}].value = globalstatsbuffer[i].value; 
			}
			{%endfor%}
			#endif
		#endif 

		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalvar_savestats_counttotalstatswritten(VECTOR_SIZE);
		#endif
	}
	
	#ifdef _DEBUGMODE_KERNELPRINTS2
	actsutilityobj->printkeyvalues("MEMACCESS_SPL_saveglobalstats.globalstatsbuffer", globalstatsbuffer, NUM_PARTITIONS); 
	#endif
	return;
}

tuple_t {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_getvptrs({%for n in context['NUM_EDGE_BANKS_seq']%}uint512_dt * edges{{n}},{%endfor%} uint512_dt * kvdram, unsigned int beginoffset, unsigned int endoffset, unsigned int edgebankID){
	#pragma HLS INLINE
	
	keyy_t beginvptr = 0;
	keyy_t endvptr = 0;
	
	#if NUM_EDGE_BANKS==0
		#ifdef _WIDEWORD
		beginvptr = kvdram[beginoffset].range(31, 0);
		endvptr = kvdram[endoffset].range(31, 0); 
		#else 
		beginvptr = kvdram[beginoffset].data[0].key;
		endvptr = kvdram[endoffset].data[0].key;
		#endif 
	#else
		if(edgebankID == 0){
			#ifdef _WIDEWORD
			beginvptr = edges0[beginoffset].range(31, 0);
			endvptr = edges0[endoffset].range(31, 0); 
			#else 
			beginvptr = edges0[beginoffset].data[0].key;
			endvptr = edges0[endoffset].data[0].key;
			#endif 
		} 
		#if NUM_EDGE_BANKS>1
		else if(edgebankID == 1){
			#ifdef _WIDEWORD
			beginvptr = edges1[beginoffset].range(31, 0);
			endvptr = edges1[endoffset].range(31, 0); 
			#else 
			beginvptr = edges1[beginoffset].data[0].key;
			endvptr = edges1[endoffset].data[0].key;
			#endif 
		} 
		#if NUM_EDGE_BANKS>2
		else if(edgebankID == 2){
			#ifdef _WIDEWORD
			beginvptr = edges2[beginoffset].range(31, 0);
			endvptr = edges2[endoffset].range(31, 0); 
			#else 
			beginvptr = edges2[beginoffset].data[0].key;
			endvptr = edges2[endoffset].data[0].key;
			#endif 
		} 
		#if NUM_EDGE_BANKS>3
		else if(edgebankID == 3){
			#ifdef _WIDEWORD
			beginvptr = edges3[beginoffset].range(31, 0);
			endvptr = edges3[endoffset].range(31, 0); 
			#else 
			beginvptr = edges3[beginoffset].data[0].key;
			endvptr = edges3[endoffset].data[0].key;
			#endif 
		} 
		#if NUM_EDGE_BANKS>4
		else if(edgebankID == 4){
			#ifdef _WIDEWORD
			beginvptr = edges4[beginoffset].range(31, 0);
			endvptr = edges4[endoffset].range(31, 0); 
			#else 
			beginvptr = edges4[beginoffset].data[0].key;
			endvptr = edges4[endoffset].data[0].key;
			#endif 
		} 
		#if NUM_EDGE_BANKS>5
		else if(edgebankID == 5){
			#ifdef _WIDEWORD
			beginvptr = edges5[beginoffset].range(31, 0);
			endvptr = edges5[endoffset].range(31, 0); 
			#else 
			beginvptr = edges5[beginoffset].data[0].key;
			endvptr = edges5[endoffset].data[0].key;
			#endif 
		} 
		#if NUM_EDGE_BANKS>6
		else if(edgebankID == 6){
			#ifdef _WIDEWORD
			beginvptr = edges6[beginoffset].range(31, 0);
			endvptr = edges6[endoffset].range(31, 0); 
			#else 
			beginvptr = edges6[beginoffset].data[0].key;
			endvptr = edges6[endoffset].data[0].key;
			#endif 
		}
		#if NUM_EDGE_BANKS>7
		else if(edgebankID == 7){
			#ifdef _WIDEWORD
			beginvptr = edges7[beginoffset].range(31, 0);
			endvptr = edges7[endoffset].range(31, 0); 
			#else 
			beginvptr = edges7[beginoffset].data[0].key;
			endvptr = edges7[endoffset].data[0].key;
			#endif 
		}
	#endif
	#endif 
	#endif 
	#endif 
	#endif
	#endif 
	#endif
	else {
		#ifdef _WIDEWORD 
		beginvptr = NAp; 
		endvptr = NAp; 
		#else 
		beginvptr = NAp;
		endvptr = NAp;
		#endif 
	}
	#endif 

	tuple_t t; t.A = beginvptr; t.B = endvptr;
	return t;
}

unsigned int {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_getvptr(uint512_dt * kvdram, unsigned int baseoffset_kvs, unsigned int offset){
	keyvalue_t vptr_kv;
	
	uint512_dt V = kvdram[baseoffset_kvs + (offset / 16)];
	unsigned int M = (offset % 16) / 2;
	
	#ifdef _WIDEWORD
	{%for v in context['8_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<8-1)%}if(M == {{v}}){%endif%}{
		vptr_kv.key = V.range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		vptr_kv.value = V.range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
	}
	{%endfor%}
	#else 
	{%for v in context['8_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<8-1)%}if(M == {{v}}){%endif%}{
		vptr_kv.key = V.data[{{v}}].key; 
		vptr_kv.value = V.data[{{v}}].value; 
	}
	{%endfor%}
	#endif
	
	if(offset % 2 == 0){ return vptr_kv.key; }
	else { return vptr_kv.value; }
}

tuple_t {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_getvptrs_opt({%for n in context['NUM_EDGE_BANKS_seq']%}uint512_dt * edges{{n}},{%endfor%} uint512_dt * kvdram, unsigned int baseoffset_kvs, unsigned int beginoffset, unsigned int endoffset, unsigned int edgebankID){
	#pragma HLS INLINE
	keyy_t beginvptr = 0;
	keyy_t endvptr = 0;
	
	beginoffset = beginoffset / VPTR_SHRINK_RATIO; // convert-to-appropriate-skip-format
	endoffset = endoffset / VPTR_SHRINK_RATIO;
	
	#if NUM_EDGE_BANKS==0
		beginvptr = MEMACCESS_SPL_getvptr(kvdram, baseoffset_kvs, beginoffset);
		endvptr = MEMACCESS_SPL_getvptr(kvdram, baseoffset_kvs, endoffset);
	#else
		if(edgebankID == 0){
			beginvptr = MEMACCESS_SPL_getvptr(edges0, baseoffset_kvs, beginoffset);
			endvptr = MEMACCESS_SPL_getvptr(edges0, baseoffset_kvs, endoffset);
		} 
		#if NUM_EDGE_BANKS>1
		else if(edgebankID == 1){
			beginvptr = MEMACCESS_SPL_getvptr(edges1, baseoffset_kvs, beginoffset);
			endvptr = MEMACCESS_SPL_getvptr(edges1, baseoffset_kvs, endoffset);
		} 
		#if NUM_EDGE_BANKS>2
		else if(edgebankID == 2){
			beginvptr = MEMACCESS_SPL_getvptr(edges2, baseoffset_kvs, beginoffset);
			endvptr = MEMACCESS_SPL_getvptr(edges2, baseoffset_kvs, endoffset);
		} 
		#if NUM_EDGE_BANKS>3
		else if(edgebankID == 3){
			beginvptr = MEMACCESS_SPL_getvptr(edges3, baseoffset_kvs, beginoffset);
			endvptr = MEMACCESS_SPL_getvptr(edges3, baseoffset_kvs, endoffset);
		} 
		#if NUM_EDGE_BANKS>4
		else if(edgebankID == 4){
			beginvptr = MEMACCESS_SPL_getvptr(edges4, baseoffset_kvs, beginoffset);
			endvptr = MEMACCESS_SPL_getvptr(edges4, baseoffset_kvs, endoffset);
		} 
		#if NUM_EDGE_BANKS>5
		else if(edgebankID == 5){
			beginvptr = MEMACCESS_SPL_getvptr(edges5, baseoffset_kvs, beginoffset);
			endvptr = MEMACCESS_SPL_getvptr(edges5, baseoffset_kvs, endoffset);
		} 
		#if NUM_EDGE_BANKS>6
		else if(edgebankID == 6){
			beginvptr = MEMACCESS_SPL_getvptr(edges6, baseoffset_kvs, beginoffset);
			endvptr = MEMACCESS_SPL_getvptr(edges6, baseoffset_kvs, endoffset);
		}
		#if NUM_EDGE_BANKS>7
		else if(edgebankID == 7){
			beginvptr = MEMACCESS_SPL_getvptr(edges7, baseoffset_kvs, beginoffset);
			endvptr = MEMACCESS_SPL_getvptr(edges7, baseoffset_kvs, endoffset);
		}
	#endif
	#endif 
	#endif 
	#endif 
	#endif
	#endif 
	#endif
	else {
		#ifdef _WIDEWORD 
		beginvptr = NAp; 
		endvptr = NAp; 
		#else 
		beginvptr = NAp;
		endvptr = NAp;
		#endif 
	}
	#endif 

	tuple_t t; t.A = beginvptr; t.B = endvptr;
	return t;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_copystats(uint512_dt * edges, uint512_dt * kvdram, globalparams_t globalparamsE, globalparams_t globalparamsK){
	analysis_type analysis_treedepth = TREE_DEPTH;
	analysis_type analysis_loop1 = 1;
	
	COPYSTATS_LOOP1: for(unsigned int k=0; k<globalparamsK.SIZE_KVSTATSDRAM; k++){
	#pragma HLS PIPELINE II=1
		kvdram[globalparamsK.BASEOFFSETKVS_STATSDRAM + k] = edges[globalparamsE.BASEOFFSETKVS_STATSDRAM + k];
	}
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_copyallstats({%for n in context['NUM_EDGE_BANKS_seq']%}uint512_dt * edges{{n}},{%endfor%} uint512_dt * kvdram, globalparams_t globalparamsE, globalparams_t globalparamsK, unsigned int edgebankID){
	analysis_type analysis_treedepth = TREE_DEPTH;
	analysis_type analysis_loop1 = 1;

	{%for n in context['NUM_EDGE_BANKS_seq']%}
	if(edgebankID == {{n}}){
		COPYSTATS_LOOP{{n}}: for(unsigned int k=0; k<globalparamsK.SIZE_KVSTATSDRAM; k++){
		#pragma HLS PIPELINE II=1
			kvdram[globalparamsK.BASEOFFSETKVS_STATSDRAM + k] = edges{{n}}[globalparamsE.BASEOFFSETKVS_STATSDRAM + k];
		}
	}
	{%endfor%}
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_commitkvstats(uint512_dt * kvdram, value_t * buffer, globalparams_t globalparams, unsigned int offset){
	unsigned int totalnumpartitionsb4last = 0;
	RETRIEVEKVSTATS_LOOP1: for(unsigned int k=0; k<globalparams.ACTSPARAMS_TREEDEPTH; k++){ totalnumpartitionsb4last += (1 << (NUM_PARTITIONS_POW * k)); }
	for(unsigned int k=0; k<totalnumpartitionsb4last; k++){
		#ifdef _WIDEWORD
		kvdram[globalparams.BASEOFFSETKVS_STATSDRAM + offset + k].range(63, 32) = buffer[k]; 
		#else
		kvdram[globalparams.BASEOFFSETKVS_STATSDRAM + offset  + k].data[0].value = buffer[k]; 
		#endif
	}
	
	#ifdef _WIDEWORD
	kvdram[BASEOFFSET_MESSAGESDATA_KVS + MESSAGES_ALGORITHMINFO_GRAPHITERATIONID].range(31, 0) = globalparams.ALGORITHMINFO_GRAPHITERATIONID + 1; // CRITICAL NOTEME: Graph Iteration is incremented here
	#else
	kvdram[BASEOFFSET_MESSAGESDATA_KVS + MESSAGES_ALGORITHMINFO_GRAPHITERATIONID].data[0].key = globalparams.ALGORITHMINFO_GRAPHITERATIONID + 1;
	#endif 
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_commitkvstats2(uint512_dt * kvdram, value_t * buffer, globalparams_t globalparams, unsigned int offset, unsigned int size){
	for(unsigned int k=0; k<size; k++){
		#ifdef _WIDEWORD
		kvdram[globalparams.BASEOFFSETKVS_STATSDRAM + offset + k].range(63, 32) = buffer[k]; 
		#else
		kvdram[globalparams.BASEOFFSETKVS_STATSDRAM + offset  + k].data[0].value = buffer[k]; 
		#endif
	}
	return;
}

void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_retreievekvstats(uint512_dt * kvdram, value_t * buffer, globalparams_t globalparams, unsigned int offset, unsigned int size){
	for(unsigned int k=0; k<size; k++){
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		buffer[k] = kvdram[globalparams.BASEOFFSETKVS_STATSDRAM + offset + k].range(63, 32); 
		#else
		buffer[k] = kvdram[globalparams.BASEOFFSETKVS_STATSDRAM + offset + k].data[0].value; 
		#endif
	}
}

////
{%for n in context['T_seq']%}
{%if(n>=1)%}
void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readmanyvmasks{{n}}(bool_type enable, uint512_dt * kvdram, {%for i in context['T_seq']%}{%if(i<n)%}unit1_type vmaskBITS{{i}}[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE],{%endif%}{%endfor%} keyvalue_vbuffer_t tempbuffer[VDATA_PACKINGSIZE][BLOCKRAM_SIZE], batch_type offset_kvs, buffer_type size_kvs, globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount1 = BLOCKRAM_SIZE;
	analysis_type analysis_loopcount2 = BLOCKRAM_SIZE / 16;
	analysis_type analysis_loopcount3 = BLOCKRAM_SIZE;
	
	buffer_type transfsize = size_kvs * 16;
	uint32_type bitsbuffer[MAXREDUCEBUFFERSZ];

	READVMASKS_LOOP: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount1 avg=analysis_loopcount1
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		{%for v in context['8_seq']%}
		tempbuffer[{{2*v}}][i] = kvdram[offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		tempbuffer[{{2*v+1}}][i] = kvdram[offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		tempbuffer[{{v}}][i].key = kvdram[offset_kvs + i].data[{{v}}].key;
		tempbuffer[{{v}}][i].value = kvdram[offset_kvs + i].data[{{v}}].value; 
		{%endfor%}
		
		#endif 
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvsread(VECTOR_SIZE);
		#endif
	}
	
	{%for v in context['16_seq']%}
	uint32_type D{{v}};
	{%endfor%}
	buffer_type index = 0;
	LOADVMASKS_LOOP1: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount2 avg=analysis_loopcount2
	#pragma HLS PIPELINE II=8
		#ifdef _WIDEWORD
		{%for v in context['16_seq']%}
		bitsbuffer[index + {{v}}] = tempbuffer[{{v}}][i];
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		bitsbuffer[index + {{2*v}}] = tempbuffer[{{v}}][i].key;
		bitsbuffer[index + {{2*v + 1}}] = tempbuffer[{{v}}][i].value;
		{%endfor%}
		#endif
		
		index += VECTOR_SIZE * 2;
	}

	// u32 => u16bits	
	buffer_type index2 = 0;
	LOADVMASKS_LOOP2: for (buffer_type i=0; i<transfsize; i++){ // transfsize, reducebuffersz
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount3 avg=analysis_loopcount3
	#pragma HLS PIPELINE II=1
		{%for i in context['T_seq']%}
		{%if(i<n)%}
		#ifdef _WIDEWORD
		{%for v in context['16_seq']%}
		vmaskBITS{{i}}[{{v}}][index2] = bitsbuffer[i].range({{v}}, {{v}});
		{%endfor%}
		{%for v in context['16_seq']%}
		vmaskBITS{{i}}[{{v}}][index2 + 1] = bitsbuffer[i].range({{16+v}}, {{16+v}});
		{%endfor%}
		#else 
		{%for v in context['16_seq']%}
		vmaskBITS{{i}}[{{v}}][index2] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_READFROM_UINT(bitsbuffer[i], {{v}}, 1);
		{%endfor%}
		{%for v in context['16_seq']%}
		vmaskBITS{{i}}[{{v}}][index2 + 1] = {%if(context['XWARE']=="SW")%}acts_utilobj->{%endif%}UTIL_READFROM_UINT(bitsbuffer[i], {{16+v}}, 1);
		{%endfor%}
		#endif
		{%endif%}
		{%endfor%}
		
		index2 += 2;
	}
	return;
}
{%endif%}
{%endfor%}

{%for n in context['T_seq']%}
{%if(n>=1)%}
void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readmanyspmask{{n}}(bool_type enable, unit1_type vmask0[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE], {%for i in context['T_seq']%}{%if(i<n)%}unit1_type vmask{{i}}_subp[VMASK_PACKINGSIZE][DOUBLE_BLOCKRAM_SIZE],{%endif%}{%endfor%} buffer_type size_kvs){
	
	#ifdef NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNOTIMPLEMENTED // FIXME. NOT IMPLEMENTED.
	
	if(enable == OFF){ return; }
	analysis_type analysis_loopcount1 = BLOCKRAM_SIZE;
	analysis_type analysis_loopcount2 = BLOCKRAM_SIZE / 16;
	analysis_type analysis_loopcount3 = BLOCKRAM_SIZE;
	
	buffer_type transfsize = size_kvs * 16;

	unitBRAMwidth_type tempvmask;
	#pragma HLS DATA_PACK variable = tempvmask	
	unitBRAMwidth_type tempvSUBmask;
	#pragma HLS DATA_PACK variable = tempvSUBmask		
	{%for v in context['16_seq']%}
	tempvSUBmask.data[{{v}}].key = 0;
	tempvSUBmask.data[{{v}}].value = 0;
	{%endfor%}
	LOADVMASKSSUBP_LOOP2: for (buffer_type i=0; i<transfsize; i++){ // transfsize, reducebuffersz
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount3 avg=analysis_loopcount3
	#pragma HLS PIPELINE II=2
		
		tempvmask = vmask0[i];
		
		// subp mask 
		#ifdef ENABLE_SUBVMASKING
		{%for v in context['16_seq']%}
		tempvSUBmask.data[{{v}}].key = tempvSUBmask.data[{{v}}].key | tempvmask.data[{{v}}].key;
		tempvSUBmask.data[{{v}}].value = tempvSUBmask.data[{{v}}].value | tempvmask.data[{{v}}].value;
		{%endfor%}
		
		if(i % 8 == 7){ // CRITICAL AUTOMATEME.
			{%for i in context['T_seq']%}
			{%if(i<n)%}
			if(i%16==7){  // CRITICAL AUTOMATEME.
				{%for v in context['16_seq']%}
				vmask{{i}}_subp[i/16].data[{{v}}].key = tempvSUBmask.data[{{v}}].key | tempvSUBmask.data[{{v}}].value; 
				{%endfor%}
			} else {
				{%for v in context['16_seq']%}
				vmask{{i}}_subp[i/16].data[{{v}}].value = tempvSUBmask.data[{{v}}].key | tempvSUBmask.data[{{v}}].value; 
				{%endfor%}
			}
			{%endif%}
			{%endfor%}
			
			{%for v in context['16_seq']%}
			tempvSUBmask.data[{{v}}].key = 0;
			tempvSUBmask.data[{{v}}].value = 0;
			{%endfor%}
		}
		#endif 
	}
	
	#endif 
	return;
}
{%endif%}
{%endfor%}

{%for n in context['T_seq']%}
{%if(n>=1)%}
void {{context['classname__mem_access_splitdstvxs']}}MEMACCESS_SPL_readmanypmask{{n}}(uint512_dt * kvdram, {%for i in context['T_seq']%}{%if(i<n)%}uint32_type vmask{{i}}_p[BLOCKRAM_SIZE],{%endif%}{%endfor%} batch_type offset_kvs, batch_type size_kvs){
	LOADACTIVEPARTITIONS_LOOP: for (buffer_type i=0; i<size_kvs; i++){
		#ifdef _WIDEWORD
		{%for i in context['T_seq']%}
		{%if(i<n)%}
		vmask{{i}}_p[i] = kvdram[offset_kvs + i].range(31, 0);
		{%endif%}
		{%endfor%}
		#else
		{%for i in context['T_seq']%}
		{%if(i<n)%}
		vmask{{i}}_p[i] = kvdram[offset_kvs + i].data[0].key;
		{%endif%}
		{%endfor%}
		#endif 
	}
	return;
}
{%endif%}
{%endfor%}




