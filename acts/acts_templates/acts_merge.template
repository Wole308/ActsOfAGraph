#include "acts_merge.h"
using namespace std;

#ifdef SW
acts_merge::acts_merge(){ 
	actsutilityobj = new actsutility(); 
	acts_utilobj = new acts_util(); 
	processedges_unslicedgraphobj = new processedges_unslicedgraph();
	processedges_slicedgraphobj = new processedges_slicedgraph();
	partitionupdatesobj = new partitionupdates();
	reduceupdatesobj = new reduceupdates();
	mem_accessobj = new mem_access();
	actsobj = new acts();
	mergeobj = new merge_vtxs();
}
acts_merge::~acts_merge(){}
#endif

value_t 
	#ifdef SW 
	acts_merge::
	#endif 
MERGE_applyfunc(value_t vtemp, value_t res, unsigned int GraphIter, unsigned int GraphAlgo){
	value_t temp = 0;
	if(GraphAlgo == PAGERANK){
		// temp = vtemp + res;
		// temp = 0.5 + (1 - 0.5)*res / vdeg; // IDEAL
		temp = res;
	} else if(GraphAlgo == BFS){
		temp = res;
	} else if(GraphAlgo == SSSP){
		temp = acts_utilobj->UTIL_amin(vtemp, res);
	} else {
		temp = NAp;
	}
	return temp;
}

void // 
	#ifdef SW 
	acts_merge::
	#endif 
MERGE_readvdata(bool_type enable1, uint512_dt * kvdram, batch_type dramoffset_kvs, keyvalue_vbuffer_t buffer[VECTOR_SIZE][BLOCKRAM_SIZE], batch_type bufferoffset_kvs, buffer_type size_kvs){
	#pragma HLS function_instantiate variable=kvdram
	if(enable1 == OFF){ return; }
	analysis_type analysis_loopcount = BLOCKRAM_SIZE;
		
	READVDATA_LOOP: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
	#pragma HLS PIPELINE II=1
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t mykeyvalue{{v}};
		{%endfor%}
		
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
		mykeyvalue{{v}}.key = kvdram[dramoffset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}); 
		mykeyvalue{{v}}.value = kvdram[dramoffset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}); 
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		mykeyvalue{{v}}.key = kvdram[dramoffset_kvs + i].data[{{v}}].key; 
		mykeyvalue{{v}}.value = kvdram[dramoffset_kvs + i].data[{{v}}].value; 
		{%endfor%}
		#endif
		
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer[{{v}}][bufferoffset_kvs + i] = acts_utilobj->UTIL_GETKV2(mykeyvalue{{v}});
		{%endfor%}
		
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvsread(VECTOR_SIZE);
		#endif
	}
	return;
}

void // 
	#ifdef SW 
	acts_merge::
	#endif 
MERGE_writevdata(bool_type enable1, uint512_dt * kvdram, batch_type basedramoffset_kvs, batch_type localdramoffset_kvs, keyvalue_vbuffer_t buffer[VECTOR_SIZE][BLOCKRAM_SIZE], batch_type bufferoffset_kvs, buffer_type size_kvs){
	#pragma HLS function_instantiate variable=kvdram
	if(enable1 == OFF){ return; }
	analysis_type analysis_loopcount = BLOCKRAM_SIZE;
	unsigned int dramoffset_kvs = basedramoffset_kvs + localdramoffset_kvs;

	WRITEVDATA_LOOP: for (buffer_type i=0; i<size_kvs; i++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
		#pragma HLS PIPELINE II=1
			{%for v in context['VECTOR_SIZE_seq']%}
			keyvalue_t keyvalue{{v}} = acts_utilobj->UTIL_GETKV2(buffer[{{v}}][i]); 
			{%endfor%}
			
			#ifdef _WIDEWORD
			{%for v in context['VECTOR_SIZE_seq']%}
			kvdram[dramoffset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = keyvalue{{v}}.key;
			kvdram[dramoffset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = keyvalue{{v}}.value;
			{%endfor%}
			#else
			{%for v in context['VECTOR_SIZE_seq']%}
			kvdram[dramoffset_kvs + i].data[{{v}}].key = keyvalue{{v}}.key; 
			kvdram[dramoffset_kvs + i].data[{{v}}].value = keyvalue{{v}}.value;
			{%endfor%}
			#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<">>> ACTS MERGE: MERGE_writevdata: data written at: dramoffset: "<<localdramoffset_kvs*VECTOR2_SIZE<<", dramoffset_kvs: "<<localdramoffset_kvs<<", size_kvs: "<<size_kvs<<endl;
	#endif
	return;
}

{%for n in context['T_seq']%}
{%if(n>=1)%}
void
	#ifdef SW 
	acts_merge::
	#endif
MERGE_merge{{n}}({%for i in context['T_seq']%}{%if(i<n)%}uint512_dt * kvdram{{i}},{%endif%}{%endfor%} uint512_dt * vdram){
	#pragma HLS INLINE
	
	#if defined(_DEBUGMODE_KERNELPRINTS2)
	cout<<">>> ====================== ACTS MERGE Launched... size: "<<SYNC_GETKEYENTRY(kvdram0[BASEOFFSET_MESSAGESDATA_KVS + MESSAGES_SIZE_RUN], 0)<<endl; 
	#endif
	
	globalparams_t globalparams = acts_utilobj->UTIL_getglobalparams(kvdram0);
	globalparams_t globalparamsv = acts_utilobj->UTIL_getglobalparams(vdram);
	batch_type num_source_partitions = acts_utilobj->UTIL_get_num_source_partitions(globalparams.ACTSPARAMS_TREEDEPTH);
	
	buffer_type reducebuffersz = globalparams.SIZE_REDUCE / 2;
	
	{%for i in context['T_seq']%}
	{%if(i<n)%}
	keyvalue_vbuffer_t vbuffer{{i}}[VECTOR_SIZE][BLOCKRAM_SIZE];
	#pragma HLS array_partition variable = vbuffer{{i}}
	{%endif%}
	{%endfor%}
	
	keyvalue_vbuffer_t mergedv_buffer[VECTOR_SIZE][BLOCKRAM_SIZE];
	#pragma HLS array_partition variable = mergedv_buffer
	
	travstate_t rtravstates[{{n}}];
	#pragma HLS ARRAY_PARTITION variable=rtravstates complete
	
	value_t buffer[DOUBLE_BLOCKRAM_SIZE];
	for(unsigned int i=0; i<DOUBLE_BLOCKRAM_SIZE; i++){ buffer[i] = 0; } 
	
	#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
	keyvalue_vbuffer_t refbuffer[VECTOR_SIZE][BLOCKRAM_SIZE];
	#pragma HLS array_partition variable = refbuffer
	#endif 
	
	unsigned int sourcestatsmarker = 0;
	#ifdef ENABLERECURSIVEPARTITIONING
	for(unsigned int k=0; k<_globalparams.ACTSPARAMS_TREEDEPTH-1; k++){ sourcestatsmarker += (1 << (NUM_PARTITIONS_POW * k)); }
	#else 
	for(unsigned int k=0; k<_globalparams.ACTSPARAMS_TREEDEPTH; k++){ sourcestatsmarker += (1 << (NUM_PARTITIONS_POW * k)); }
	#endif
	
	unsigned int _MERGECHUNKSZ = reducebuffersz / {{n}}; // SIMPLIFYME.
	unsigned int _MERGECHUNKSCOUNT = {{n}}; // FIXME. edge-condition // (reducebuffersz + (_MERGECHUNKSZ-1)) / _MERGECHUNKSZ;
	unsigned int total_num_blocks = 16 * 2; //  (globalparams.SIZE_BATCHRANGE / 16) / reducebuffersz; // SIMPLIFYME. CRITICAL AUTOMATEME.

	TOPKERNELMERGE_MAINLOOP: for(batch_type iterationidx=0; iterationidx<total_num_blocks; iterationidx+=1){
		unsigned int vreadoffset_kvs = iterationidx * reducebuffersz;
		unsigned int vwriteoffset_kvs = iterationidx * reducebuffersz * {{n}};
		unsigned int vwritebufferoffset_kvs = 0;
		unsigned int partition = iterationidx / 2;
		#ifdef _DEBUGMODE_KERNELPRINTS3
		cout<<">>> ACTS MERGE: merge iterationidx started: "<<iterationidx<<" (of "<<total_num_blocks<<" total blocks), [vreadoffset: "<<vreadoffset_kvs * VECTOR2_SIZE<<", vwriteoffset: "<<vwriteoffset_kvs * VECTOR2_SIZE<<"]"<<endl;
		#endif
		
		unsigned int mv_index = 0;
		unsigned int v_index = 0;
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t udata{{v}};
		keyvalue_t vdata{{v}};
		keyvalue_t res{{v}};
		{%endfor%}
		
		// skipping logic 
		bool_type enablemerge = OFF; 
		unsigned int ntravszs = 0;
		{%for i in context['T_seq']%}
		{%if(i<n)%}
		rtravstates[{{i}}] = acts_utilobj->UTIL_gettravstate(ON, kvdram{{i}}, globalparams, globalparams.ACTSPARAMS_TREEDEPTH, iterationidx/2); // CRITICAL NOTEME. POSSIBLE SOURCE OF ROUTING CONSTRAINTS?
		{%endif%}
		{%endfor%}
		for(unsigned int i = 0; i < {{n}}; i++){ ntravszs += rtravstates[i].size_kvs; }
		if(ntravszs > 0){ enablemerge = ON; } else { enablemerge = OFF; }
		cout<<"---- acts_merge:: printing rtravstates "<<endl; for(unsigned int i = 0; i < {{n}}; i++){ cout<<rtravstates[i].size_kvs<<", "; } cout<<endl;
		if(enablemerge == ON){ cout<<"---- acts_merge:: iterationidx: "<<iterationidx<<", partition: "<<partition<<", enablemerge: "<<enablemerge<<", ntravszs: "<<ntravszs<<endl; }
		continue; /////////////
		
		{%for i in context['T_seq']%}
		{%if(i<n)%}
		MERGE_readvdata(enablemerge, kvdram{{i}}, globalparams.BASEOFFSETKVS_DESTVERTICESDATA + vreadoffset_kvs, vbuffer{{i}}, 0, reducebuffersz);
		{%endif%}
		{%endfor%}
		#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
		MERGE_readvdata(enablemerge, vdram, globalparamsv.BASEOFFSETKVS_DESTVERTICESDATA + vwriteoffset_kvs, refbuffer, 0, reducebuffersz);
		#endif 
		
		if(enablemerge==ON){
			for(unsigned int i=0; i<_MERGECHUNKSCOUNT; i++){ // _MERGECHUNKSCOUNT
				for(unsigned int k=0; k<_MERGECHUNKSZ; k++){ // _MERGECHUNKSZ. FIXME. edge-condition
				#pragma HLS PIPELINE II=1
					{%for i in context['T_seq']%}
					{%if(i<n)%}
						{%for v in context['VECTOR_SIZE_seq']%}
						vdata{{v}} = acts_utilobj->UTIL_GETKV2(vbuffer{{i}}[{{v}}][v_index + k]);
						mergedv_buffer[{{v}}][mv_index] = acts_utilobj->UTIL_GETKV2(vdata{{v}});
						
						#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
						udata{{v}} = acts_utilobj->UTIL_GETKV2(refbuffer[{{v}}][mv_index]);
						res{{v}}.key = MERGE_applyfunc(udata{{v}}.key, vdata{{v}}.key, globalparams.ALGORITHMINFO_GRAPHITERATIONID, globalparams.ALGORITHMINFO_GRAPHALGORITHMID);
						res{{v}}.value = MERGE_applyfunc(udata{{v}}.value, vdata{{v}}.value, globalparams.ALGORITHMINFO_GRAPHITERATIONID, globalparams.ALGORITHMINFO_GRAPHALGORITHMID);
						if(res{{v}}.key != udata{{v}}.key){ cout<<"acts_merge::ACTIVE VTX SEEN(1) @ (vid: "<<(vwriteoffset_kvs+vwritebufferoffset_kvs)*VECTOR_SIZE*2 + ({{v}}*globalparams.SIZE_REDUCE) + 2*mv_index<<", vbuffer{{i}}[{{v}}]["<<v_index + k<<"].key: "<<vbuffer{{i}}[{{v}}][v_index + k].key<<", refbuffer[{{v}}]["<<mv_index<<"].key: "<<refbuffer[{{v}}][mv_index].key<<endl; }
						if(res{{v}}.value != udata{{v}}.value){ cout<<"acts_merge::ACTIVE VTX SEEN(1) @ (vid: "<<(vwriteoffset_kvs+vwritebufferoffset_kvs)*VECTOR_SIZE*2 + ({{v}}*globalparams.SIZE_REDUCE) + 2*mv_index + 1<<", vbuffer{{i}}[{{v}}]["<<v_index + k<<"].value: "<<vbuffer{{i}}[{{v}}][v_index + k].value<<", refbuffer[{{v}}]["<<mv_index<<"].value: "<<refbuffer[{{v}}][mv_index].value<<endl; }					
						#endif
						{%endfor%}
						#ifdef _DEBUGMODE_KERNELPRINTS
						cout<<">>> ACTS MERGE: i: "<<i<<", mv_index: "<<mv_index<<", v_index: "<<v_index + k<<", _MERGECHUNKSCOUNT: "<<_MERGECHUNKSCOUNT<<", _MERGECHUNKSZ: "<<_MERGECHUNKSZ<<endl;
						#endif 
					mv_index += 1;
					{%endif%}
					{%endfor%}
				}
				
				v_index += _MERGECHUNKSZ;
				MERGE_writevdata(enablemerge, vdram, globalparamsv.BASEOFFSETKVS_SRCVERTICESDATA, vwriteoffset_kvs + vwritebufferoffset_kvs, mergedv_buffer, 0, mv_index);
				vwritebufferoffset_kvs += mv_index;
				mv_index = 0;
			}
		}
		// exit(EXIT_SUCCESS); //
		
		// skipping logic (update stats)
		if(enablemerge == ON){ buffer[partition] += 64; } else { buffer[partition] += 0; }
	}
	exit(EXIT_SUCCESS);
	return;
}
{%endif%}
{%endfor%}
