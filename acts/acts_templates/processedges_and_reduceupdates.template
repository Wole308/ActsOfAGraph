value_t {{context['classname__processedges_and_reduceupdates']}}PANDR{{context['id']}}_processfunc(value_t udata, value_t edgew, unsigned int GraphAlgo){
	value_t res = 0;
	#ifdef CUSTOMLOGICFOREACHALGORITHM
		#if defined(PR_ALGORITHM)
			res = udata + edgew;
		#elif defined(CF_ALGORITHM)
			// source: https://mrmgroup.cs.princeton.edu/papers/taejun_micro16.pdf (Graphicionado)
			// process edge & process combined here (source: graphicionado paper)
			/* --- Collaborative Filtering ---:
			Process Edges: Executed in Reduce. ({Ew, Uprop} from source is sent to destination vertex)
			Reduce: Function of (uprop, Ew, Vprop) is executed 
			Apply: Function of (Vprop, Vtemp) is executed 
			Finish: */
			res = udata;
		#elif defined(CC_ALGORITHM)
			// source: https://www.baeldung.com/cs/graph-connected-components
			// source: https://cs.usm.maine.edu/~briggs/webPage/c161/projects/graphColoring.htmls
			// source: https://www.usenix.org/system/files/conference/osdi12/osdi12-final-126.pdf (GraphChi)
			/* --- Connected Components ---:
			Process Edges: Each vertex writes its id ("label") to its edges. 
			Reduce: Vertex chooses the minimum label of its neighbors; 
			Apply: A neighbor is scheduled only if a label in a connecting edge changes, which we implement by using selective scheduling. 
			Finish: sets of vertices with equal labels are interpreted as connected components or communities, respectively. */
			res = udata;
		#elif defined(BFS_ALGORITHM)
			res = NAp;
		#elif defined(SSSP_ALGORITHM)
			res = udata + edgew;
		#else
			NOT DEFINED.
		#endif
	#else 
	if(GraphAlgo == PAGERANK){
		res = udata + edgew;
	} else if(GraphAlgo == CF){
		res = udata;
	} else if(GraphAlgo == CC){
		res = udata;
	} else if(GraphAlgo == BFS){
		res = NAp;
	} else if(GraphAlgo == SSSP){
		res = udata + edgew;
	} else {
		res = NAp;
	}
	#endif
	return res;
}

value_t {{context['classname__processedges_and_reduceupdates']}}PANDR{{context['id']}}_reducefunc(value_t vtemp, value_t res, unsigned int GraphIter, unsigned int GraphAlgo){
	value_t temp = 0;
	#ifdef CUSTOMLOGICFOREACHALGORITHM
		#if defined(PR_ALGORITHM)
			temp = vtemp + res;
		#elif defined(CF_ALGORITHM)
			unsigned int ew = 1;
			unsigned int lamda = 1;
			temp = vtemp + ((ew - vtemp*res)*res - lamda*vtemp);
		#elif defined(CC_ALGORITHM)
			temp = UTIL{{context['id']}}_amin(vtemp, res);
		#elif defined(BFS_ALGORITHM)
			temp = UTIL{{context['id']}}_amin(vtemp, GraphIter);
		#elif defined(SSSP_ALGORITHM)
			temp = UTIL{{context['id']}}_amin(vtemp, res);
		#else 
			NOT DEFINED.
		#endif
	#else 
	if(GraphAlgo == PAGERANK){
		temp = vtemp + res;
	} else if(GraphAlgo == CF){
		temp = vtemp + ((ew - vtemp*res)*res - lamda*vtemp);
	} else if(GraphAlgo == CC){
		temp = UTIL{{context['id']}}_amin(vtemp, res);
	} else if(GraphAlgo == BFS){
		temp = UTIL{{context['id']}}_amin(vtemp, GraphIter);
	} else if(GraphAlgo == SSSP){
		temp = UTIL{{context['id']}}_amin(vtemp, res);
	} else {
		NOT DEFINED
	}
	#endif
	return temp;
}

void {{context['classname__processedges_and_reduceupdates']}}PANDR{{context['id']}}_GetXYLayoutV(unsigned int s, unsigned int depths[PE_SETSZ], unsigned int basedepth){
	unsigned int s_ = s % VECTOR2_SIZE;
	
	{%for v in context['PE_SETSZ_seq']%}
	{%if(v>0)%}else{%endif%} {%if(v<16-1)%}if(s_=={{v}}){%endif%}{ 
		{%for v2 in context['PE_SETSZ_seq']%}{%if(v2<v)%}
		depths[{{v2}}] = {{16-v+v2}}; 
		{%endif%}{%endfor%}
		{%for v2 in context['PE_SETSZ_seq']%}{%if(v2>=v)%}
		depths[{{v2}}] = {{v2-v}}; 
		{%endif%}{%endfor%}
	}
	{%endfor%}
	return;
}

parsededge_t {{context['classname__processedges_and_reduceupdates']}}PANDR{{context['id']}}_PARSEEDGE(uint32_type data){ 
	parsededge_t parsededge;
	#ifdef _WIDEWORD
	parsededge.incr = data.range(31, 28);
	parsededge.dstvid = data.range(28, 0);
	#else
	parsededge.incr = UTIL{{context['id']}}_READFROM_UINT(data, 28, 4);
	parsededge.dstvid = UTIL{{context['id']}}_READFROM_UINT(data, 0, 28);
	#endif
	return parsededge; 
}

void {{context['classname__processedges_and_reduceupdates']}}PANDR{{context['id']}}_processorreducevector(bool enx, unsigned int mode, unsigned int col, unsigned int _loc, keyvalue_t kvdata,
		keyvalue_vbuffer_t vbuffer[BLOCKRAM_VDATA_SIZE], keyvalue_buffer_t buffer[SOURCEBLOCKRAM_SIZE], unsigned int * loadcount, 
			unsigned int GraphAlgoClass, unsigned int upperlimit, sweepparams_t sweepparams, globalparams_t globalparams){
	#pragma HLS INLINE
	bool en = true; 
	keyvalue_t mykeyvalue;
	unsigned int loc = 0;
	
	if(mode == ACTSPROCESSMODE){ 
		loc = _loc;
		if(kvdata.key != INVALIDDATA && kvdata.value != INVALIDDATA && enx == true){ en = true; } else { en = false; }
	} else if(mode == ACTSREDUCEMODE){
		mykeyvalue = UTIL{{context['id']}}_GETKV(kvdata);
		loc = ((mykeyvalue.key - upperlimit) - col) >> NUM_PARTITIONS_POW;
		if(mykeyvalue.key != UTIL{{context['id']}}_GETK(INVALIDDATA) && mykeyvalue.value != UTIL{{context['id']}}_GETV(INVALIDDATA) && enx == true){ en = true; } else { en = false; }
	} else {}
	
	if(loc >= globalparams.SIZEKVS2_REDUCEPARTITION && en == true){
		#ifdef _DEBUGMODE_CHECKS2X
		if(true){ cout<<"REDUCE{{context['id']}}_processvector::ERROR SEEN @ loc("<<loc<<") >= globalparams.SIZE_REDUCE("<<globalparams.SIZE_REDUCE<<"). kvdata.key: "<<kvdata.key<<", upperlimit: "<<upperlimit<<", col: "<<col<<". EXITING... "<<endl; exit(EXIT_FAILURE); }
		#endif 
		loc = 0; }
	
	// read 
	vmdata_t vmdata;
	if(en == true){ vmdata = MEMCA{{context['id']}}_READFROMBUFFER_VDATAWITHVMASK(loc, vbuffer, 0); }
	if(mode == ACTSPROCESSMODE && GraphAlgoClass == ALGORITHMCLASS_ALLVERTEXISACTIVE){ vmdata.vmask = 1; } 
	
	#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
	if(mode == ACTSPROCESSMODE && vmdata.vmask == 1){ 
		if(en == true){ cout<<"PANDR{{context['id']}}_processorreducevector:: PROCESS SEEN @ vid: "<<UTIL{{context['id']}}_GETREALVID(kvdata.key, globalparams.ACTSPARAMS_INSTID)<<", loc: "<<loc<<", edata.key(dstvid): "<<edata.key<<", edata.value(srcvid): "<<edata.value<<", upperlimit: "<<upperlimit<<endl; }
	} else if(mode == ACTSREDUCEMODE){
		if(en == true){ cout<<"PANDR{{context['id']}}_processorreducevector:: REDUCE SEEN @ vid: "<<UTIL{{context['id']}}_GETREALVID(mykeyvalue.key, globalparams.ACTSPARAMS_INSTID)<<", loc: "<<loc<<", mykeyvalue.key: "<<mykeyvalue.key<<", mykeyvalue.value: "<<mykeyvalue.value<<", upperlimit: "<<upperlimit<<endl; }
	} else {}
	#endif 
			
	// process
	if(mode == ACTSPROCESSMODE){ 
		value_t res = PANDR{{context['id']}}_processfunc(vmdata.vdata, 1, globalparams.ALGORITHMINFO_GRAPHALGORITHMID);
		keyvalue_t mykeyvalue; mykeyvalue.key = kvdata.key; mykeyvalue.value = res;
	} else if(mode == ACTSREDUCEMODE){
		value_t new_vprop = PANDR{{context['id']}}_reducefunc(vmdata.vdata, mykeyvalue.value, globalparams.ALGORITHMINFO_GRAPHITERATIONID, globalparams.ALGORITHMINFO_GRAPHALGORITHMID);
		if(en == true && new_vprop != vmdata.vdata){ vmdata.vmask = 1; }
	} else {}
	
	// write 
	if(mode == ACTSPROCESSMODE){
		if(en == true && vmdata.vmask == 1){ buffer[*loadcount] = UTIL{{context['id']}}_GETKV(mykeyvalue); }
		if(en == true && vmdata.vmask == 1){ *loadcount += 1; }
	} else if(mode == ACTSREDUCEMODE){
		if(en == true){ MEMCA{{context['id']}}_WRITETOBUFFER_VDATAWITHVMASK(loc, vbuffer, vmdata.vdata, vmdata.vmask, 0); }
	} else {}	
	
	#ifdef _DEBUGMODE_STATS
	if(mode == ACTSPROCESSMODE){ 
		actsutilityobj->globalstats_countkvsprocessed(1);
		if(en == true && vmdata.vmask == 1){ actsutilityobj->globalstats_processedges_countvalidkvsprocessed(1); }
	} else if(mode == ACTSREDUCEMODE){
		actsutilityobj->globalstats_countkvsreduced(1); 
		if(en == true){ actsutilityobj->globalstats_reduce_countvalidkvsreduced(1); }
	} else {}
	#endif 
	return;
}

fetchmessage_t {{context['classname__processedges_and_reduceupdates']}}PANDR{{context['id']}}_processandreduce(bool_type enable, unsigned int mode, 
		uint512_dt * edges, uint512_dt * kvdram, 
			keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], keyvalue_buffer_t buffer[VECTOR_SIZE][SOURCEBLOCKRAM_SIZE],
				keyvalue_t globalcapsule[MAX_NUM_PARTITIONS], keyvalue_capsule_t localcapsule[MAX_NUM_PARTITIONS],
					batch_type goffset_kvs, batch_type loffset_kvs, batch_type size_kvs, 
						travstate_t travstate, sweepparams_t sweepparams, globalparams_t globalparams){
	fetchmessage_t fetchmessage;
	fetchmessage.chunksize_kvs = -1;
	fetchmessage.nextoffset_kvs = -1;
	if(enable == OFF){ return fetchmessage; }
	analysis_type analysis_loopcount = (DESTBLOCKRAM_SIZE / (NUM_PARTITIONS / 2));
	
	buffer_type reducebuffersz = globalparams.SIZE_REDUCE / 2;
	unsigned int validbound = reducebuffersz * FETFACTOR * VECTOR2_SIZE;
	
	travstate.i_kvs = travstate.i_kvs / 2;
	travstate.end_kvs = travstate.end_kvs / 2;
	loffset_kvs = loffset_kvs / 2;
	buffer_type edgessize_kvs = size_kvs / 2;
	
	batch_type offset_kvs = goffset_kvs + loffset_kvs;
	
	unsigned int lsrcvids[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=lsrcvids complete
	unsigned int ldstvids[VECTOR2_SIZE];	
	#pragma HLS ARRAY_PARTITION variable=ldstvids complete
	value_t res[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=res complete
	unsigned int loadcount[VECTOR_SIZE];
	#pragma HLS ARRAY_PARTITION variable=loadcount complete
	unsigned int depths[PE_SETSZ];
	#pragma HLS ARRAY_PARTITION variable=depths complete
	unsigned int d[PE_SETSZ];
	#pragma HLS ARRAY_PARTITION variable=d complete
	bool enx[PE_SETSZ];
	#pragma HLS ARRAY_PARTITION variable=enx complete
	value_t EDATA[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=EDATA complete
	keyvalue_buffer_t KVDATAA[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=KVDATAA complete
	keyvalue_t kvdata[VECTOR2_SIZE];
	#pragma HLS ARRAY_PARTITION variable=kvdata complete
	buffer_type size_kvs[MAX_NUM_PARTITIONS];
	#pragma HLS ARRAY_PARTITION variable=size_kvs complete
	value_t tempbuffer[VECTOR_SIZE][SOURCEBLOCKRAM_SIZE];
	#pragma HLS array_partition variable = tempbuffer
	
	buffer_type maxsize_kvs = 0;
	buffer_type totalsize_kvs = 0;
	unsigned int key_kvs[NUM_PARTITIONS];
	
	batch_type vptrbaseoffset_kvs = globalparams.BASEOFFSETKVS_VERTEXPTR + (globalparams.ACTSPARAMS_SRCVOFFSET / VECTOR_SIZE);
	batch_type voffset_kvs = sweepparams.source_partition * reducebuffersz * FETFACTOR;

	fetchmessage.chunksize_kvs = edgessize_kvs;
	fetchmessage.nextoffset_kvs = -1;
	
	unsigned int GraphAlgo = globalparams.ALGORITHMINFO_GRAPHALGORITHMID;
	unsigned int GraphAlgoClass = globalparams.ALGORITHMINFO_GRAPHALGORITHMCLASS;

	buffer_type chunk_size = 0;
	if(mode == ACTSPROCESSMODE){
		chunk_size = UTIL{{context['id']}}_getchunksize_kvs(edgessize_kvs, travstate, 0);
	} else if(mode == ACTSREDUCEMODE){
		chunk_size = DESTBLOCKRAM_SIZE;
	} else {}
	
	if(mode == ACTSPROCESSMODE){
		// FIXME. Get this is a metadata in DRAM
		unsigned int modelsz = chunk_size / NUM_PARTITIONS;
		for(unsigned int i=0; i<NUM_PARTITIONS; i++){ localcapsule[i].key = i * modelsz; localcapsule[i].value = modelsz; } // FIXME.
		for(unsigned int t=0; t<VECTOR2_SIZE; t++){ loadcount[t] = 0; }
		
		#ifdef _DEBUGMODE_KERNELPRINTS
		actsutilityobj->printkeyvalues("processandbuffer.localcapsule", (keyvalue_t *)localcapsule, NUM_PARTITIONS);
		#endif
		
		PANDR_BUFFERPARTITIONS_LOOP1: for(buffer_type i=0; i<chunk_size; i++){
		#pragma HLS PIPELINE II=1
			#ifdef _WIDEWORD
			{%for v in context['VECTOR2_SIZE_seq']%}
			tempbuffer[{{v}}][i] = edges[offset_kvs + i].range({{((v + 1) * 32) - 1}}, {{v * 32}}); 
			{%endfor%}
			#else 
			{%for v in context['VECTOR_SIZE_seq']%}
			tempbuffer[{{2*v}}][i] = edges[offset_kvs + i].data[{{v}}].key; 
			tempbuffer[{{2*v+1}}][i] = edges[offset_kvs + i].data[{{v}}].value;	
			{%endfor%}
			#endif
		}
	}
	buffer_type height_kvs = (localcapsule[NUM_PARTITIONS-1].key + localcapsule[NUM_PARTITIONS-1].value) / VECTOR_SIZE;

	buffer_type blockoffset=0;
	PANDR_BUFFERPARTITIONS_LOOP3: for(buffer_type blockoffset=0; blockoffset<NUM_PARTITIONS; blockoffset+=8){
		
		PANDR_BUFFERPARTITIONS_LOOP3B: for(partition_type p=blockoffset; p<blockoffset + 8; p++){
		#pragma HLS PIPELINE II=1
			size_kvs[p] = localcapsule[blockoffset + p].value / VECTOR_SIZE;
			if(maxsize_kvs < size_kvs[p]){ maxsize_kvs = size_kvs[p]; }
			totalsize_kvs += size_kvs[p];
			key_kvs[p] = localcapsule[blockoffset + p].key / VECTOR_SIZE;
		}
		
		PANDR_BUFFERPARTITIONS_LOOP3C: for(unsigned int r=0; r<NUM_PARTITIONS; r++){
			PANDR_BUFFERPARTITIONS_LOOP3D: for(buffer_type i=0; i<maxsize_kvs; i++){ // maxsize // FIXME
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_loopcount avg=analysis_loopcount
			#pragma HLS PIPELINE II=4
				#ifdef _DEBUGMODE_CHECKS2
				{%for v in context['VECTOR_SIZE_seq']%}
				actsutilityobj->checkoutofbounds("readandprocess2(12)::DEBUG CODE 1::1", i, SOURCEBLOCKRAM_SIZE, NAp, NAp, NAp);
				actsutilityobj->checkoutofbounds("readandprocess2(12)::DEBUG CODE 14::1", blockoffset + depths[{{v}}], NUM_PARTITIONS, NAp, NAp, NAp);
				{%endfor%} 
				#endif	
				
				// read edges . FIXME
				PANDR{{context['id']}}_GetXYLayoutV(r, depths, 0);
				{%for v in context['VECTOR_SIZE_seq']%}
				d[{{v}}] = (localcapsule[blockoffset + depths[{{v}}]].key / VECTOR_SIZE) + i; 	
				{%endfor%} 
				if(mode == ACTSPROCESSMODE){
					{%for v in context['VECTOR_SIZE_seq']%}
					if(d[{{v}}] < {%if(v==context['VECTOR_SIZE']-1)%}height_kvs{%else%}key_kvs[{{v+1}}]{%endif%}){ EDATA[{{v}}] = tempbuffer[{{v}}][d[{{v}}]]; enx[{{v}}] = true; } else { enx[{{v}}] = false; }
					{%endfor%} 
				} else if(mode == ACTSREDUCEMODE){
					{%for v in context['VECTOR_SIZE_seq']%}
					if(d[{{v}}] < {%if(v==context['VECTOR2_SIZE']-1)%}height_kvs{%else%}key_kvs[{{v+1}}]{%endif%}){ KVDATAA[{{v}}] = buffer[{{v}}][d[{{v}}]]; enx[{{v}}] = true; } else { enx[{{v}}] = false; }
					{%endfor%} 					
				} else {}
				
				// parse {srcvid, dstvid}
				if(mode == ACTSPROCESSMODE){
					{%for v in context['VECTOR_SIZE_seq']%}
					parsededge_t parsed_edge{{v}} = PANDR{{context['id']}}_PARSEEDGE(EDATA[{{v}}]);
					kvdata[{{v}}].value = parsed_edge{{v}}.incr; // source info
					kvdata[{{v}}].key = parsed_edge{{v}}.dstvid;	
					{%endfor%}
				} else if(mode == ACTSREDUCEMODE){
					{%for v in context['VECTOR_SIZE_seq']%}
					kvdata[{{v}}].key = UTIL{{context['id']}}_GETKV(KVDATAA[{{2*v}}]).key;
					kvdata[{{v}}].value = UTIL{{context['id']}}_GETKV(KVDATAA[{{2*v+1}}]).value;
					{%endfor%} 
				} else {}
				
				// process
				if(mode == ACTSPROCESSMODE){ enx[0] = false; }
				{%for v in context['VECTOR_SIZE_seq']%}
				if(EDATA[{{v}}] == INVALIDDATA){ enx[{{v}}] = false; }
				PANDR{{context['id']}}_processorreducevector(enx[{{v}}], mode, {{v}}, kvdata[{{v}}].value, kvdata[{{v}}],
						vbuffer[blockoffset + {{v}}], buffer[{{v}}], &loadcount[{{v}}], 
							GraphAlgoClass, sweepparams.upperlimit, sweepparams, globalparams);
				{%endfor%}
			}
		}
	}
	
	// cout<<"classname__processedges2_splitdstvxs SUCCESSFULL HERE...."<<endl;
	// for(unsigned int t=0; t<VECTOR_SIZE; t++){ cout<<"--- loadcount["<<t<<"]: "<<loadcount[t]<<endl; }
	fetchmessage.chunksize_kvs = chunk_size * 2; // loadcount; // CRITICAL FIXME
	// exit(EXIT_SUCCESS); ////
	return fetchmessage;
}

#ifdef BASIC_PARTITION_AND_REDUCE_STRETEGY
void {{context['classname__processedges_and_reduceupdates']}}REDUCE{{context['id']}}_priorreduceandbuffer(bool_type enable, keyvalue_buffer_t buffer[VECTOR_SIZE][SOURCEBLOCKRAM_SIZE], keyvalue_capsule_t localcapsule[MAX_NUM_PARTITIONS], keyvalue_vbuffer_t vbuffer[VDATA_PACKINGSIZE][BLOCKRAM_VDATA_SIZE], buffer_type chunk_size, sweepparams_t sweepparams, globalparams_t globalparams){				
	#ifdef _DEBUGMODE_KERNELPRINTS3
	cout<<"reduceupdates2: REDUCE{{context['id']}}_tradreduceandbuffer NOT DEFINED HERE."<<endl;
	exit(EXIT_FAILURE);
	#endif 
	return;
}
#endif 

#ifdef TRAD_PARTITION_AND_REDUCE_STRETEGY
void {{context['classname__processedges_and_reduceupdates']}}REDUCE{{context['id']}}_tradreduceandbuffer(bool_type enable, uint512_dt * kvdram, keyvalue_buffer_t buffer[VECTOR_SIZE][SOURCEBLOCKRAM_SIZE], buffer_type chunk_size, keyvalue_t globalstatsbuffer[MAX_NUM_PARTITIONS], sweepparams_t sweepparams, globalparams_t globalparams){				
	#ifdef _DEBUGMODE_KERNELPRINTS3
	cout<<"reduceupdates2: REDUCE{{context['id']}}_tradreduceandbuffer NOT DEFINED HERE."<<endl;
	exit(EXIT_FAILURE);
	#endif 
	return;
}
#endif 



