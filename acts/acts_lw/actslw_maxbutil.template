#include <string>
#include <string.h>
#include <iostream>
#include <vector>
#include <string.h>
#include <stdio.h>
#include <ctime>
#include <functional>
#include <sys/time.h>
#include <time.h>
#include <stdlib.h>
#include <iomanip>
#include <cmath>
#include <fstream>
#include "../../include/config_params.h"
#include "../../include/common.h"
#include "../include/actscommon.h"
#ifndef FPGA_IMPL
#include "../../src/utility/utility.h"
#endif 
#ifndef HW
#include "../../acts/actsutility/actsutility.h"
#endif 
#include "actslw_maxbutil.h"
using namespace std;

#ifdef SW
actslw_maxbutil::actslw_maxbutil(){ actsutilityobj = new actsutility(); }
actslw_maxbutil::~actslw_maxbutil(){}
#endif
#ifdef SWEMU
actsutility * actsutilityobj = new actsutility();
#endif

// kernel utilities
unsigned int
	#ifdef SW 
	actslw_maxbutil::
	#endif 
amin(unsigned int val1, unsigned int val2){
	if(val1 < val2){ return val1; }
	else { return val2; }
}
batch_type
	#ifdef SW 
	actslw_maxbutil::
	#endif
allignlower_KV(batch_type val){
	batch_type fac = val / VECTOR_SIZE;
	return (fac * VECTOR_SIZE);
}
batch_type
	#ifdef SW 
	actslw_maxbutil::
	#endif 
allignhigher_KV(batch_type val){
	batch_type fac = (val + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
	return (fac * VECTOR_SIZE);
}
batch_type
	#ifdef SW 
	actslw_maxbutil::
	#endif
getskipsize(step_type currentLOP, bool_type sourceORdest, globalparams_t globalparams){
	analysis_type analysis_treedepth = TREE_DEPTH;
	batch_type result;
	
	if(currentLOP == 0){ currentLOP = 1; }
	if(sourceORdest == SOURCE){ result = globalparams.LLOPnumpartitions; }
	else if (sourceORdest == DEST){ result = globalparams.LLOPnumpartitions / NUM_PARTITIONS; } // FIXME. use TREE_DEPTH for less lut?
	else {}
	for(step_type i=0; i<(currentLOP-1); i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_treedepth avg=analysis_treedepth
		result = result / NUM_PARTITIONS;
	}
	return result;
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
resetkeyandvalues(skeyvalue_t * buffer, buffer_type size){
	for(buffer_type i=0; i<size; i++){ buffer[i].key = 0; buffer[i].value = 0; }
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
resetvalues(keyvalue_t * buffer, buffer_type size){
	for(buffer_type i=0; i<size; i++){ buffer[i].value = 0; }
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
resetmanykeyandvalues(skeyvalue_t buffer[VECTOR_SIZE][NUM_PARTITIONS], buffer_type size){
	for(buffer_type i=0; i<size; i++){
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer[{{v}}][i].key = 0; buffer[{{v}}][i].value = 0; 
		{%endfor%}
	}
	return;
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
resetmanykeyandvalues(keyvalue_t buffer[VECTOR_SIZE][PADDEDDESTBUFFER_SIZE], buffer_type size){
	for(buffer_type i=0; i<size; i++){
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer[{{v}}][i].key = 0; buffer[{{v}}][i].value = 0; 
		{%endfor%}
	}
	return;
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
resetmanykeyandvalues(keyvalue_t buffer[NUM_PARTITIONS], buffer_type size){
	for(buffer_type i=0; i<size; i++){
		buffer[i].key = 0; buffer[i].value = 0; 
	}
	return;
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
resetmanyvalues(skeyvalue_t buffer[VECTOR_SIZE][NUM_PARTITIONS], buffer_type size){
	for(buffer_type i=0; i<size; i++){ 
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer[{{v}}][i].value = 0;
		{%endfor%}
	}
	return;
}
buffer_type 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
getchunksize_kvs(buffer_type buffer_size, travstate_t travstate, buffer_type localoffset){
	buffer_type chunk_size = buffer_size;
	batch_type i = travstate.i_kvs + localoffset;
	if (i > travstate.end_kvs){ chunk_size = 0; }
	else if ((i + buffer_size) > travstate.end_kvs){ chunk_size = travstate.end_kvs - i; }
	else {}
	return chunk_size;
}
buffer_type 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
getchunksize(buffer_type buffersz, travstate_t travstate, buffer_type localoffset){
	buffer_type chunksz = buffersz;
	batch_type i = travstate.i + localoffset;
	if (i > travstate.end){ chunksz = 0; }
	else if ((i + buffersz) > travstate.end){ chunksz = travstate.end - i; }
	else {}
	return chunksz;
}
partition_type
	#ifdef SW 
	actslw_maxbutil::
	#endif 
getpartition(keyvalue_t keyvalue, step_type currentLOP, vertex_t upperlimit, unsigned int batch_range_pow){
	partition_type partition = ((keyvalue.key - upperlimit) >> (batch_range_pow - (NUM_PARTITIONS_POW * currentLOP)));
	
	#ifdef _DEBUGMODE_CHECKS2
	if(partition >= NUM_PARTITIONS){ actsutilityobj->globalstats_counterrorsingetpartition(1); }
	#endif 
	
	#ifdef ENABLE_PERFECTACCURACY
		#ifdef _DEBUGMODE_CHECKS2
		if(partition >= NUM_PARTITIONS){ cout<<"getpartition::ERROR 1. partition out of bounds partition: "<<partition<<", keyvalue.key: "<<keyvalue.key<<", NUM_PARTITIONS: "<<NUM_PARTITIONS<<", keyvalue.key: "<<keyvalue.key<<", upperlimit: "<<upperlimit<<", currentLOP: "<<currentLOP<<", batch_range_pow: "<<batch_range_pow<<endl; exit(EXIT_FAILURE); }
		#endif
	#endif 
	#ifndef ENABLE_PERFECTACCURACY
		if(partition >= NUM_PARTITIONS){ partition = (((1 << NUM_PARTITIONS_POW) - 1) & (partition >> (1 - 1))); } // FIXME. REMOVEME. PERFECTIONTEST.
	#endif
	
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("actslw_maxbutil::getpartition 2", partition, NUM_PARTITIONS, keyvalue.key, upperlimit, currentLOP);
	#endif
	return partition;
}
value_t 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
reducefunc(value_t vtemp, value_t res, unsigned int GraphIter, unsigned int GraphAlgo){
	value_t temp = 0;
	#ifdef PR_ALGORITHM
	temp = vtemp + res;
	#elif defined(BFS_ALGORITHM)
	temp = amin(vtemp, GraphIter); // NEWCHANGE.
	#elif defined(BC_ALGORITHM)
	temp = amin(vtemp, res);
	#endif
	return temp;
	
	// value_t temp = 0;
	// if(GraphAlgo == PAGERANK){
		// temp = vtemp + res;
	// } else if (GraphAlgo == BREADTHFIRSTSEARCH){
		// temp = amin(vtemp, GraphIter);
	// } else if (GraphAlgo == SSSP){
		// temp = amin(vtemp, res);
	// } else { temp = 0; }
	// return temp;
}
value_t 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
processedgefunc(value_t Uprop, unsigned int edgeweight, unsigned int voutdegree, unsigned int GraphIter, unsigned int GraphAlgo){
	// value_t ret = 0;
	// #ifdef PR_ALGORITHM
	// ret = Uprop;
	// #elif defined(BFS_ALGORITHM)
	// ret = Uprop + edgeweight;
	// #elif defined(BC_ALGORITHM)
	// ret = Uprop + edgeweight;
	// #endif
	// return ret;
	
	value_t res = 0;
	#ifdef PR_ALGORITHM
	res = Uprop / voutdegree;
	#elif defined(BFS_ALGORITHM)
	res = NAp;
	#elif defined(BC_ALGORITHM)
	res = Uprop + edgeweight;
	#endif
	return res;
	
	// value_t res = 0;
	// if(GraphAlgo == PAGERANK){
		// res = Uprop / voutdegree;
	// } else if (GraphAlgo == BREADTHFIRSTSEARCH){
		// res = NAp;
	// } else if (GraphAlgo == SSSP){
		// res = Uprop + edgeweight;
	// } else { res = 0; }
	// return res;
}
value_t 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
mergefunc(value_t value1, value_t value2, unsigned int GraphAlgo){
	value_t res = 0;
	#ifdef PR_ALGORITHM
	res = value1 + value2;
	#elif defined(BFS_ALGORITHM)
	res = amin(value1, value2);
	#elif defined(BC_ALGORITHM)
	res = amin(value1, value2);
	#endif
	return res;
	
	// value_t res = 0;
	// if(GraphAlgo == PAGERANK){
		// res = value1 + value2;
	// } else if (GraphAlgo == BREADTHFIRSTSEARCH){
		// res = amin(value1, value2);
	// } else if (GraphAlgo == SSSP){
		// res = amin(value1, value2);
	// } else { res = 0; }
	// return res;
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
copykeyvalues(keyvalue_t * buffer1, keyvalue_t * buffer2, buffer_type size){
	COPYKEYS_LOOP: for(buffer_type i=0; i<size; i++){ buffer1[i] = buffer2[i]; }
}
buffer_type 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
getpartitionwritesz(buffer_type realsize_kvs, buffer_type bramoffset_kvs){
	// #pragma HLS INLINE
	buffer_type size_kvs = 0;
	
	#ifdef ENABLE_APPROXIMATEPARTITIONWRITES
		{% set my_variable = 2 %}
		{% set my_base = 0 %} // SECOND SET:: (my_variable): {{my_variable}}, (my_base): {{my_base}}
		
		{%for n in context['32_seq']%}
		{%if(n>0)%}else {%endif%}if(realsize_kvs >= {{(n * my_variable)}} && realsize_kvs < {{((n+1) * my_variable)}}){ size_kvs = {{((n+1) * my_variable)}}; }
		{%endfor%}
		
		{% set my_variable = my_variable + 2 %}
		{% set my_base = my_base + (32 * 2) %} // SECOND SET:: (my_variable): {{my_variable}}, (my_base): {{my_base}}
		
		{%for n in context['16_seq']%}
		else if(realsize_kvs >= {{(my_base + n * my_variable)}} && realsize_kvs < {{(my_base + (n+1) * my_variable)}}){ size_kvs = {{(my_base + (n+1) * my_variable)}}; }
		{%endfor%}
		
		{% set my_variable = my_variable + 4 %}
		{% set my_base = my_base + (16 * 4) %} // THIRD SET:: (my_variable): {{my_variable}}, (my_base): {{my_base}}
		
		{%for n in context['16_seq']%}
		else if(realsize_kvs >= {{(my_base + n * my_variable)}} && realsize_kvs < {{(my_base + (n+1) * my_variable)}}){ size_kvs = {{(my_base + (n+1) * my_variable)}}; }
		{%endfor%}
		
		{% set my_variable = my_variable + 8 %}
		{% set my_base = my_base + (16 * 8) %} // FOURTH SET:: (my_variable): {{my_variable}}, (my_base): {{my_base}}
		
		{%for n in context['16_seq']%}
		else if(realsize_kvs >= {{(my_base + n * my_variable)}} && realsize_kvs < {{(my_base + (n+1) * my_variable)}}){ size_kvs = {{(my_base + (n+1) * my_variable)}}; }
		{%endfor%}
		
		else {
			cout<<"WARNING:getpartitionwritesz: should not get here. something might be wrong. realsize_kvs: "<<realsize_kvs<<", size_kvs: "<<size_kvs<<", PADDEDDESTBUFFER_SIZE: "<<PADDEDDESTBUFFER_SIZE<<endl;				 
			
			#ifdef ENABLE_PERFECTACCURACY
			#ifdef _DEBUGMODE_CHECKS2
			cout<<"WARNING:getpartitionwritesz: should not get here. something might be wrong. realsize_kvs: "<<realsize_kvs<<", size_kvs: "<<size_kvs<<", PADDEDDESTBUFFER_SIZE: "<<PADDEDDESTBUFFER_SIZE<<endl;				 
			exit(EXIT_FAILURE);
			#endif
			#else
			size_kvs = PADDEDDESTBUFFER_SIZE / NUM_PARTITIONS;
			#endif 
		}
		// #if defined(SW) || defined(SWEMU) 
		#if defined(SW) || defined(SWEMU) || defined(HW) // NEWCHANGE.
		if((bramoffset_kvs + size_kvs) >= PADDEDDESTBUFFER_SIZE){ size_kvs = PADDEDDESTBUFFER_SIZE - bramoffset_kvs - 1; } 
		#endif
	#else 
		size_kvs = realsize_kvs;
	#endif
	return size_kvs;
}
buffer_type
	#ifdef SW 
	actslw_maxbutil::
	#endif 
withinvalidrange(buffer_type val1, buffer_type val2){
	// #pragma HLS INLINE
	if(val1 < val2){ return 1; }
	else { return 0; }
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
calculateoffsets(keyvalue_t * buffer, buffer_type size, batch_type base, batch_type skipspacing[NUM_PARTITIONS]){
	unsigned int analysis_size = NUMLASTLEVELPARTITIONS;
	
	buffer[0].key += base;
	for(buffer_type i=1; i<size; i++){ 
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_size avg=analysis_size	
		buffer[i].key = allignhigher_KV(buffer[i-1].key + buffer[i-1].value + skipspacing[i-1]); 
	}
	return;
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
calculateunallignedoffsets(skeyvalue_t buffer[NUM_PARTITIONS], buffer_type size, batch_type base, batch_type skipspacing){
	for(buffer_type i=1; i<size; i++){ 
		buffer[i].key = buffer[i-1].key + buffer[i-1].value + skipspacing; 
	}
	return;
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
calculatemanyoffsets(skeyvalue_t buffer[VECTOR_SIZE][NUM_PARTITIONS], buffer_type size, batch_type base, batch_type skipspacing){
	for(buffer_type i=1; i<size; i++){ 
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer[{{v}}][i].key = allignhigher_KV(buffer[{{v}}][i-1].key + buffer[{{v}}][i-1].value + skipspacing); 
		{%endfor%}
	}
	return;
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
calculatemanyunallignedoffsets(skeyvalue_t buffer[VECTOR_SIZE][NUM_PARTITIONS], buffer_type size, batch_type base, batch_type skipspacing){
	for(buffer_type i=1; i<size; i++){ 
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer[{{v}}][i].key = buffer[{{v}}][i-1].key + buffer[{{v}}][i-1].value + skipspacing; 
		{%endfor%}
	}
	return;
}
batch_type
	#ifdef SW 
	actslw_maxbutil::
	#endif 
getvaluecount(keyvalue_t * keyvalues, unsigned int size){
	unsigned int totalnumkeyvalues = 0;
	for(unsigned int p=0; p<size; p++){ totalnumkeyvalues += keyvalues[p].value; }
	return totalnumkeyvalues;
}
batch_type
	#ifdef SW 
	actslw_maxbutil::
	#endif 
get_num_source_partitions(step_type currentLOP){
	// #pragma HLS INLINE
	analysis_type analysis_treedepth = TREE_DEPTH;
	
	if(currentLOP == 0){ currentLOP = 1; }
	batch_type pow = 1;
	for(step_type i=0; i<(currentLOP-1); i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_treedepth avg=analysis_treedepth
		pow = pow * NUM_PARTITIONS;
	}
	return pow;
}
globalparams_t 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
getglobalparams(uint512_dt * kvdram){
	globalparams_t globalparams;
	#ifdef _WIDEWORD
	globalparams.command = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_COMMANDID].range(31, 0);
	globalparams.runkernelcommand = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_RUNKERNELCOMMANDID].range(31, 0);
	globalparams.processcommand = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_PROCESSCOMMANDID].range(31, 0);
	globalparams.collectstatscommand = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_COLLECTSTATSCOMMANDID].range(31, 0);
	globalparams.partitioncommand = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_PARTITIONCOMMANDID].range(31, 0);
	globalparams.reducecommand = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_APPLYUPDATESCOMMANDID].range(31, 0);
	globalparams.finalnumpartitions = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_FINALNUMPARTITIONSID].range(31, 0);
	globalparams.treedepthid = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_TREEDEPTHID].range(31, 0);
	globalparams.ssdpartitionid = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_SSDPARTITIONID].range(31, 0);
	globalparams.srcvoffset = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_SRCVOFFSET].range(31, 0); // not used
	globalparams.srcvsize = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_SRCVSIZE].range(31, 0);
	globalparams.srcvsize_kvs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_SRCVSIZE_KVS].range(31, 0);
	globalparams.edgessize = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_EDGESSIZE].range(31, 0);
	globalparams.edgessize_kvs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_EDGESSIZE_KVS].range(31, 0);
	globalparams.destvoffset = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_DESTVOFFSET].range(31, 0);
	globalparams.actvvsize = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_ACTVVSIZE].range(31, 0);
	globalparams.firstvid = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_FIRSTVID].range(31, 0);
	globalparams.firstkey = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_FIRSTKEY].range(31, 0);
	globalparams.firstvalue = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_FIRSTVALUE].range(31, 0); // not used
	globalparams.treedepth = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_TREEDEPTH].range(31, 0);
	globalparams.LLOPnumpartitions = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_FINALNUMPARTITIONS].range(31, 0);
	globalparams.batchsize = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_BATCHSIZE].range(31, 0);
	globalparams.runsize = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_RUNSIZE].range(31, 0);
	globalparams.runsize_kvs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_RUNSIZE_KVS].range(31, 0);
	globalparams.nextbatchoffset = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_NEXTBATCHOFFSET].range(31, 0);
	globalparams.GraphIter = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_GRAPHITERATIONID].range(31, 0);
	globalparams.GraphAlgo = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_GRAPHALGORITHMID].range(31, 0);
	globalparams.statsalreadycollected = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_STATSALREADYCOLLECTED].range(31, 0);
	globalparams.groupid = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_GROUPID].range(31, 0);
	globalparams.beginLOP = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_BEGINLOP].range(31, 0);
	globalparams.endLOP = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_ENDLOP].range(31, 0);
	globalparams.numLOPs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_NUMLOPS].range(31, 0);
	globalparams.batch_range = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_BATCHRANGE].range(31, 0);
	globalparams.batch_range_kvs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_BATCHRANGE_KVS].range(31, 0);
	globalparams.batch_range_pow = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_BATCHRANGE_POW].range(31, 0);
	globalparams.applyvertexbuffersz = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_APPLYVERTEXBUFFERSZ].range(31, 0);
	globalparams.applyvertexbuffersz_kvs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_APPLYVERTEXBUFFERSZ_KVS].range(31, 0);
	#else 
	globalparams.command = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_COMMANDID].data[0].key;
	globalparams.runkernelcommand = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_RUNKERNELCOMMANDID].data[0].key;
	globalparams.processcommand = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_PROCESSCOMMANDID].data[0].key;
	globalparams.collectstatscommand = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_COLLECTSTATSCOMMANDID].data[0].key;
	globalparams.partitioncommand = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_PARTITIONCOMMANDID].data[0].key;
	globalparams.reducecommand = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_APPLYUPDATESCOMMANDID].data[0].key;
	globalparams.finalnumpartitions = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_FINALNUMPARTITIONSID].data[0].key;
	globalparams.treedepthid = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_TREEDEPTHID].data[0].key;
	globalparams.ssdpartitionid = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_SSDPARTITIONID].data[0].key;
	globalparams.srcvoffset = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_SRCVOFFSET].data[0].key;
	globalparams.srcvsize = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_SRCVSIZE].data[0].key;
	globalparams.srcvsize_kvs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_SRCVSIZE_KVS].data[0].key;
	globalparams.edgessize = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_EDGESSIZE].data[0].key;
	globalparams.edgessize_kvs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_EDGESSIZE_KVS].data[0].key;
	globalparams.destvoffset = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_DESTVOFFSET].data[0].key;
	globalparams.actvvsize = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_ACTVVSIZE].data[0].key;
	globalparams.firstvid = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_FIRSTVID].data[0].key;
	globalparams.firstkey = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_FIRSTKEY].data[0].key;
	globalparams.firstvalue = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_FIRSTVALUE].data[0].key;
	globalparams.treedepth = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_TREEDEPTH].data[0].key;
	globalparams.LLOPnumpartitions = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_FINALNUMPARTITIONS].data[0].key;
	globalparams.batchsize = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_BATCHSIZE].data[0].key;
	globalparams.runsize = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_RUNSIZE].data[0].key;
	globalparams.runsize_kvs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_RUNSIZE_KVS].data[0].key;
	globalparams.nextbatchoffset = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_NEXTBATCHOFFSET].data[0].key;
	globalparams.GraphIter = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_GRAPHITERATIONID].data[0].key;
	globalparams.GraphAlgo = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_GRAPHALGORITHMID].data[0].key;
	globalparams.statsalreadycollected = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_STATSALREADYCOLLECTED].data[0].key;
	globalparams.groupid = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_GROUPID].data[0].key;
	globalparams.beginLOP = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_BEGINLOP].data[0].key;
	globalparams.endLOP = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_ENDLOP].data[0].key;
	globalparams.numLOPs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_NUMLOPS].data[0].key;
	globalparams.batch_range = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_BATCHRANGE].data[0].key;
	globalparams.batch_range_kvs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_BATCHRANGE_KVS].data[0].key;
	globalparams.batch_range_pow = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_BATCHRANGE_POW].data[0].key;
	globalparams.applyvertexbuffersz = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_APPLYVERTEXBUFFERSZ].data[0].key;
	globalparams.applyvertexbuffersz_kvs = kvdram[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_APPLYVERTEXBUFFERSZ_KVS].data[0].key;
	#endif 
	globalparams.baseaddr_destkvs_kvs = 0;
	#ifdef _DEBUGMODE_KERNELPRINTS2
	actsutilityobj->printglobalparameters("actslw_maxbutil::getglobalparams:: printing global parameters", globalparams);
	#endif
	return globalparams;
}
sweepparams_t 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
getsweepparams(globalparams_t globalparams, step_type currentLOP, batch_type source_partition){
	sweepparams_t sweepparams;
	batch_type sourceskipsize = getskipsize(currentLOP, SOURCE, globalparams);
	
	sweepparams.currentLOP = currentLOP;
	if((currentLOP % 2) == 1){ sweepparams.worksourcebaseaddress_kvs = BASEOFFSET_KVDRAM_KVS; sweepparams.workdestbaseaddress_kvs = BASEOFFSET_KVDRAMWORKSPACE_KVS; }
	else { sweepparams.worksourcebaseaddress_kvs = BASEOFFSET_KVDRAMWORKSPACE_KVS; sweepparams.workdestbaseaddress_kvs = BASEOFFSET_KVDRAM_KVS; }
	
	sweepparams.upperlimit = globalparams.destvoffset + (source_partition * sourceskipsize * (globalparams.batch_range / globalparams.LLOPnumpartitions));
	
	sweepparams.source_partition = source_partition;
	return sweepparams;
}
travstate_t 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
gettravstate(uint512_dt * kvdram, globalparams_t globalparams, step_type currentLOP, batch_type sourcestatsmarker){
	travstate_t travstate;
	keyvalue_t keyvalue;
	keyvalue_t nextkeyvalue;
	
	if(currentLOP == 0){ keyvalue.key = 0; }
	else if(currentLOP == 1){ keyvalue.key = 0; }
	#ifdef _WIDEWORD
	else { keyvalue.key = kvdram[BASEOFFSET_STATSDRAM_KVS + sourcestatsmarker].range(31, 0); 
		   keyvalue.value = kvdram[BASEOFFSET_STATSDRAM_KVS + sourcestatsmarker].range(63, 32); }
	#else 
	else { keyvalue = kvdram[BASEOFFSET_STATSDRAM_KVS + sourcestatsmarker].data[0]; }
	#endif 
	
	if(currentLOP == 0){ nextkeyvalue.key = globalparams.runsize; }
	else if(currentLOP == 1){ nextkeyvalue.key = globalparams.runsize; }
	else { nextkeyvalue.key = keyvalue.key + keyvalue.value; }
		
	travstate.begin_kvs = keyvalue.key / VECTOR_SIZE; 
	// travstate.end_kvs = nextkeyvalue.key / VECTOR_SIZE;
	travstate.end_kvs = (nextkeyvalue.key + (VECTOR_SIZE - 1)) / VECTOR_SIZE; // NEWCHANGE.
	travstate.size_kvs = travstate.end_kvs - travstate.begin_kvs;
	travstate.skip_kvs = SRCBUFFER_SIZE;
	travstate.i_kvs = travstate.begin_kvs;
	return travstate;	
}

{%for sw in context['NUMSUBWORKERS_seq']%}
// collect globalstats functions 
{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
readglobalstats{{inst}}{{sw}}(bool_type enable, uint512_dt * kvdram, keyvalue_t globalstatsbuffer[NUM_PARTITIONS], batch_type offset_kvs){
	if(enable == OFF){ return; }
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("readglobalstats{{inst}}", offset_kvs + NUM_PARTITIONS, BASEOFFSET_STATSDRAM_KVS + KVSTATSDRAMSZ_KVS + 1, NAp, NAp, NAp);
	#endif
	
	READGLOBALSTATS_LOOP: for (buffer_type i=0; i<NUM_PARTITIONS; i++){
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		globalstatsbuffer[i].key = kvdram[offset_kvs + i].range(31, 0);
		globalstatsbuffer[i].value = kvdram[offset_kvs + i].range(63, 32);
		#else 
		globalstatsbuffer[i] = kvdram[offset_kvs + i].data[0];
		#endif 
	}
	return;
}
{%endfor%}

{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif
collectglobalstats{{inst}}{{sw}}(bool_type enable, keyvalue_t sourcebuffer[VECTOR_SIZE][PADDEDDESTBUFFER_SIZE], keyvalue_t destbuffer[VECTOR_SIZE][PADDEDDESTBUFFER_SIZE], step_type currentLOP, vertex_t upperlimit, travstate_t travstate, globalparams_t globalparams){					
	if(enable == OFF){ return; }
	analysis_type analysis_srcbuffersz = SRCBUFFER_SIZE;
	buffer_type chunk_size = getchunksize_kvs(SRCBUFFER_SIZE, travstate, 0);

	COLLECTGLOBALSTATS_LOOP: for(buffer_type i=0; i<chunk_size; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_srcbuffersz avg=analysis_srcbuffersz	
	#pragma HLS PIPELINE II=3
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t keyvalue{{v}} = sourcebuffer[{{v}}][i];
		{%endfor%}
		
		{%for v in context['VECTOR_SIZE_seq']%}
		partition_type p{{v}} = 0;
		if(keyvalue{{v}}.key != INVALIDDATA){ p{{v}} = getpartition(keyvalue{{v}}, currentLOP, upperlimit, globalparams.batch_range_pow); }
		{%endfor%}
		
		{%for v in context['VECTOR_SIZE_seq']%}
		#ifdef _DEBUGMODE_CHECKS2
		actsutilityobj->checkoutofbounds("collectglobalstats{{inst}}. out of bounds for destbuffer[{{v}}]", p{{v}}, NUM_PARTITIONS, keyvalue{{v}}.key, globalparams.batch_range, NAp);
		#endif 
		if(keyvalue{{v}}.key != INVALIDDATA){ destbuffer[{{v}}][p{{v}}].value += 1; }
		{%endfor%}
	}
	return;
}
{%endfor%}

{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif
prepareglobalstats{{inst}}{{sw}}(bool_type enable, keyvalue_t buffer[VECTOR_SIZE][PADDEDDESTBUFFER_SIZE], keyvalue_t globalstatsbuffer[NUM_PARTITIONS], globalparams_t globalparams){
	if(enable == OFF){ return; }
	
	PREPAREGLOBALSTATS_LOOP1: for(vector_type v=0; v<VECTOR_SIZE; v++){
		PREPAREGLOBALSTATS_LOOP1B: for(buffer_type i=0; i<NUM_PARTITIONS; i++){
			globalstatsbuffer[i].value += buffer[v][i].value;
		}
	}
	return;
}
{%endfor%}

{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
saveglobalstats{{inst}}{{sw}}(bool_type enable, uint512_dt * kvdram, keyvalue_t globalstatsbuffer[NUM_PARTITIONS], batch_type offset_kvs){
	if(enable == OFF){ return; }
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("saveglobalstats{{inst}}", offset_kvs + NUM_PARTITIONS, BASEOFFSET_STATSDRAM_KVS + KVSTATSDRAMSZ_KVS + 1, offset_kvs, NUM_PARTITIONS, KVSTATSDRAMSZ_KVS);
	#endif
	
	SAVEGLOBALSTATS_LOOP: for (buffer_type i=0; i<NUM_PARTITIONS; i++){
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		kvdram[offset_kvs + i].range(31, 0) = globalstatsbuffer[i].key;
		kvdram[offset_kvs + i].range(63, 32) = globalstatsbuffer[i].value;
		#else 
		kvdram[offset_kvs + i].data[0] = globalstatsbuffer[i];
		#endif 
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalvar_savestats_counttotalstatswritten(VECTOR_SIZE);
		#endif
	}
	return;
}
{%endfor%}

// partition functions
{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
readkeyvalues{{inst}}{{sw}}(bool_type enable, uint512_dt * kvdram, keyvalue_t buffer[VECTOR_SIZE][PADDEDDESTBUFFER_SIZE], batch_type offset_kvs, travstate_t travstate){
	if(enable == OFF){ return; }
	analysis_type analysis_srcbuffersz = SRCBUFFER_SIZE;
	buffer_type chunk_size = getchunksize_kvs(SRCBUFFER_SIZE, travstate, 0);

	READKVS_LOOP: for (buffer_type i=0; i<chunk_size; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_srcbuffersz avg=analysis_srcbuffersz	
	#pragma HLS PIPELINE II=1
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer[{{v}}][i].key = kvdram[offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}});
		buffer[{{v}}][i].value = kvdram[offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}});
		{%endfor%}
		#else 
		{%for v in context['VECTOR_SIZE_seq']%}
		buffer[{{v}}][i] = kvdram[offset_kvs + i].data[{{v}}]; 
		{%endfor%}
		#endif 
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvsread(VECTOR_SIZE);
		#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	cout<<"readkeyvalues{{inst}}:: keyvalues read: offset: "<<offset_kvs * VECTOR_SIZE<<"-"<<(offset_kvs + chunk_size) * VECTOR_SIZE<<", number of keyvalues read: "<<(chunk_size * VECTOR_SIZE)<<endl;
	// cout<<"readkeyvalues{{inst}}:: keyvalues read: offset: "<<(offset_kvs - BASEOFFSET_EDGESDATA_KVS) * VECTOR_SIZE<<"-"<<(offset_kvs + chunk_size - BASEOFFSET_EDGESDATA_KVS) * VECTOR_SIZE<<", number of keyvalues read: "<<(chunk_size * VECTOR_SIZE)<<endl;
	#endif
	return;
}
{%endfor%}

{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif
partitionkeyvalues{{inst}}{{sw}}(bool_type enable, keyvalue_t sourcebuffer[VECTOR_SIZE][PADDEDDESTBUFFER_SIZE], keyvalue_t destbuffer[VECTOR_SIZE][PADDEDDESTBUFFER_SIZE], skeyvalue_t localcapsule[VECTOR_SIZE][NUM_PARTITIONS], step_type currentLOP, vertex_t upperlimit, travstate_t travstate, globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_srcbuffersz = SRCBUFFER_SIZE;
	buffer_type chunk_size = getchunksize_kvs(SRCBUFFER_SIZE, travstate, 0);

	resetmanykeyandvalues(localcapsule, NUM_PARTITIONS);
	
	PARTITIONKEYVALUES_LOOP1: for(step_type c=0; c<2; c++){
		PARTITIONKEYVALUES_LOOP1B: for(buffer_type i=0; i<chunk_size; i++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_srcbuffersz avg=analysis_srcbuffersz	
		#pragma HLS PIPELINE II=2
			{%for v in context['VECTOR_SIZE_seq']%}
			keyvalue_t keyvalue{{v}} = sourcebuffer[{{v}}][i];
			{%endfor%}
			
			{%for v in context['VECTOR_SIZE_seq']%}
			partition_type p{{v}} = 0;
			if(keyvalue{{v}}.key != INVALIDDATA){ p{{v}} = getpartition(keyvalue{{v}}, currentLOP, upperlimit, globalparams.batch_range_pow); } 
			{%endfor%}
			
			#ifdef _DEBUGMODE_CHECKS2
			{%for v in context['VECTOR_SIZE_seq']%}
			actsutilityobj->checkoutofbounds("partitionkeyvalues{{inst}}", localcapsule[{{v}}][p{{v}}].key + localcapsule[{{v}}][p{{v}}].value, PADDEDDESTBUFFER_SIZE, NAp, NAp, NAp);
			{%endfor%}
			#endif
			{%for v in context['VECTOR_SIZE_seq']%}
			if(keyvalue{{v}}.key != INVALIDDATA){ destbuffer[{{v}}][localcapsule[{{v}}][p{{v}}].key + localcapsule[{{v}}][p{{v}}].value] = keyvalue{{v}}; }
			{%endfor%}
			
			#ifdef _DEBUGMODE_CHECKS2
			{%for v in context['VECTOR_SIZE_seq']%}
			actsutilityobj->checkoutofbounds("partitionkeyvalues{{inst}}", p{{v}}, NUM_PARTITIONS, NAp, NAp, NAp);
			{%endfor%}
			#endif
			{%for v in context['VECTOR_SIZE_seq']%}
			if(keyvalue{{v}}.key != INVALIDDATA){ localcapsule[{{v}}][p{{v}}].value += 1; }
			{%endfor%}
		}
		if(c==0){ calculatemanyunallignedoffsets(localcapsule, NUM_PARTITIONS, 0, 0); } 
		if(c==0){ resetmanyvalues(localcapsule, NUM_PARTITIONS); }
	}
	
	#ifdef _DEBUGMODE_STATS
	for(vector_type v=0; v<VECTOR_SIZE; v++){ actsutilityobj->globalvar_inmemory_counttotalvalidkeyvalues(actsutilityobj->ugetvaluecount((keyvalue_t *)localcapsule[v], NUM_PARTITIONS)); } // REMOVEME. unmatched data types
	#endif
	return;
}
{%endfor%}

{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
savekeyvalues{{inst}}{{sw}}(bool_type enable, uint512_dt * kvdram, keyvalue_t buffer[8][PADDEDDESTBUFFER_SIZE], keyvalue_t * globalcapsule, skeyvalue_t localcapsule[NUM_PARTITIONS], batch_type globalbaseaddress_kvs, globalparams_t globalparams){				
	if(enable == OFF){ return; }
	
	#ifdef _DEBUGMODE_CHECKS
	actsutilityobj->printkeyvalues("savekeyvalues{{inst}}::localcapsule", localcapsule, NUM_PARTITIONS);
	actsutilityobj->printvaluecount("savekeyvalues{{inst}}::localcapsule", localcapsule, NUM_PARTITIONS);
	actsutilityobj->scankeyvalues("savekeyvalues{{inst}}::buffer", (keyvalue_t *)buffer, localcapsule, NUM_PARTITIONS, globalparams.batch_range / NUM_PARTITIONS, actsutilityobj->getsweepparams().upperlimit);
	#endif 
	
	analysis_type analysis_destpartitionsz = PADDEDDESTBUFFER_SIZE / NUM_PARTITIONS;
	SAVEPARTITIONS_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){
		batch_type dramoffset_kvs = globalbaseaddress_kvs + ((globalcapsule[p].key + globalcapsule[p].value) / VECTOR_SIZE);
		buffer_type bramoffset_kvs = localcapsule[p].key / VECTOR_SIZE;
		buffer_type realsize_kvs = localcapsule[p].value / VECTOR_SIZE;
		buffer_type size_kvs = getpartitionwritesz(realsize_kvs, bramoffset_kvs);
		
		#ifdef _DEBUGMODE_CHECKS2
		actsutilityobj->checkoutofbounds("savekeyvalues{{inst}} 23", bramoffset_kvs + size_kvs, PADDEDDESTBUFFER_SIZE + 1, p, NAp, NAp);
		actsutilityobj->checkoutofbounds("savekeyvalues{{inst}} 25", ((globalcapsule[p].key + globalcapsule[p].value) / VECTOR_SIZE), KVDRAMSZ + 1, p, NAp, NAp);
		#endif
		SAVEPARTITIONS_LOOP1B: for(buffer_type i=0; i<size_kvs; i++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_destpartitionsz avg=analysis_destpartitionsz
		#pragma HLS PIPELINE II=1
			#ifdef _WIDEWORD
			{%for v in context['VECTOR_SIZE_seq']%}
			kvdram[dramoffset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = buffer[{{v}}][bramoffset_kvs + i].key; 
			kvdram[dramoffset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = buffer[{{v}}][bramoffset_kvs + i].value; 
			{%endfor%}
			#else 
			{%for v in context['VECTOR_SIZE_seq']%}
			kvdram[dramoffset_kvs + i].data[{{v}}] = buffer[{{v}}][bramoffset_kvs + i]; 
			{%endfor%}
			#endif 
			#ifdef _DEBUGMODE_STATS
			actsutilityobj->globalstats_countkvspartitionswritten_actual(VECTOR_SIZE);
			#endif
		}
		#ifdef _DEBUGMODE_STATS
		actsutilityobj->globalstats_countkvspartitionswritten(realsize_kvs * VECTOR_SIZE);
		#endif
	}
	SAVEPARTITIONS_LOOP2: for(partition_type p=0; p<NUM_PARTITIONS; p++){ globalcapsule[p].value += localcapsule[p].value; }
	
	#ifdef _DEBUGMODE_CHECKS2
	actsutilityobj->checkoutofbounds("savekeyvalues{{inst}}::globalcapsule 34", globalcapsule[NUM_PARTITIONS-1].key + globalcapsule[NUM_PARTITIONS-1].value, KVDRAMSZ, NAp, NAp, NAp);
	#endif
	return;
}
{%endfor%}

// in-memory partition functions
{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for n in context['4_seq']%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif
combineSetof1stoSetof2{{inst}}{{sw}}_I{{n}}(bool_type enable, keyvalue_t buffer_setof1M0[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof1M1[PADDEDDESTBUFFER_SIZE], 
															keyvalue_t buffer_setof2R0[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof2R1[PADDEDDESTBUFFER_SIZE], 
																skeyvalue_t localcapsuleM[NUM_PARTITIONS], skeyvalue_t localcapsuleN[NUM_PARTITIONS], skeyvalue_t localcapsuleR[NUM_PARTITIONS], globalparams_t globalparams){
	if(enable == OFF){ return; }
	analysis_type analysis_srcbuffersz = SRCBUFFER_SIZE / NUM_PARTITIONS;
	buffer_type index=0, begin=0, end=0;
	keyvalue_t NullKV; NullKV.key = INVALIDDATA; NullKV.value = INVALIDDATA;
	
	resetkeyandvalues(localcapsuleR, NUM_PARTITIONS);
	
	EXECUTE_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){
		buffer_type counter = 0;
		
		EXECUTE_LOOP1B: for(step_type i=0; i<2; i++){
			if(i==0){ begin = localcapsuleM[p].key; end = localcapsuleM[p].key + localcapsuleM[p].value; }
			else { begin = localcapsuleN[p].key; end = localcapsuleN[p].key + localcapsuleN[p].value; }
		
			EXECUTE_LOOP1C: for(buffer_type k=begin; k<end; k++){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_srcbuffersz avg=analysis_srcbuffersz	
			#pragma HLS PIPELINE II=1
				#ifdef _DEBUGMODE_CHECKS2
				actsutilityobj->checkoutofbounds("combineSetof1stoSetof2{{inst}}_I{{n}} 1", index, PADDEDDESTBUFFER_SIZE, NAp, NAp, NAp);
				actsutilityobj->checkoutofbounds("combineSetof1stoSetof2{{inst}}_I{{n}} 2", k, PADDEDDESTBUFFER_SIZE, NAp, NAp, NAp);
				#endif
				if(i==0){
					if(counter % 2 == 0){
						buffer_setof2R0[index] = buffer_setof1M0[k];
					} else {
						buffer_setof2R1[index] = buffer_setof1M0[k];
					}
				} else {
					if(counter % 2 == 0){
						buffer_setof2R0[index] = buffer_setof1M1[k];
					} else {
						buffer_setof2R1[index] = buffer_setof1M1[k];
					}
				}
				counter+=1; if(counter % 2 == 0){ index++; }
			}
		}
		
		localcapsuleR[p].value = localcapsuleM[p].value + localcapsuleN[p].value; 
		if(counter % 2 != 0){ buffer_setof2R1[index] = NullKV; localcapsuleR[p].value += 1; index += 1; } // edge conditions
		#ifdef _DEBUGMODE_STATS
		if(counter % 2 != 0){ actsutilityobj->globalvar_savepartitions_countinvalids(1); }
		#endif 
	}
	
	calculateunallignedoffsets(localcapsuleR, NUM_PARTITIONS, 0, 0);
	#ifdef _DEBUGMODE_CHECKS
	actsutilityobj->scankeyvalues("combineSetof1stoSetof2{{inst}}_I{{n}}::buffer_setof2M", (keyvalue_t *)buffer_setof1M, localcapsuleM, NUM_PARTITIONS, globalparams.batch_range / NUM_PARTITIONS, actsutilityobj->getsweepparams().upperlimit);
	actsutilityobj->scankeyvalues("combineSetof1stoSetof2{{inst}}_I{{n}}::buffer_setof2", (keyvalue_t *)buffer_setof2, localcapsuleR, NUM_PARTITIONS, globalparams.batch_range / NUM_PARTITIONS, actsutilityobj->getsweepparams().upperlimit);
	#endif
	return;
}
{%endfor%}
{%for n in context['2_seq']%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif
combineSetof2stoSetof4{{inst}}{{sw}}_I{{n}}(bool_type enable, keyvalue_t buffer_setof2M0[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof2M1[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof2M2[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof2M3[PADDEDDESTBUFFER_SIZE], 
															keyvalue_t buffer_setof4R0[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof4R1[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof4R2[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof4R3[PADDEDDESTBUFFER_SIZE], 
																skeyvalue_t localcapsuleM[NUM_PARTITIONS], skeyvalue_t localcapsuleN[NUM_PARTITIONS], skeyvalue_t localcapsuleR[NUM_PARTITIONS], globalparams_t globalparams){			
	if(enable == OFF){ return; }
	analysis_type analysis_srcbuffersz = SRCBUFFER_SIZE / NUM_PARTITIONS;
	buffer_type index=0, begin=0, end=0;
	keyvalue_t NullKV; NullKV.key = INVALIDDATA; NullKV.value = INVALIDDATA;
	
	resetkeyandvalues(localcapsuleR, NUM_PARTITIONS);
	
	EXECUTE_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){
		buffer_type counter = 0;
		
		EXECUTE_LOOP1B: for(step_type i=0; i<2; i++){
			
			if(i==0){ begin = localcapsuleM[p].key / 2; end = (localcapsuleM[p].key + localcapsuleM[p].value) / 2; }
			else { begin = localcapsuleN[p].key / 2; end = (localcapsuleN[p].key + localcapsuleN[p].value) / 2; }
			
			EXECUTE_LOOP1C: for(buffer_type k=begin; k<end; k++){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_srcbuffersz avg=analysis_srcbuffersz	
			#pragma HLS PIPELINE II=1
				#ifdef _DEBUGMODE_CHECKS2
				actsutilityobj->checkoutofbounds("combineSetof2stoSetof4{{inst}}_I{{n}} 1", index, PADDEDDESTBUFFER_SIZE, NAp, NAp, NAp);
				actsutilityobj->checkoutofbounds("combineSetof2stoSetof4{{inst}}_I{{n}} 2", k, PADDEDDESTBUFFER_SIZE, NAp, NAp, NAp);
				#endif
				if(i==0){
					if(counter % 2 == 0){
						buffer_setof4R0[index] = buffer_setof2M0[k];
						buffer_setof4R1[index] = buffer_setof2M1[k]; 
					} else {
						buffer_setof4R2[index] = buffer_setof2M0[k];
						buffer_setof4R3[index] = buffer_setof2M1[k]; 
					}
				} else {
					if(counter % 2 == 0){
						buffer_setof4R0[index] = buffer_setof2M2[k];
						buffer_setof4R1[index] = buffer_setof2M3[k]; 
					} else {
						buffer_setof4R2[index] = buffer_setof2M2[k];
						buffer_setof4R3[index] = buffer_setof2M3[k]; 
					}
				}
				counter+=1; if(counter % 2 == 0){ index++; }
			}
		}
		
		localcapsuleR[p].value = localcapsuleM[p].value + localcapsuleN[p].value; 
		if(counter % 2 != 0){ buffer_setof4R2[index] = NullKV; buffer_setof4R3[index] = NullKV; localcapsuleR[p].value += 2; index += 1; } // edge conditions
		#ifdef _DEBUGMODE_STATS
		if(counter % 2 != 0){ actsutilityobj->globalvar_savepartitions_countinvalids(2); }
		#endif 
	}
	
	calculateunallignedoffsets(localcapsuleR, NUM_PARTITIONS, 0, 0);
	#ifdef _DEBUGMODE_CHECKS
	actsutilityobj->scankeyvalues("combineSetof2stoSetof4{{inst}}_I{{n}}::buffer_setof2M", (keyvalue_t *)buffer_setof2M, localcapsuleM, NUM_PARTITIONS, globalparams.batch_range / NUM_PARTITIONS, actsutilityobj->getsweepparams().upperlimit);
	actsutilityobj->scankeyvalues("combineSetof2stoSetof4{{inst}}_I{{n}}::buffer_setof2N", (keyvalue_t *)buffer_setof2N, localcapsuleN, NUM_PARTITIONS, globalparams.batch_range / NUM_PARTITIONS, actsutilityobj->getsweepparams().upperlimit);
	actsutilityobj->scankeyvalues("combineSetof2stoSetof4{{inst}}_I{{n}}::buffer_setof4", (keyvalue_t *)buffer_setof4, localcapsuleR, NUM_PARTITIONS, globalparams.batch_range / NUM_PARTITIONS, actsutilityobj->getsweepparams().upperlimit);
	#endif
	return;
}
{%endfor%}
{%for n in context['1_seq']%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif
combineSetof4stoSetof8{{inst}}{{sw}}_I{{n}}(bool_type enable, keyvalue_t buffer_setof4M0[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof4M1[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof4M2[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof4M3[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof4M4[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof4M5[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof4M6[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof4M7[PADDEDDESTBUFFER_SIZE],
															keyvalue_t buffer_setof8R0[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof8R1[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof8R2[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof8R3[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof8R4[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof8R5[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof8R6[PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof8R7[PADDEDDESTBUFFER_SIZE],
																skeyvalue_t localcapsuleM[NUM_PARTITIONS], skeyvalue_t localcapsuleN[NUM_PARTITIONS], skeyvalue_t localcapsuleR[NUM_PARTITIONS], globalparams_t globalparams){				
	if(enable == OFF){ return; }
	analysis_type analysis_srcbuffersz = SRCBUFFER_SIZE / NUM_PARTITIONS;
	buffer_type index=0, begin=0, end=0;
	keyvalue_t NullKV; NullKV.key = INVALIDDATA; NullKV.value = INVALIDDATA;
	
	resetkeyandvalues(localcapsuleR, NUM_PARTITIONS);
	
	EXECUTE_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){
		buffer_type counter = 0;
		
		EXECUTE_LOOP1B: for(step_type i=0; i<2; i++){
			if(i==0){ begin = localcapsuleM[p].key / 4; end = (localcapsuleM[p].key + localcapsuleM[p].value) / 4; }
			else { begin = localcapsuleN[p].key / 4; end = (localcapsuleN[p].key + localcapsuleN[p].value) / 4; }
			
			EXECUTE_LOOP1C: for(buffer_type k=begin; k<end; k++){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_srcbuffersz avg=analysis_srcbuffersz	
			#pragma HLS PIPELINE II=1
				#ifdef _DEBUGMODE_CHECKS2
				actsutilityobj->checkoutofbounds("combineSetof4stoSetof8{{inst}}_I{{n}} 1", index, PADDEDDESTBUFFER_SIZE, p, counter, NAp);
				actsutilityobj->checkoutofbounds("combineSetof4stoSetof8{{inst}}_I{{n}} 2", k, PADDEDDESTBUFFER_SIZE, p, counter, NAp);
				#endif 
				if(i==0){
					if(counter % 2 == 0){
						buffer_setof8R0[index] = buffer_setof4M0[k];
						buffer_setof8R1[index] = buffer_setof4M1[k]; 
						buffer_setof8R2[index] = buffer_setof4M2[k]; 
						buffer_setof8R3[index] = buffer_setof4M3[k];
					} else {
						buffer_setof8R4[index] = buffer_setof4M0[k];
						buffer_setof8R5[index] = buffer_setof4M1[k]; 
						buffer_setof8R6[index] = buffer_setof4M2[k]; 
						buffer_setof8R7[index] = buffer_setof4M3[k];
					}
				} else {
					if(counter % 2 == 0){
						buffer_setof8R0[index] = buffer_setof4M4[k];
						buffer_setof8R1[index] = buffer_setof4M5[k]; 
						buffer_setof8R2[index] = buffer_setof4M6[k]; 
						buffer_setof8R3[index] = buffer_setof4M7[k];
					} else {
						buffer_setof8R4[index] = buffer_setof4M4[k];
						buffer_setof8R5[index] = buffer_setof4M5[k]; 
						buffer_setof8R6[index] = buffer_setof4M6[k]; 
						buffer_setof8R7[index] = buffer_setof4M7[k];
					}
				}
				counter+=1; if(counter % 2 == 0){ index++; }
			}
		}
		
		localcapsuleR[p].value = localcapsuleM[p].value + localcapsuleN[p].value; 
		if(counter % 2 != 0){ buffer_setof8R4[index] = NullKV; buffer_setof8R5[index] = NullKV; 
			buffer_setof8R6[index] = NullKV; buffer_setof8R7[index] = NullKV;
			localcapsuleR[p].value += 4; index += 1; }
		#ifdef _DEBUGMODE_STATS
		if(counter % 2 != 0){ actsutilityobj->globalvar_savepartitions_countinvalids(4); }
		#endif 
	}
	
	calculateunallignedoffsets(localcapsuleR, NUM_PARTITIONS, 0, 0);
	#ifdef _DEBUGMODE_CHECKS
	actsutilityobj->scankeyvalues("combineSetof4stoSetof8{{inst}}_I{{n}}::buffer_setof2M", (keyvalue_t *)buffer_setof8, localcapsuleR, NUM_PARTITIONS, globalparams.batch_range / NUM_PARTITIONS, actsutilityobj->getsweepparams().upperlimit);
	#endif
	return;
}
{%endfor%}
{%endfor%}

// group functions
{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif
combineSetof1stoSetof2s{{inst}}{{sw}}(bool_type enable, keyvalue_t buffer_setof1[8][PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof2[8][PADDEDDESTBUFFER_SIZE], skeyvalue_t templocalcapsule_so1[8][NUM_PARTITIONS], skeyvalue_t templocalcapsule_so2[4][NUM_PARTITIONS], globalparams_t globalparams){
	// #pragma HLS INLINE
	// 1s->2s
	combineSetof1stoSetof2{{inst}}{{sw}}_I0(enable, buffer_setof1[0], buffer_setof1[1], buffer_setof2[0], buffer_setof2[1], templocalcapsule_so1[0], templocalcapsule_so1[1], templocalcapsule_so2[0], globalparams);
	combineSetof1stoSetof2{{inst}}{{sw}}_I1(enable, buffer_setof1[2], buffer_setof1[3], buffer_setof2[2], buffer_setof2[3], templocalcapsule_so1[2], templocalcapsule_so1[3], templocalcapsule_so2[1], globalparams);
	combineSetof1stoSetof2{{inst}}{{sw}}_I2(enable, buffer_setof1[4], buffer_setof1[5], buffer_setof2[4], buffer_setof2[5], templocalcapsule_so1[4], templocalcapsule_so1[5], templocalcapsule_so2[2], globalparams);
	combineSetof1stoSetof2{{inst}}{{sw}}_I3(enable, buffer_setof1[6], buffer_setof1[7], buffer_setof2[6], buffer_setof2[7], templocalcapsule_so1[6], templocalcapsule_so1[7], templocalcapsule_so2[3], globalparams);
	return;
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif
combineSetof2stoSetof4s{{inst}}{{sw}}(bool_type enable, keyvalue_t buffer_setof2[8][PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof4[8][PADDEDDESTBUFFER_SIZE], skeyvalue_t templocalcapsule_so2[4][NUM_PARTITIONS], skeyvalue_t templocalcapsule_so4[2][NUM_PARTITIONS], globalparams_t globalparams){
	// #pragma HLS INLINE
	// 2s->4s
	combineSetof2stoSetof4{{inst}}{{sw}}_I0(enable, buffer_setof2[0], buffer_setof2[1], buffer_setof2[2], buffer_setof2[3], buffer_setof4[0], buffer_setof4[1], buffer_setof4[2], buffer_setof4[3], templocalcapsule_so2[0], templocalcapsule_so2[1], templocalcapsule_so4[0], globalparams);
	combineSetof2stoSetof4{{inst}}{{sw}}_I1(enable, buffer_setof2[4], buffer_setof2[5], buffer_setof2[6], buffer_setof2[7], buffer_setof4[4], buffer_setof4[5], buffer_setof4[6], buffer_setof4[7], templocalcapsule_so2[2], templocalcapsule_so2[3], templocalcapsule_so4[1], globalparams);
	return;
}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif
combineSetof4stoSetof8s{{inst}}{{sw}}(bool_type enable, keyvalue_t buffer_setof4[8][PADDEDDESTBUFFER_SIZE], keyvalue_t buffer_setof8[8][PADDEDDESTBUFFER_SIZE], skeyvalue_t templocalcapsule_so4[2][NUM_PARTITIONS], skeyvalue_t templocalcapsule_so8[NUM_PARTITIONS], globalparams_t globalparams){
	// #pragma HLS INLINE
	// 4s->8s
	combineSetof4stoSetof8{{inst}}{{sw}}_I0(enable, buffer_setof4[0], buffer_setof4[1], buffer_setof4[2], buffer_setof4[3], buffer_setof4[4], buffer_setof4[5], buffer_setof4[6], buffer_setof4[7], 
												buffer_setof8[0], buffer_setof8[1], buffer_setof8[2], buffer_setof8[3], buffer_setof8[4], buffer_setof8[5], buffer_setof8[6], buffer_setof8[7], 
													templocalcapsule_so4[0], templocalcapsule_so4[1], templocalcapsule_so8, globalparams);
	return;
}
{%endfor%}
{%endfor%}

// main function
{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void 
	#ifdef SW 
	actslw_maxbutil::
	#endif 
maxdispatch{{inst}}({%for sw in context['NUMSUBWORKERS_seq']%} {%if(sw>0)%},{%endif%}uint512_dt * kvdram{{sw}} {%endfor%}){
	analysis_type analysis_collectstatsloop = KVDATA_BATCHSIZE_KVS / (SRCBUFFER_SIZE * 1); // NUMSUBWORKERS
	analysis_type analysis_partitionloop = KVDATA_BATCHSIZE_KVS / (SRCBUFFER_SIZE * NUMPIPELINES * 1); // NUMSUBWORKERS
	analysis_type analysis_reduceloop = KVDATA_BATCHSIZE_KVS / SRCBUFFER_SIZE;
	analysis_type analysis_processedges_overallloop = BATCH_RANGE_KVS / PADDEDDESTBUFFER_SIZE;
	analysis_type analysis_processedges_loadedgebatch = 1;
	analysis_type analysis_numllops = 1;
	analysis_type analysis_numsourcepartitions = 1;
	#if defined(_DEBUGMODE_KERNELPRINTS)
	actsutilityobj->printparameters();
	actsutilityobj->printglobalvars();
	#endif 
	#if defined(_DEBUGMODE_KERNELPRINTS2) || defined(_DEBUGMODE_CHECKS2)
	actsutilityobj->clearglobalvars();
	#endif
		
	{%for sw in context['NUMSUBWORKERS_seq']%}
	keyvalue_t sourcebuffer{{sw}}[VECTOR_SIZE][PADDEDDESTBUFFER_SIZE];
	#pragma HLS array_partition variable = sourcebuffer{{sw}}
	
	keyvalue_t buffer{{sw}}_setof1[8][PADDEDDESTBUFFER_SIZE];
	#pragma HLS array_partition variable = buffer{{sw}}_setof1
	skeyvalue_t templocalcapsule{{sw}}_so1[8][NUM_PARTITIONS];
	#pragma HLS array_partition variable = templocalcapsule{{sw}}_so1
	
	keyvalue_t buffer{{sw}}_setof2[8][PADDEDDESTBUFFER_SIZE];
	#pragma HLS array_partition variable = buffer{{sw}}_setof2
	skeyvalue_t templocalcapsule{{sw}}_so2[4][NUM_PARTITIONS];
	#pragma HLS array_partition variable = templocalcapsule{{sw}}_so2
	
	keyvalue_t buffer{{sw}}_setof4[8][PADDEDDESTBUFFER_SIZE];
	#pragma HLS array_partition variable = buffer{{sw}}_setof4
	skeyvalue_t templocalcapsule{{sw}}_so4[2][NUM_PARTITIONS];
	#pragma HLS array_partition variable = templocalcapsule{{sw}}_so4
	
	keyvalue_t buffer{{sw}}_setof8[8][PADDEDDESTBUFFER_SIZE];
	#pragma HLS array_partition variable = buffer{{sw}}_setof8
	skeyvalue_t templocalcapsule{{sw}}_so8[NUM_PARTITIONS];

	keyvalue_t globalstatsbuffer{{sw}}[NUM_PARTITIONS];
	batch_type skipsizes{{sw}}[NUM_PARTITIONS];
	#ifdef _DEBUGMODE_CHECKS2
	keyvalue_t BIGKV{{sw}}[NUM_PARTITIONS];
	#endif
	{%endfor%}
	
	{%for sw in context['NUMSUBWORKERS_seq']%}
	batch_type sourcestatsmarker{{sw}} = 0;
	batch_type deststatsmarker{{sw}} = 1;
	batch_type destoffset{{sw}} = 0;
	config_t config{{sw}};
	globalparams_t globalparams{{sw}} = getglobalparams(kvdram{{sw}});
	sweepparams_t sweepparams{{sw}};
	#ifdef _DEBUGMODE_CHECKS2
	if(globalparams{{sw}}.runsize >= MAXKVDATA_BATCHSIZE){ cout<<"maxdispatch:ERROR. runsize too large!. globalparams{{sw}}.runsize: "<<globalparams{{sw}}.runsize<<", MAXKVDATA_BATCHSIZE: "<<MAXKVDATA_BATCHSIZE<<". EXITING"<<endl; exit(EXIT_FAILURE); }
	#endif
	{%endfor%}
	
	// start launch
	MAIN_LOOP1: for(step_type currentLOP=globalparams0.beginLOP; currentLOP<(globalparams0.beginLOP + globalparams0.numLOPs); currentLOP++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_numllops avg=analysis_numllops	
	
		batch_type num_source_partitions = get_num_source_partitions(currentLOP);
		{%for sw in context['NUMSUBWORKERS_seq']%}
		destoffset{{sw}} = 0;
		{%endfor%}
		
		MAIN_LOOP1B: for(batch_type source_partition=0; source_partition<num_source_partitions; source_partition+=1){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_numsourcepartitions avg=analysis_numsourcepartitions	
		
			{%for sw in context['NUMSUBWORKERS_seq']%}
			resetmanykeyandvalues(buffer{{sw}}_setof1, NUM_PARTITIONS);
			resetmanykeyandvalues(globalstatsbuffer{{sw}}, NUM_PARTITIONS);
			{%endfor%}
			
			{%for sw in context['NUMSUBWORKERS_seq']%}
			sweepparams{{sw}} = getsweepparams(globalparams{{sw}}, currentLOP, source_partition);
			travstate_t travstate{{sw}} = gettravstate(kvdram{{sw}}, globalparams{{sw}}, currentLOP, sourcestatsmarker{{sw}});
			travstate_t CStravstate{{sw}} = travstate{{sw}};
			travstate_t Ptravstate{{sw}} = travstate{{sw}};
			travstate_t Rtravstate{{sw}} = travstate{{sw}};
			travstate_t AVtravstate{{sw}};
			#ifdef _DEBUGMODE_KERNELPRINTS2
			actsutilityobj->setstructs(config{{sw}}, sweepparams{{sw}}, travstate{{sw}});
			#endif
			{%endfor%}
			
			// collect stats
			#ifdef COLLECTSTATS
			{%for sw in context['NUMSUBWORKERS_seq']%}
			if(currentLOP >= 1 && currentLOP <= globalparams{{sw}}.treedepth){ config{{sw}}.enableprocessedges = OFF; config{{sw}}.enablecollectglobalstats = ON; config{{sw}}.enablepartition = OFF; config{{sw}}.enablereduce = OFF; } 
			else { CStravstate{{sw}}.begin_kvs = 0; CStravstate{{sw}}.end_kvs = 0; config{{sw}}.enablecollectglobalstats = OFF; }
			#ifdef _DEBUGMODE_KERNELPRINTS2
			if(config{{sw}}.enablecollectglobalstats == ON){ actsutilityobj->print7("### maxdispatch{{inst}}::collectgstats:: source_p", "upperlimit", "begin", "end", "size", "dest range", "currentLOP", sweepparams{{sw}}.source_partition, sweepparams{{sw}}.upperlimit, CStravstate{{sw}}.begin_kvs * VECTOR_SIZE, CStravstate{{sw}}.end_kvs * VECTOR_SIZE, (CStravstate{{sw}}.end_kvs - CStravstate{{sw}}.begin_kvs) * VECTOR_SIZE, BATCH_RANGE / (1 << (NUM_PARTITIONS_POW * sweepparams{{sw}}.currentLOP)), sweepparams{{sw}}.currentLOP); }					
			#endif
			{%endfor%}
			MAIN_LOOP1C_COLLECTGLOBALSTATS: for(batch_type offset_kvs=CStravstate0.begin_kvs; offset_kvs<CStravstate0.end_kvs; offset_kvs+=CStravstate0.skip_kvs * 1){ // NUMSUBWORKERS
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_collectstatsloop avg=analysis_collectstatsloop
				#ifdef _DEBUGMODE_KERNELPRINTS
				actsutilityobj->print4("### maxdispatch{{inst}}::collectglobalstats:: offset_kvs", "begin_kvs", "end_kvs", "skip", offset_kvs, CStravstate{{sw}}.begin_kvs, CStravstate{{sw}}.end_kvs, SRCBUFFER_SIZE);
				#endif
				
				{%for sw in context['NUMSUBWORKERS_seq']%}
				CStravstate{{sw}}.i_kvs = offset_kvs;
				{%endfor%}
				
				{%for sw in context['NUMSUBWORKERS_seq']%}
				readkeyvalues{{inst}}{{sw}}(ON, kvdram{{sw}}, sourcebuffer{{sw}}, (sweepparams{{sw}}.worksourcebaseaddress_kvs + offset_kvs), CStravstate{{sw}});
				{%endfor%}
				
				{%for sw in context['NUMSUBWORKERS_seq']%}
				collectglobalstats{{inst}}{{sw}}(ON, sourcebuffer{{sw}}, buffer{{sw}}_setof1, sweepparams{{sw}}.currentLOP, sweepparams{{sw}}.upperlimit, CStravstate{{sw}}, globalparams{{sw}});
				{%endfor%}
			}
			{%for sw in context['NUMSUBWORKERS_seq']%}
			prepareglobalstats{{inst}}{{sw}}(config{{sw}}.enablecollectglobalstats, buffer{{sw}}_setof1, globalstatsbuffer{{sw}}, globalparams{{sw}});
			for(partition_type p=0; p<NUM_PARTITIONS; p++){ batch_type A = (globalstatsbuffer{{sw}}[p].value + (VECTOR_SIZE-1)) / VECTOR_SIZE; batch_type B = (A + (SRCBUFFER_SIZE-1)) / SRCBUFFER_SIZE; if(B < 80){ B = B * 2; } batch_type C = ((4 * 4 * 2) * NUM_PARTITIONS) + VECTOR_SIZE; skipsizes{{sw}}[p] = (B * C) + 128; } //'128' is safety padd // FIXME. REMOVEME.
			{%endfor%}
			
			{%for sw in context['NUMSUBWORKERS_seq']%}
			#ifdef _DEBUGMODE_CHECKS2
			resetvalues(BIGKV{{sw}}, NUM_PARTITIONS);
			for(partition_type p=0; p<NUM_PARTITIONS; p++){ BIGKV{{sw}}[p].value = globalstatsbuffer{{sw}}[p].value + skipsizes{{sw}}[p]; }
			#endif
			calculateoffsets(globalstatsbuffer{{sw}}, NUM_PARTITIONS, destoffset{{sw}}, skipsizes{{sw}});
			resetvalues(globalstatsbuffer{{sw}}, NUM_PARTITIONS);
			saveglobalstats{{inst}}{{sw}}(config{{sw}}.enablecollectglobalstats, kvdram{{sw}}, globalstatsbuffer{{sw}}, BASEOFFSET_STATSDRAM_KVS + deststatsmarker{{sw}});
			{%endfor%}
			#endif 
			
			// partition
			#ifdef PARTITIONUPDATES
			{%for sw in context['NUMSUBWORKERS_seq']%}
			if((currentLOP >= 1) && (currentLOP <= globalparams{{sw}}.treedepth) && (Ptravstate{{sw}}.size_kvs > 0)){ config{{sw}}.enableprocessedges = OFF; config{{sw}}.enablecollectglobalstats = OFF; config{{sw}}.enablepartition = ON; config{{sw}}.enablereduce = OFF; } 
			else { Ptravstate{{sw}}.begin_kvs = 0; Ptravstate{{sw}}.end_kvs = 0; config{{sw}}.enablepartition = OFF; }
			travstate_t Ptravstate{{sw}}pp0 = Ptravstate{{sw}};
			travstate_t Ptravstate{{sw}}pp1 = Ptravstate{{sw}};
			travstate_t Ptravstate{{sw}}pp2 = Ptravstate{{sw}};
			#ifdef _DEBUGMODE_KERNELPRINTS2
			if((currentLOP >= 1) && (currentLOP <= globalparams{{sw}}.treedepth)){ actsutilityobj->print7("### maxdispatch{{inst}}::partition:: source_p", "upperlimit", "begin", "end", "size", "dest range", "currentLOP", sweepparams{{sw}}.source_partition, sweepparams{{sw}}.upperlimit, Ptravstate{{sw}}.begin_kvs * VECTOR_SIZE, Ptravstate{{sw}}.end_kvs * VECTOR_SIZE, Ptravstate{{sw}}.size_kvs * VECTOR_SIZE, BATCH_RANGE / (1 << (NUM_PARTITIONS_POW * sweepparams{{sw}}.currentLOP)), sweepparams{{sw}}.currentLOP); }	
			#endif
			readglobalstats{{inst}}{{sw}}(config{{sw}}.enablepartition, kvdram{{sw}}, globalstatsbuffer{{sw}}, BASEOFFSET_STATSDRAM_KVS + deststatsmarker{{sw}});
			resetvalues(globalstatsbuffer{{sw}}, NUM_PARTITIONS);
			{%endfor%}
			MAIN_LOOP1D_PARTITION: for(batch_type offset_kvs=Ptravstate0.begin_kvs; offset_kvs<Ptravstate0.end_kvs; offset_kvs+=Ptravstate0.skip_kvs * NUMPIPELINES * 1){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_partitionloop avg=analysis_partitionloop
				#ifdef _DEBUGMODE_KERNELPRINTS2
				{%for sw in context['NUMSUBWORKERS_seq']%}
				actsutilityobj->print4("### maxdispatch{{inst}}::partition:: offset_kvs", "begin_kvs", "end_kvs", "skip", offset_kvs, Ptravstate{{sw}}.begin_kvs, Ptravstate{{sw}}.end_kvs, SRCBUFFER_SIZE);
				{%endfor%}
				#endif
				
				{%for sw in context['NUMSUBWORKERS_seq']%}
				Ptravstate{{sw}}.i_kvs = offset_kvs;
				Ptravstate{{sw}}pp0.i_kvs = offset_kvs;
				Ptravstate{{sw}}pp1.i_kvs = offset_kvs + SRCBUFFER_SIZE;
				Ptravstate{{sw}}pp2.i_kvs = offset_kvs + (2 * SRCBUFFER_SIZE);
				unsigned int en{{sw}}; if(offset_kvs == Ptravstate{{sw}}.begin_kvs){ en{{sw}} = OFF; } else { en{{sw}} = ON; }
				{%endfor%}
				
				{%for sw in context['NUMSUBWORKERS_seq']%}
				readkeyvalues{{inst}}{{sw}}(ON, kvdram{{sw}}, sourcebuffer{{sw}}, (sweepparams{{sw}}.worksourcebaseaddress_kvs + offset_kvs), Ptravstate{{sw}}pp0);
				#ifdef PP1 // pipeline overflow from bottom
				savekeyvalues{{inst}}{{sw}}(en{{sw}}, kvdram{{sw}}, buffer{{sw}}_setof8, globalstatsbuffer{{sw}}, templocalcapsule{{sw}}_so8, sweepparams{{sw}}.workdestbaseaddress_kvs, globalparams{{sw}});
				#endif
				#ifdef PP2 // pipeline overflow from bottom
				combineSetof4stoSetof8s{{inst}}{{sw}}(en{{sw}}, buffer{{sw}}_setof4, buffer{{sw}}_setof8, templocalcapsule{{sw}}_so4, templocalcapsule{{sw}}_so8, globalparams{{sw}});
				#endif
				{%endfor%}
				
				{%for sw in context['NUMSUBWORKERS_seq']%}
				partitionkeyvalues{{inst}}{{sw}}(ON, sourcebuffer{{sw}}, buffer{{sw}}_setof1, templocalcapsule{{sw}}_so1, sweepparams{{sw}}.currentLOP, sweepparams{{sw}}.upperlimit, Ptravstate{{sw}}pp0, globalparams{{sw}});
				#ifdef PP1
				readkeyvalues{{inst}}{{sw}}(ON, kvdram{{sw}}, sourcebuffer{{sw}}, (sweepparams{{sw}}.worksourcebaseaddress_kvs + offset_kvs + SRCBUFFER_SIZE), Ptravstate{{sw}}pp1);
				#endif
				#ifdef PP2 // pipeline overflow from bottom
				savekeyvalues{{inst}}{{sw}}(en{{sw}}, kvdram{{sw}}, buffer{{sw}}_setof8, globalstatsbuffer{{sw}}, templocalcapsule{{sw}}_so8, sweepparams{{sw}}.workdestbaseaddress_kvs, globalparams{{sw}});
				#endif
				{%endfor%}
				
				// 1s->2s
				{%for sw in context['NUMSUBWORKERS_seq']%}
				combineSetof1stoSetof2s{{inst}}{{sw}}(ON, buffer{{sw}}_setof1, buffer{{sw}}_setof2, templocalcapsule{{sw}}_so1, templocalcapsule{{sw}}_so2, globalparams{{sw}});
				#ifdef PP1
				partitionkeyvalues{{inst}}{{sw}}(ON, sourcebuffer{{sw}}, buffer{{sw}}_setof1, templocalcapsule{{sw}}_so1, sweepparams{{sw}}.currentLOP, sweepparams{{sw}}.upperlimit, Ptravstate{{sw}}pp1, globalparams{{sw}});
				#endif
				#ifdef PP2
				readkeyvalues{{inst}}{{sw}}(ON, kvdram{{sw}}, sourcebuffer{{sw}}, (sweepparams{{sw}}.worksourcebaseaddress_kvs + offset_kvs + SRCBUFFER_SIZE + SRCBUFFER_SIZE), Ptravstate{{sw}}pp2);
				#endif
				{%endfor%}
				
				// 2s->4s
				{%for sw in context['NUMSUBWORKERS_seq']%}
				combineSetof2stoSetof4s{{inst}}{{sw}}(ON, buffer{{sw}}_setof2, buffer{{sw}}_setof4, templocalcapsule{{sw}}_so2, templocalcapsule{{sw}}_so4, globalparams{{sw}});
				#ifdef PP1
				combineSetof1stoSetof2s{{inst}}{{sw}}(ON, buffer{{sw}}_setof1, buffer{{sw}}_setof2, templocalcapsule{{sw}}_so1, templocalcapsule{{sw}}_so2, globalparams{{sw}});
				#endif
				#ifdef PP2
				partitionkeyvalues{{inst}}{{sw}}(ON, sourcebuffer{{sw}}, buffer{{sw}}_setof1, templocalcapsule{{sw}}_so1, sweepparams{{sw}}.currentLOP, sweepparams{{sw}}.upperlimit, Ptravstate{{sw}}pp2, globalparams{{sw}});
				#endif
				{%endfor%}
				
				// 4s->8s
				{%for sw in context['NUMSUBWORKERS_seq']%}
				combineSetof4stoSetof8s{{inst}}{{sw}}(ON, buffer{{sw}}_setof4, buffer{{sw}}_setof8, templocalcapsule{{sw}}_so4, templocalcapsule{{sw}}_so8, globalparams{{sw}});
				#ifdef PP1
				combineSetof2stoSetof4s{{inst}}{{sw}}(ON, buffer{{sw}}_setof2, buffer{{sw}}_setof4, templocalcapsule{{sw}}_so2, templocalcapsule{{sw}}_so4, globalparams{{sw}});
				#endif
				#ifdef PP2
				combineSetof1stoSetof2s{{inst}}{{sw}}(ON, buffer{{sw}}_setof1, buffer{{sw}}_setof2, templocalcapsule{{sw}}_so1, templocalcapsule{{sw}}_so2, globalparams{{sw}});
				#endif
				{%endfor%}
				
				{%for sw in context['NUMSUBWORKERS_seq']%}
				savekeyvalues{{inst}}{{sw}}(ON, kvdram{{sw}}, buffer{{sw}}_setof8, globalstatsbuffer{{sw}}, templocalcapsule{{sw}}_so8, sweepparams{{sw}}.workdestbaseaddress_kvs, globalparams{{sw}});
				#ifdef PP1
				combineSetof4stoSetof8s{{inst}}{{sw}}(ON, buffer{{sw}}_setof4, buffer{{sw}}_setof8, templocalcapsule{{sw}}_so4, templocalcapsule{{sw}}_so8, globalparams{{sw}});
				#endif
				#ifdef PP2
				combineSetof2stoSetof4s{{inst}}{{sw}}(ON, buffer{{sw}}_setof2, buffer{{sw}}_setof4, templocalcapsule{{sw}}_so2, templocalcapsule{{sw}}_so4, globalparams{{sw}});
				#endif
				{%endfor%}
				///// overflow. pipeline continuing from top...
			}
			{%for sw in context['NUMSUBWORKERS_seq']%}
			#ifdef PP1 // pipeline overflow from bottom
			savekeyvalues{{inst}}{{sw}}(config{{sw}}.enablepartition, kvdram{{sw}}, buffer{{sw}}_setof8, globalstatsbuffer{{sw}}, templocalcapsule{{sw}}_so8, sweepparams{{sw}}.workdestbaseaddress_kvs, globalparams{{sw}});
			#endif
			#ifdef PP2 // pipeline overflow from bottom
			combineSetof4stoSetof8s{{inst}}{{sw}}(config{{sw}}.enablepartition, buffer{{sw}}_setof4, buffer{{sw}}_setof8, templocalcapsule{{sw}}_so4, templocalcapsule{{sw}}_so8, globalparams{{sw}});
			#endif
			{%endfor%}
			
			{%for sw in context['NUMSUBWORKERS_seq']%}
			#ifdef PP2 // pipeline overflow from bottom
			savekeyvalues{{inst}}{{sw}}(config{{sw}}.enablepartition, kvdram{{sw}}, buffer{{sw}}_setof8, globalstatsbuffer{{sw}}, templocalcapsule{{sw}}_so8, sweepparams{{sw}}.workdestbaseaddress_kvs, globalparams{{sw}});
			#endif
			{%endfor%}
			
			{%for sw in context['NUMSUBWORKERS_seq']%}
			saveglobalstats{{inst}}{{sw}}(config{{sw}}.enablepartition, kvdram{{sw}}, globalstatsbuffer{{sw}}, BASEOFFSET_STATSDRAM_KVS + deststatsmarker{{sw}});
			#if defined(_DEBUGMODE_CHECKS2) && defined(ENABLE_PERFECTACCURACY)
			if(config{{sw}}.enablereduce == OFF){ actsutilityobj->checkforgreaterthan("maxdispatch. comparing BIGKV{{sw}} & globalstatsbuffer{{sw}}", BIGKV, globalstatsbuffer{{sw}}, NUM_PARTITIONS); }
			#endif
			{%endfor%}
			#endif
			
			{%for sw in context['NUMSUBWORKERS_seq']%}
			if(currentLOP > 0){
				sourcestatsmarker{{sw}} += 1;
				deststatsmarker{{sw}} += NUM_PARTITIONS;
				destoffset{{sw}} = globalstatsbuffer{{sw}}[NUM_PARTITIONS-1].key + globalstatsbuffer{{sw}}[NUM_PARTITIONS-1].value + 64; }
			{%endfor%}
			
			#ifdef _DEBUGMODE_KERNELPRINTS2 // REMOVEME.
			{%for sw in context['NUMSUBWORKERS_seq']%}
			if(config{{sw}}.enablereduce == OFF){ actsutilityobj->printpartitionresult2(OFF, kvdram{{sw}}, globalstatsbuffer{{sw}}, sweepparams{{sw}}); }
			{%endfor%}
			#endif
		}
		#if defined(_DEBUGMODE_KERNELPRINTS2)
		actsutilityobj->printglobalvars();
		#endif 
		#if defined(_DEBUGMODE_KERNELPRINTS2) || defined(_DEBUGMODE_CHECKS2)
		actsutilityobj->clearglobalvars();
		#endif
	}
	#ifdef _DEBUGMODE_CHECKS
	{%for sw in context['NUMSUBWORKERS_seq']%}
	actsutilityobj->countvalueslessthan("maxdispatch", (value_t *)&kvdram{{sw}}[BASEOFFSET_VERTICESDATA_KVS], BATCH_RANGE, INFINITI);
	{%endfor%}
	#endif 
	return;
}
{%endfor%}

// top
extern "C" {
void 
	#ifdef SW 
	actslw_maxbutil:: 
	#endif
topkernel(
	{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	{%if(inst>0)%},{%endif%} {%for sw in context['NUMSUBWORKERS_seq']%} {%if(sw>0)%},{%endif%}uint512_dt * source{{inst_}}{{sw}}volume {%endfor%}
	{%endfor%}
	){
{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for sw in context['NUMSUBWORKERS_seq']%}
#pragma HLS INTERFACE m_axi port = source{{inst_}}{{sw}}volume offset = slave bundle = gmem{{inst*context['NUMSUBWORKERS'] + sw}} // max_read_burst_length=64 max_write_burst_length=64
{%endfor%}
{%endfor%}

{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for sw in context['NUMSUBWORKERS_seq']%}
#pragma HLS INTERFACE s_axilite port = source{{inst_}}{{sw}}volume bundle = control
{%endfor%}
{%endfor%}

#pragma HLS INTERFACE s_axilite port=return bundle=control

{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for sw in context['NUMSUBWORKERS_seq']%}
#pragma HLS DATA_PACK variable = source{{inst_}}{{sw}}volume
{%endfor%}
{%endfor%}
	
	#ifdef _DEBUGMODE_KERNELPRINTS3
	#ifdef _WIDEWORD
	{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	cout<<">>> Light weight ACTS MAXBUTIL (L2) Launched... size: "<<(unsigned int)(source{{inst_}}{{sw}}volume[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_RUNSIZE].range(31, 0))<<endl; 
	{%endfor%}
	{%endfor%}
	#else
	{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	cout<<">>> Light weight ACTS MAXBUTIL (L2) Launched... size: "<<source{{inst_}}{{sw}}volume[BASEOFFSET_MESSAGESDRAM_KVS + MESSAGES_RUNSIZE].data[0].key<<endl; 
	{%endfor%}
	{%endfor%}
	#endif
	#endif
	
	{%for inst, inst_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	maxdispatch{{inst}}({%for sw in context['NUMSUBWORKERS_seq']%} {%if(sw>0)%},{%endif%}source{{inst_}}{{sw}}volume {%endfor%});
	{%endfor%}
	return;
}
}








