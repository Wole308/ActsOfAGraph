#include <chrono>
#include <stdlib.h>
#include <ctime>
#include <map>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <vector>
#include <mutex>
#include <iostream>
#include <thread>
#include "../src/common.h"
// #include "../kernels/enigma.h"
#include "../kernels/acts.h"
#include "../kernels/kernelprocess.h"
#ifndef FPGA_IMPL
#include <chrono>
#endif 
using namespace std;

kernelprocess::kernelprocess(){ }
kernelprocess::~kernelprocess(){}

void kernelprocess::topkernel(
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		{%if(ddrs==0)%}{%else%},{%endif%}uint512_dt * kvsourcedram{{ddrs_}}
		{%endfor%}
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		,uint512_dt * kvdestdram{{ddrs_}}
		{%endfor%}
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		,keyvalue_t * kvstats{{ddrs_}}
		{%endfor%}
        ){
	#ifdef SW
	return kernelobj.topkernel(
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		{%if(ddrs==0)%}{%else%},{%endif%}kvsourcedram{{ddrs_}}
		{%endfor%}
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		,kvdestdram{{ddrs_}}
		{%endfor%}
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		,kvstats{{ddrs_}}
		{%endfor%}
        );
	#endif
}
void kernelprocess::topkernelMW(uint512_dt ** kvsourcedram, uint512_dt ** kvdestdram, keyvalue_t ** kvstats){
	#ifdef SW
	#if defined(TESTKERNEL) || defined(LOCKE)
	topkernel(kvsourcedram[0], kvdestdram[0], kvstats[0]);
	#else 
	for (int i = 0; i < NUMDRAMBANKS; i++){ acts_thread[i] = std::thread(&kernelprocess::topkernel, this, kvsourcedram[i], kvdestdram[i], kvstats[i]); }
	for (int i = 0; i < NUMDRAMBANKS; i++){ acts_thread[i].join(); }
	// for (int i = 0; i < NUMDRAMBANKS; i++){ topkernel(kvsourcedram[i], kvdestdram[i], kvstats[i]); }
	#endif
	#endif 
	return;
}




