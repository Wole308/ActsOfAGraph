#include "{{context['PROJECT_BASEPATH']}}/debugger/kernel_debugger.h"
#ifndef FPGA_IMPL
#include "{{context['PROJECT_BASEPATH']}}/kernels/kernelprocess.h"
#endif 
#ifndef FPGA_IMPL
#include <chrono>
#endif 
using namespace std;
// #define OOO
#define INVALIDDATA 0

#ifdef _DEBUGMODE_STATS
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
int kvpairsread{{ddrs}};
int kvpairswritten{{ddrs}};
int kvpairsread{{ddrs}}_transfers;
int kvpairswritten{{ddrs}}_transfers;
#ifdef _BUFFERB4WRITE
int kvpairswritten_bram2tmp{{ddrs}};
int kvpairswritten_tmp2dram{{ddrs}};
int kvpairswritten_bram2tmp{{ddrs}}_transfers;
int kvpairswritten_tmp2dram{{ddrs}}_transfers;
#endif
int kvpairswritten_interm2dest_parallel{{ddrs}};
int kvpairswritten_interm2dest_seqential{{ddrs}};
{%endfor%}
int INapplyphase;
edge_t numedgesprocessedPE;
vertex_t numverticesprocessedPE;
#endif
#ifdef _DEBUGMODE_CHECKS2
unsigned int state_i_kvs;
unsigned int state_ikvs_sz;
unsigned int state_moduleid;
unsigned int state_kvbuffer1_kvs_tracker;
#endif 

/// Utility Functions
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}printstate(){
	#ifdef _DEBUGMODE_CHECKS2
	cout<<">>> kernelprocess::printstate: "<<endl;
	cout<<">>> state_i_kvs: "<<state_i_kvs<<endl;
	cout<<">>> state_ikvs_sz: "<<state_ikvs_sz<<endl;
	cout<<">>> state_moduleid: "<<state_moduleid<<endl;
	cout<<">>> state_kvbuffer1_kvs_tracker: "<<state_kvbuffer1_kvs_tracker<<endl;
	cout<<">>> state_moduleid: "<<state_moduleid<<endl;
	cout<<">>> state_moduleid: "<<state_moduleid<<endl;
	cout<<">>> KVBUFFERSZ_KVS: "<<KVBUFFERSZ_KVS<<endl;
	#endif
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}ceildiv(unsigned int val1, unsigned int val2){
	return (val1 + (val2 - 1)) / val2;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}min8(unsigned int val0, unsigned int val1, unsigned int val2, unsigned int val3, unsigned int val4, unsigned int val5, unsigned int val6, unsigned int val7){
	unsigned int min = 7777777;	
	#ifdef _DEBUGMODE_CHECKS
	cout<<"min8: val0: "<<val0<<endl;
	cout<<"min8: val1: "<<val1<<endl;
	cout<<"min8: val2: "<<val2<<endl;
	cout<<"min8: val3: "<<val3<<endl;
	cout<<"min8: val4: "<<val4<<endl;
	cout<<"min8: val5: "<<val5<<endl;
	cout<<"min8: val6: "<<val6<<endl;
	cout<<"min8: val7: "<<val7<<endl;
	#endif	
	if(min > val0){ min = val0; }
	if(min > val1){ min = val1; }
	if(min > val2){ min = val2; }
	if(min > val3){ min = val3; }
	if(min > val4){ min = val4; }
	if(min > val5){ min = val5; }
	if(min > val6){ min = val6; }
	if(min > val7){ min = val7; }
	return min;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}min(unsigned int val1, unsigned int val2){
	if(val1 < val2){ return val1; }
	else { return val2; }
}
			
unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}max(unsigned int val1, unsigned int val2){
	if(val1 > val2){ return val1; }
	else { return val2; }
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}minorzero(int val1){
	if(val1 > 0){ return val1; }
	else { return 0; }
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}allignup_KV(unsigned int val){
	unsigned int fac = (val + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
	return (fac * VECTOR_SIZE);
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}alligndown_KV(unsigned int val){
	unsigned int fac = val / VECTOR_SIZE;
	return (fac * VECTOR_SIZE);
}

vertex_t {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(unsigned int ssdpartitonid){
	vertex_t range = 0;
	#ifdef _EVENWORLOADDISTRIBUTION
	if(ssdpartitonid < MAXNUMSSDPARTITIONS){
		range = KVDATA_RANGE_PERSSDPARTITION;
	} else { range = KVDATA_RANGE; } // NB: partitioning phase takes the DEFAULT
	#else
	range = KVDATA_RANGE_PERSSDPARTITION;
	else {
		range = KVDATA_RANGE; // NB: partitioning phase takes the DEFAULT
		#ifdef _DEBUGMODE_CHECKS2
		#ifndef PARTITION_PHASE
		std::cout<<"Kernel::GETKVDATA_RANGE_PERSSDPARTITION should never get here. {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION 45 "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
		#endif
	}
	#endif 
	return range;
}

vertex_t {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION_POW(unsigned int ssdpartitonid){
	return KVDATA_RANGE_PERSSDPARTITION_POW;
}

vertex_t {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION(unsigned int ssdpartitonid){
	return APPLYVERTEXBUFFERSZ_PERSSDPARTITION;
}

vertex_t {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(unsigned int ssdpartitonid){
	return APPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETTREEDEPTH(unsigned int ssdpartitonid){
	unsigned int depth = 0;
	#ifdef _EVENWORLOADDISTRIBUTION
	if(ssdpartitonid < MAXNUMSSDPARTITIONS){
		depth = TREEDEPTH_FORSSDPARTITION0;
	} else { depth = 1; } // NB: partitioning phase takes the DEFAULT
	#else 
	{%for ppid in context['MAXNUMSSDPARTITIONS_seq']%}
	{%if(ppid==0)%}{%else%}else {%endif%}if(ssdpartitonid == {{ppid}}){
		depth = TREEDEPTH_FORSSDPARTITION{{ppid}};
	}
	{%endfor%}
	else {
		// depth = TREEDEPTH_FORSSDPARTITION0;
		depth = 1; // NB: partitioning phase takes the DEFAULT
		#ifdef _DEBUGMODE_CHECKS2
		#ifndef PARTITION_PHASE
		std::cout<<"Kernel:: {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETTREEDEPTH should never get here.  {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETTREEDEPTH 45 "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
		#endif
	}
	#endif 
	return depth;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc(unsigned int currentLOP, keyvalue_t kventry, vertex_t upperlimit, vertex_t range){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc: kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<", range: "<<range<<std::endl;
	#endif

	unsigned int hashedval = 0;
	if(currentLOP == 1){
		hashedval = (kventry.key - upperlimit) / (range / NUM_PARTITIONS);
	} else if(currentLOP == 2){
		hashedval = (kventry.key - upperlimit) / ((range / NUM_PARTITIONS) / NUM_PARTITIONS);
	} else if(currentLOP == 3){
		hashedval = (kventry.key - upperlimit) / (((range / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS);
	} else if(currentLOP == 4){
		hashedval = (kventry.key - upperlimit) / ((((range / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS);
	} else if(currentLOP == 5){
		hashedval = (kventry.key - upperlimit) / (((((range / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS);
	} else {
		hashedval = 0; 
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc should never get here. {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc 45 "<<std::endl;
		exit(EXIT_FAILURE);
		#endif
	}
	#ifdef _DEBUGMODE_CHECKS2
	if(hashedval >= NUM_PARTITIONS){
		std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc:: out-of-bounds 45. hashedval: "<<hashedval<<", NUM_PARTITIONS: "<<NUM_PARTITIONS<<", kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<", range: "<<range<<", currentLOP: "<<currentLOP<<std::endl;
		exit(EXIT_FAILURE);
	}
	#endif
	if(hashedval >= FORCDFINISH_NUM_PARTITIONS){ hashedval = 0; }
	return hashedval;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc2(unsigned int currentLOP, keyvalue_t kventry, vertex_t upperlimit, unsigned int ssdpartitonid){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc2: kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<", ssdpartitonid: "<<ssdpartitonid<<std::endl;
	#endif

	unsigned int hashedval = 0;
	if(currentLOP == 1){
		hashedval = (kventry.key - upperlimit) / ({%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid) / NUM_PARTITIONS);		
	} else if(currentLOP == 2){
		hashedval = (kventry.key - upperlimit) / (({%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid) / NUM_PARTITIONS) / NUM_PARTITIONS);
	} else if(currentLOP == 3){
		hashedval = (kventry.key - upperlimit) / ((({%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid) / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS);
	} else if(currentLOP == 4){
		hashedval = (kventry.key - upperlimit) / (((({%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid) / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS);
	} else if(currentLOP == 5){
		hashedval = (kventry.key - upperlimit) / ((((({%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid) / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS) / NUM_PARTITIONS);
	} else {
		hashedval = 0; 
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc2 should never get here. {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc2 45 "<<std::endl;
		exit(EXIT_FAILURE);
		#endif
	}
	#ifdef _DEBUGMODE_CHECKS2
	if(hashedval >= NUM_PARTITIONS){
		std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc2:: out-of-bounds 45. hashedval: "<<hashedval<<", NUM_PARTITIONS: "<<NUM_PARTITIONS<<", kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<", ssdpartitonid: "<<ssdpartitonid<<", currentLOP: "<<currentLOP<<std::endl;
		exit(EXIT_FAILURE);
	}
	#endif
	if(hashedval >= FORCDFINISH_NUM_PARTITIONS){ hashedval = 0; }
	return hashedval;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc3(unsigned int currentLOP, keyvalue_t kventry, vertex_t upperlimit, unsigned int ssdpartitonid){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc3: kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<", ssdpartitonid: "<<ssdpartitonid<<std::endl;
	#endif

	unsigned int hashedval = 0;
	hashedval = (kventry.key - upperlimit) / ({%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid) / (1 << (NUM_PARTITIONS_POW * currentLOP)));
	#ifdef _DEBUGMODE_CHECKS2
	if(hashedval >= NUM_PARTITIONS){
		std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc3:: out-of-bounds 45. hashedval: "<<hashedval<<", NUM_PARTITIONS: "<<NUM_PARTITIONS<<", kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<", ssdpartitonid: "<<ssdpartitonid<<", currentLOP: "<<currentLOP<<std::endl;
		exit(EXIT_FAILURE);
	}
	#endif
	if(hashedval >= FORCDFINISH_NUM_PARTITIONS){ hashedval = 0; }
	return hashedval;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc4(unsigned int currentLOP, keyvalue_t kventry, vertex_t upperlimit, unsigned int ssdpartitonid){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc4: kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<", ssdpartitonid: "<<ssdpartitonid<<std::endl;
	#endif
	#ifdef _DEBUGMODE_CHECKS2
	if(kventry.key < upperlimit){
		if(kventry.key != INVALIDDATA){ std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc4:: out-of-bounds 44. kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<", ssdpartitonid: "<<ssdpartitonid<<", currentLOP: "<<currentLOP<<endl; }
		if(kventry.key != INVALIDDATA){ exit(EXIT_FAILURE); }
		// exit(EXIT_FAILURE);
	}
	#endif

	unsigned int hashedval = 0;
	hashedval = ((kventry.key - upperlimit) >> ({%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION_POW(ssdpartitonid) - (NUM_PARTITIONS_POW * currentLOP)));
	
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc4: kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<", ssdpartitonid: "<<ssdpartitonid<<", hashedval: "<<hashedval<<", currentLOP: "<<currentLOP<<", {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION_POW("<<ssdpartitonid<<"): "<<{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION_POW(ssdpartitonid)<<std::endl;
	#endif
	
	#ifdef _DEBUGMODE_CHECKS2
	if(hashedval >= NUM_PARTITIONS){
		if(kventry.key != INVALIDDATA){ std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc4:: out-of-bounds 45. hashedval: "<<hashedval<<", NUM_PARTITIONS: "<<NUM_PARTITIONS<<", kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<", ssdpartitonid: "<<ssdpartitonid<<", currentLOP: "<<currentLOP<<", {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION_POW("<<ssdpartitonid<<"): "<<{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION_POW(ssdpartitonid)<<", (NUM_PARTITIONS_POW * currentLOP): "<<(NUM_PARTITIONS_POW * currentLOP)<<", state_i_kvs: "<<state_i_kvs<<", state_ikvs_sz: "<<state_ikvs_sz<<std::endl;	}
		if(kventry.key != INVALIDDATA){ {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}printstate(); }
		if(kventry.key != INVALIDDATA){ exit(EXIT_FAILURE); }
		// exit(EXIT_FAILURE);
	}
	#endif
	if(hashedval >= FORCDFINISH_NUM_PARTITIONS){ hashedval = 0; }
	return hashedval;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc5(unsigned int currentLOP, keyvalue_t kventry, vertex_t upperlimit, unsigned int range){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc5: kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<std::endl;
	#endif

	unsigned int hashedval = 0;
	#pragma HLS RESOURCE variable=hashedval core=DivnS
	hashedval = (kventry.key - upperlimit) / range;
	#ifdef _DEBUGMODE_CHECKS2
	if(hashedval >= NUM_PARTITIONS){
		std::cout<<"Kernel::{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc5:: out-of-bounds 45. hashedval: "<<hashedval<<", NUM_PARTITIONS: "<<NUM_PARTITIONS<<", kventry.key: "<<kventry.key<<", upperlimit: "<<upperlimit<<", currentLOP: "<<currentLOP<<std::endl;
		exit(EXIT_FAILURE);
	}
	#endif
	if(hashedval >= FORCDFINISH_NUM_PARTITIONS){ hashedval = 0; }
	return hashedval;
}

keyvalue_t {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry(int addr, uint512_dt kvbuffer[KVSRCBUFFERSZ_KVS]){
	unsigned int idy = (addr / VECTOR_SIZE);
	unsigned int idx = ((addr * 2) % (VECTOR_SIZE * 2));
	unsigned int idx_plus1 = idx + 1;
	#ifdef _WIDEWORD
	keyvalue_t kventry;
	kventry.key = kvbuffer[(idy % FORCDFINISH_KVSRCBUFFERSZ_KVS)].range(DATATYPE_SIZE * (idx + 1) - 1, idx * DATATYPE_SIZE); 
	kventry.value = kvbuffer[(idy % FORCDFINISH_KVSRCBUFFERSZ_KVS)].range(DATATYPE_SIZE * (idx_plus1 + 1) - 1, idx_plus1 * DATATYPE_SIZE); 
	return kventry;
	#else 
	return kvbuffer[(idy % FORCDFINISH_KVSRCBUFFERSZ_KVS)].data[idx]; 
	#endif 
}

keyvalue_t {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII(int addr, uint512_dt kvbuffer[KVSRCBUFFERSZ_KVS]){
	if(addr >= FORCDFINISH_KVSRCBUFFERSZ){ addr = 0; }
	unsigned int idy = addr / VECTOR_SIZE;
	unsigned int idx = addr % VECTOR_SIZE;
	#ifdef _DEBUGMODE_CHECKS
	checkforoutofbounds_kernel(idy, KVSRCBUFFERSZ_KVS, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII 5", 0, 0, 0);
	checkforoutofbounds_kernel(idx, VECTOR_SIZE, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII 6", 0, 0, 0);
	#endif
	#ifdef _WIDEWORD
	keyvalue_t kventry;
	unsigned int ihi = ((VECTOR_SIZE - idx) * 32) - 1;
	unsigned int ilo = ihi - 31;
	#ifdef _DEBUGMODE_CHECKS
	checkforoutofbounds_kernel(ihi, DATAWIDTH, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII 7", 0, 0, 0);
	#endif
	{%for e in context['VECTOR_SIZE_seq']%}
	{%if(e>0)%}else {%endif%}if(idx=={{e}}){
		kventry.key = kvbuffer[idy].range({{(((e*2) * 32) + 31)}}, {{((e*2) * 32)}});
		kventry.value = kvbuffer[idy].range({{(((((e*2) * 32) + 31) + 1) + 31)}}, {{((((e*2) * 32) + 31) + 1)}});
	}
	{%endfor%}
	else {
		kventry.key = 0; 
		kventry.value = 0; 
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII:: out-of-bounds 45. "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	return kventry;
	#else
	return kvbuffer[idy].data[idx];
	#endif
}

keyvalue_t {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIII(int addr, uint512_dt kvbuffer[KVSRCBUFFERSZ_KVS]){
	#pragma HLS INLINE // "unlike {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIII, this is inlined"
	if(addr >= FORCDFINISH_KVSRCBUFFERSZ){ addr = 0; }
	unsigned int idy = addr / VECTOR_SIZE;
	unsigned int idx = addr % VECTOR_SIZE;
	#ifdef _DEBUGMODE_CHECKS
	checkforoutofbounds_kernel(idy, KVSRCBUFFERSZ_KVS, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIII:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIII 5", 0, 0, 0);
	checkforoutofbounds_kernel(idx, VECTOR_SIZE, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIII:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIII 6", 0, 0, 0);
	#endif
	#ifdef _WIDEWORD
	keyvalue_t kventry;
	unsigned int ihi = ((VECTOR_SIZE - idx) * 32) - 1;
	unsigned int ilo = ihi - 31;
	#ifdef _DEBUGMODE_CHECKS
	checkforoutofbounds_kernel(ihi, DATAWIDTH, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIII:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIII 7", 0, 0, 0);
	#endif
	{%for e in context['VECTOR_SIZE_seq']%}
	{%if(e>0)%}else {%endif%}if(idx=={{e}}){
		kventry.key = kvbuffer[idy].range({{(((e*2) * 32) + 31)}}, {{((e*2) * 32)}});
		kventry.value = kvbuffer[idy].range({{(((((e*2) * 32) + 31) + 1) + 31)}}, {{((((e*2) * 32) + 31) + 1)}});
	}
	{%endfor%}
	else {
		kventry.key = 0; 
		kventry.value = 0; 
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIII:: out-of-bounds 45. "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	return kventry;
	#else
	return kvbuffer[idy].data[idx];
	#endif
}

keyvalue_t {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIV(int addr, uint512_dt kvbuffer[APPLYVERTEXBUFFERSZ_KVS]){
	#pragma HLS INLINE
	if(addr >= APPLYVERTEXBUFFERSZ){ addr = 0; }
	unsigned int idy = addr / VECTOR_SIZE;
	unsigned int idx = addr % VECTOR_SIZE;
	#ifdef _DEBUGMODE_CHECKS
	checkforoutofbounds_kernel(idy, APPLYVERTEXBUFFERSZ_KVS, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIV:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIV 5", 0, 0, 0);
	checkforoutofbounds_kernel(idx, VECTOR_SIZE, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIV:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIV 6", 0, 0, 0);
	#endif
	#ifdef _WIDEWORD
	keyvalue_t kventry;
	unsigned int ihi = ((VECTOR_SIZE - idx) * 32) - 1;
	unsigned int ilo = ihi - 31;
	#ifdef _DEBUGMODE_CHECKS
	checkforoutofbounds_kernel(ihi, DATAWIDTH, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIV:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIV 7", 0, 0, 0);
	#endif
	{%for e in context['VECTOR_SIZE_seq']%}
	{%if(e>0)%}else {%endif%}if(idx=={{e}}){
		kventry.key = kvbuffer[idy].range({{(((e*2) * 32) + 31)}}, {{((e*2) * 32)}});
		kventry.value = kvbuffer[idy].range({{(((((e*2) * 32) + 31) + 1) + 31)}}, {{((((e*2) * 32) + 31) + 1)}});
	}
	{%endfor%}
	else {
		kventry.key = 0; 
		kventry.value = 0; 
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIV:: out-of-bounds 45. "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	return kventry;
	#else
	return kvbuffer[idy].data[idx];
	#endif
}

void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventry(uint512_dt kvbuffer[KVSRCBUFFERSZ_KVS], unsigned int addr, keyvalue_t kventry){
	unsigned int idy = (addr / VECTOR_SIZE);
	unsigned int idx = ((addr * 2) % (VECTOR_SIZE * 2));
	unsigned int idx_plus1 = idx + 1;
	#ifdef _WIDEWORD
	kvbuffer[(idy % FORCDFINISH_KVSRCBUFFERSZ_KVS)].range(DATATYPE_SIZE * (idx + 1) - 1, idx * DATATYPE_SIZE) = kventry.key; 
	kvbuffer[(idy % FORCDFINISH_KVSRCBUFFERSZ_KVS)].range(DATATYPE_SIZE * (idx_plus1 + 1) - 1, idx_plus1 * DATATYPE_SIZE) = kventry.value; 
	#else 
	kvbuffer[(idy % FORCDFINISH_KVSRCBUFFERSZ_KVS)].data[idx] = kventry; 
	#endif 
	return;
}

void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII(uint512_dt kvbuffer[KVSRCBUFFERSZ_KVS], unsigned int addr, keyvalue_t kventry){
	if(addr >= FORCDFINISH_KVSRCBUFFERSZ){ addr = 0; }
	unsigned int idy = addr / VECTOR_SIZE;
	unsigned int idx = addr % VECTOR_SIZE;
	#ifdef _DEBUGMODE_CHECKS
	checkforoutofbounds_kernel(idy, KVSRCBUFFERSZ_KVS, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII 5", 0, 0, 0);
	checkforoutofbounds_kernel(idx, VECTOR_SIZE, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII 6", 0, 0, 0);
	#endif
	#ifdef _WIDEWORD
	unsigned int ihi = ((VECTOR_SIZE - idx) * 32) - 1;
	unsigned int ilo = ihi - 31;
	#ifdef _DEBUGMODE_CHECKS
	checkforoutofbounds_kernel(ihi, DATAWIDTH, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII 7", 0, 0, 0);
	#endif
	{%for e in context['VECTOR_SIZE_seq']%}
	{%if(e>0)%}else {%endif%}if(idx=={{e}}){	
		kvbuffer[idy].range({{(((e*2) * 32) + 31)}}, {{((e*2) * 32)}}) = kventry.key;
		kvbuffer[idy].range({{(((((e*2) * 32) + 31) + 1) + 31)}}, {{((((e*2) * 32) + 31) + 1)}}) = kventry.value;
	}
	{%endfor%}
	else {
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII:: out-of-bounds 45. "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	#else
	kvbuffer[idy].data[idx] = kventry;
	#endif
	return;
}

void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryIII(
		{%for vec in context['VECTOR_SIZE_seq']%}
		keyvalue_t kvbuffer_vec{{vec}}[KVDESTBUFFERSZ_KVS], 
		{%endfor%}
		unsigned int addr, keyvalue_t kventry){
	unsigned int idy = addr / VECTOR_SIZE;
	unsigned int idx = addr % VECTOR_SIZE;
	{%for e in context['VECTOR_SIZE_seq']%}
	{%if(e>0)%}else {%endif%}if(idx=={{e}}){	
		kvbuffer_vec{{e}}[idy].key = kventry.key;
		kvbuffer_vec{{e}}[idy].value = kventry.value;
	}
	{%endfor%}
	else {
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryIII:: out-of-bounds 45. "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	return;
}

void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventry4(
		{%for vec in context['VECTOR_SIZE_seq']%}
		keyvalue_t kvbuffer_vec{{vec}}[APPLYVERTEXBUFFERSZ_KVS], 
		{%endfor%}
		unsigned int addr, keyvalue_t kventry){
	#pragma HLS INLINE
	unsigned int idy = addr / VECTOR_SIZE;
	unsigned int idx = addr % VECTOR_SIZE;
	{%for e in context['VECTOR_SIZE_seq']%}
	{%if(e>0)%}else {%endif%}if(idx=={{e}}){	
		kvbuffer_vec{{e}}[idy].key = kventry.key;
		kvbuffer_vec{{e}}[idy].value = kventry.value;
	}
	{%endfor%}
	else {
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryIII:: out-of-bounds 45. "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	return;
}

keyvalue_t {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3(uint512_dt tmpV1, unsigned int idx){
	#ifdef _DEBUGMODE_CHECKS
	checkforoutofbounds_kernel(idx, VECTOR_SIZE, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3 6", 0, 0, 0);
	#endif
	#ifdef _WIDEWORD
	keyvalue_t kventry;
	unsigned int ihi = ((VECTOR_SIZE - idx) * 32) - 1;
	unsigned int ilo = ihi - 31;
	#ifdef _DEBUGMODE_CHECKS
	checkforoutofbounds_kernel(ihi, DATAWIDTH, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3 7", 0, 0, 0);
	#endif
	{%for e in context['VECTOR_SIZE_seq']%}
	{%if(e>0)%}else {%endif%}if(idx=={{e}}){
		kventry.key = tmpV1.range({{(((e*2) * 32) + 31)}}, {{((e*2) * 32)}});
		kventry.value = tmpV1.range({{(((((e*2) * 32) + 31) + 1) + 31)}}, {{((((e*2) * 32) + 31) + 1)}});
	}
	{%endfor%}
	else {
		kventry.key = 0; 
		kventry.value = 0; 
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3:: out-of-bounds 45. "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	return kventry;
	#else
	return tmpV1.data[idx];
	#endif
}

keyvalue_t {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry4(
		{%for vec in context['VECTOR_SIZE_seq']%}
		keyvalue_t kvbuffer_vec{{vec}}[KVSRCBUFFERSZ_APPLY_KVS], 
		{%endfor%}
		unsigned int addr){
	#pragma HLS INLINE
	keyvalue_t kventry;
	#pragma HLS DATA_PACK variable kventry
	unsigned int idy = addr / VECTOR_SIZE;
	unsigned int idx = addr % VECTOR_SIZE;
	{%for e in context['VECTOR_SIZE_seq']%}
	{%if(e>0)%}else {%endif%}if(idx=={{e}}){	
		kventry.key = kvbuffer_vec{{e}}[idy].key;
		kventry.value = kvbuffer_vec{{e}}[idy].value;
	}
	{%endfor%}
	else {
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryIII:: out-of-bounds 45. "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	return kventry;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getsourceskipsize(unsigned int currentLOP, unsigned int param){
	unsigned int treedepth = TREEDEPTH_FORSSDPARTITION0;
	unsigned int _finalnumpartitions = param;
	for(unsigned int i=0; i<(currentLOP-1); i++){ // FIXME?
	#pragma HLS LOOP_TRIPCOUNT min=0 max=treedepth avg=treedepth
		_finalnumpartitions = _finalnumpartitions / NUM_PARTITIONS;
	}
	return _finalnumpartitions;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getdestskipsize(unsigned int currentLOP, unsigned int param){
	unsigned int treedepth = TREEDEPTH_FORSSDPARTITION0; // NB: for debugging purposes only
	unsigned int _finalnumpartitions = param / NUM_PARTITIONS;
	for(unsigned int i=0; i<(currentLOP-1); i++){ // FIXME?
	#pragma HLS LOOP_TRIPCOUNT min=0 max=treedepth avg=treedepth
		_finalnumpartitions = _finalnumpartitions / NUM_PARTITIONS;
	}
	return _finalnumpartitions;
}

void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}loaddeststats(metadata_t * kvstats, metadata_t kvdeststats_tmp[NUM_PARTITIONS], unsigned int partitionoffset, unsigned int currentLOP, vertex_t finalnumpartitions){
	unsigned int skipsize = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getdestskipsize(currentLOP, finalnumpartitions);
	unsigned int nxtpos = partitionoffset;
	#ifdef _DEBUGMODE_PRINTS
	cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}loaddeststats:: currentLOP: "<<currentLOP<<", skipsize: "<<skipsize<<", partitionoffset: "<<partitionoffset<<", finalnumpartitions: "<<finalnumpartitions<<endl;
	#endif
	LOADDESTSTATS_LOOP1: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		#ifdef _DEBUGMODE_CHECKS
		checkforoutofbounds_kernel(p, NUM_PARTITIONS, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}loaddeststats:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}loaddeststats 5", 0, 0, 0);
		checkforoutofbounds_kernel((skipsize * p), KVSTATS_SIZE, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}loaddeststats:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}loaddeststats 6", 0, 0, 0);
		#endif
		
		/* kvdeststats_tmp[p] = kvstats[((partitionoffset + (p * skipsize)) % FORCDFINISH_KVSTATS_SIZE)];  */
		/* kvdeststats_tmp[p] = kvstats[nxtpos]; 
		nxtpos += skipsize; */		
		kvdeststats_tmp[p] = kvstats[(nxtpos % FORCDFINISH_KVSTATS_SIZE)]; 
		nxtpos += skipsize;
		
		#ifdef _DEBUGMODE_PRINTS
		cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}loaddeststats:: kvdeststats_tmp["<<p<<"].offset: "<<kvdeststats_tmp[p].offset<<", kvdeststats_tmp["<<p<<"].size: "<<kvdeststats_tmp[p].size<<", ";
		cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}loaddeststats:: kvstats["<<(partitionoffset + (p * skipsize))<<"].offset: "<<kvstats[(partitionoffset + (p * skipsize))].offset<<", kvstats["<<(partitionoffset + (p * skipsize))<<"].size: "<<kvstats[(partitionoffset + (p * skipsize))].size;
		cout<<endl;
		#endif
	}
	LOADDESTSTATS_LOOP2: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		kvdeststats_tmp[p].size = 0;
	}
	return;
}

void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}storedeststats(metadata_t * kvstats, metadata_t kvdeststats_tmp[NUM_PARTITIONS], unsigned int partitionoffset, unsigned int currentLOP, vertex_t finalnumpartitions){
	unsigned int skipsize = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getdestskipsize(currentLOP, finalnumpartitions);
	unsigned int nxtpos = partitionoffset;
	#ifdef _DEBUGMODE_PRINTS
	cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}storedeststats:: currentLOP: "<<currentLOP<<", skipsize: "<<skipsize<<", partitionoffset: "<<partitionoffset<<", finalnumpartitions: "<<finalnumpartitions<<endl;
	#endif
	STOREDESTSTATS_LOOP1: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		#ifdef _DEBUGMODE_CHECKS
		checkforoutofbounds_kernel(p, NUM_PARTITIONS, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}storedeststats:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}storedeststats 5", 0, 0, 0);
		checkforoutofbounds_kernel((skipsize * p), KVSTATS_SIZE, "{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}storedeststats:: out-of-bounds seen at {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}storedeststats 6", 0, 0, 0);
		#endif
		
		/* kvstats[((partitionoffset + (p * skipsize)) % FORCDFINISH_KVSTATS_SIZE)].size = kvdeststats_tmp[p].size; */
		/* kvstats[nxtpos].size = kvdeststats_tmp[p].size; 
		nxtpos += skipsize; */
		kvstats[(nxtpos % FORCDFINISH_KVSTATS_SIZE)].size = kvdeststats_tmp[p].size; 
		nxtpos += skipsize;
		
		#ifdef _DEBUGMODE_PRINTS
		cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}storedeststats:: kvdeststats_tmp["<<p<<"].offset: "<<kvdeststats_tmp[p].offset<<", kvdeststats_tmp["<<p<<"].size: "<<kvdeststats_tmp[p].size<<", ";
		cout<<"{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}storedeststats:: kvstats["<<(partitionoffset + (p * skipsize))<<"].offset: "<<kvstats[(partitionoffset + (p * skipsize))].offset<<", kvstats["<<(partitionoffset + (p * skipsize))<<"].size: "<<kvstats[(partitionoffset + (p * skipsize))].size;
		cout<<endl;
		#endif
	}
	STOREDESTSTATS_LOOP2: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		kvdeststats_tmp[p].size = 0;
	}
	return;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}get_num_source_partitions(unsigned int currentLOP){
	unsigned int treedepth = TREEDEPTH_FORSSDPARTITION0;
	unsigned int pow = 1;
	for(unsigned int i=0; i<(currentLOP-1); i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=treedepth avg=treedepth
		pow = pow * NUM_PARTITIONS;
	}
	return pow;
}

unsigned int {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}reducefunc(keyy_t vid, value_t value, value_t edgeval, unsigned int IterCount){
	unsigned int ret = 0;
	#ifdef PR_ALGORITHM
	ret = value + edgeval;
	#elif defined(BFS_ALGORITHM)
	// ret = 777;
	// cout<<"************** reducefunc: "<<endl; exit(EXIT_SUCCESS);
	ret = min(value, IterCount);
	// cout<<"************** reducefunc: ret: "<<ret<<", value: "<<value<<", IterCount: "<<IterCount<<endl; exit(EXIT_SUCCESS);
	#elif defined(BC_ALGORITHM)
	// ret = min(value, edgeval);
	ret = min(value, IterCount);
	#endif
	return ret;
}

/// Main Functions
// READ
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}read_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int workerid, uint512_dt * kvdram, unsigned int baseaddr_kvs, unsigned int offset_kvs, unsigned int kvsize_kvs, uint512_dt kvbuffer[KVSRCBUFFERSZ_KVS]){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel:: read. workerid: "<<workerid<<std::endl;
	#endif
	unsigned int kvbuffersz_kvs = KVBUFFERSZ_KVS;  // NB: debugging purposes only
	
	tracker_t kvbuffer1_tracker;
	unsigned int curroffset_kvs = offset_kvs;
	unsigned int nextoffset_kvs = offset_kvs + KVBUFFERSZ_KVS; 
	if(curroffset_kvs >= kvsize_kvs){ kvbuffer1_tracker.weof = 0; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs < kvsize_kvs)) { kvbuffer1_tracker.weof = KVBUFFERSZ; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs >= kvsize_kvs)) { kvbuffer1_tracker.weof = (kvsize_kvs - curroffset_kvs) * VECTOR_SIZE; }
	else {
		kvbuffer1_tracker.weof = 0;
		#ifdef _DEBUGMODE_CHECKS2
		cout<<"read{{ddrs}}{{sw}}:: should NEVER get here: kvbuffer1_tracker.weof: "<<kvbuffer1_tracker.weof<<", kvsize_kvs: "<<kvsize_kvs<<", KVDATA_BATCHSIZE: "<<KVDATA_BATCHSIZE<<endl;
		exit(EXIT_FAILURE);
		#endif
	}
	
	kvbuffersz_dtype rwsize_kvs = (kvbuffer1_tracker.weof + (VECTOR_SIZE - 1)) / VECTOR_SIZE; /// FIXME. why?? <round up>
	dramsz_dtype dramoffset = baseaddr_kvs + offset_kvs;
	if(rwsize_kvs > FORCDFINISH_KVSRCBUFFERSZ_KVS){ rwsize_kvs = KVBUFFERSZ_KVS; } 
	if((dramoffset + rwsize_kvs - 1) >= _x3PADDEDKVDATA_SIZE_KVS){ dramoffset = 0; }
	READBURSTKVS{{ddrs}}{{sw}}_LOOP: for(kvbuffersz_dtype i=0; i<rwsize_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_kvs avg=kvbuffersz_kvs
	#pragma HLS PIPELINE II=1
		#ifdef _DEBUGMODE_CHECKS2
		checkforoutofbounds_kernel((offset_kvs + i), PADDEDKVDATA_BATCHSIZE_KVS, "read{{ddrs}}{{sw}}:: out-of-bounds seen at read 5", baseaddr_kvs, offset_kvs, dramoffset);		
		checkforoutofbounds_kernel((dramoffset + i), _x3PADDEDKVDATA_SIZE_KVS, "read{{ddrs}}{{sw}}:: out-of-bounds seen at read 6", baseaddr_kvs, offset_kvs, dramoffset);		
		checkforoutofbounds_kernel(i, KVSRCBUFFERSZ_KVS, "out-of-bounds seen at read 7", 0, 0, 0);
		#endif
		#ifdef _DEBUGMODE_STATS
		kvpairsread{{ddrs}} += VECTOR_SIZE;
		#endif
		
		#ifdef FORCDFINISH
		kvbuffer[i] = kvdram[((dramoffset + i) & (FORCDFINISH_DRAMSZ_KVS - 1))];
		#else 
		kvbuffer[i] = kvdram[(dramoffset + i)];
		#endif 
	}
	#ifdef _DEBUGMODE_STATS
	kvpairsread{{ddrs}}_transfers += 1;
	#endif
	return;
}
{%endfor%}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}readAU_VU_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int workerid, uint512_dt * kvdram, unsigned int baseaddr_kvs, unsigned int offset_kvs, unsigned int kvsize_kvs, uint512_dt kvbuffer[KVSRCBUFFERSZ_APPLY_KVS]){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel:: read. workerid: "<<workerid<<std::endl;
	#endif
	unsigned int kvbuffersz_kvs = KVSRCBUFFERSZ_APPLY_KVS;  // NB: debugging purposes only
	
	tracker_t kvbuffer1_tracker_kvs;
	unsigned int curroffset_kvs = offset_kvs;
	unsigned int nextoffset_kvs = offset_kvs + KVSRCBUFFERSZ_APPLY_KVS; 
	if(curroffset_kvs >= kvsize_kvs){ kvbuffer1_tracker_kvs.weof = 0; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs < kvsize_kvs)) { kvbuffer1_tracker_kvs.weof = KVSRCBUFFERSZ_APPLY_KVS; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs >= kvsize_kvs)) { kvbuffer1_tracker_kvs.weof = kvsize_kvs - curroffset_kvs; }
	else {
		kvbuffer1_tracker_kvs.weof = 0;
		#ifdef _DEBUGMODE_CHECKS2
		cout<<"read{{ddrs}}{{sw}}:: should NEVER get here: kvbuffer1_tracker_kvs.weof: "<<kvbuffer1_tracker_kvs.weof<<", kvsize_kvs: "<<kvsize_kvs<<", KVDATA_BATCHSIZE: "<<KVDATA_BATCHSIZE<<endl;
		exit(EXIT_FAILURE);
		#endif
	}
	
	kvbuffersz_dtype rwsize_kvs = kvbuffer1_tracker_kvs.weof;
	if(rwsize_kvs > FORCDFINISH_KVSRCBUFFERSZ_APPLY_KVS){ rwsize_kvs = KVSRCBUFFERSZ_APPLY_KVS; } 
	dramsz_dtype dramoffset = baseaddr_kvs + offset_kvs;
	
	if((dramoffset + rwsize_kvs - 1) >= _x3PADDEDKVDATA_SIZE_KVS){ dramoffset = 0; }
	READBURSTKVS{{ddrs}}{{sw}}_LOOP: for(kvbuffersz_dtype i=0; i<rwsize_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_kvs avg=kvbuffersz_kvs
	#pragma HLS PIPELINE II=1
		#ifdef _DEBUGMODE_CHECKS2
		checkforoutofbounds_kernel((offset_kvs + i), PADDEDKVDATA_BATCHSIZE_KVS, "read{{ddrs}}{{sw}}:: out-of-bounds seen at read 5", baseaddr_kvs, offset_kvs, dramoffset);		
		checkforoutofbounds_kernel((dramoffset + i), _x3PADDEDKVDATA_SIZE_KVS, "read{{ddrs}}{{sw}}:: out-of-bounds seen at read 6", baseaddr_kvs, offset_kvs, dramoffset);		
		checkforoutofbounds_kernel((dramoffset + i), _x3PADDEDKVDATA_SIZE_KVS, "read{{ddrs}}{{sw}}:: out-of-bounds seen at read 6", (curroffset_kvs * 1), kvsize_kvs, kvbuffer1_tracker_kvs.weof);		
		checkforoutofbounds_kernel((dramoffset + i), _x3PADDEDKVDATA_SIZE_KVS, "read{{ddrs}}{{sw}}:: out-of-bounds seen at read 6", baseaddr_kvs, offset_kvs, dramoffset);
		checkforoutofbounds_kernel(i, KVSRCBUFFERSZ_APPLY_KVS, "out-of-bounds seen at read 7", 0, 0, 0);
		#endif
		#ifdef _DEBUGMODE_STATS
		kvpairsread{{ddrs}} += VECTOR_SIZE;
		#endif
		
		// for(unsigned int k=0; k<VECTOR_SIZE; k++){ cout<<"readAU_VU_ddr: kvdram["<<(dramoffset + i)<<"].data["<<k<<"].key: "<<kvdram[(dramoffset + i)].data[k].key<<", kvdram["<<(dramoffset + i)<<"].data["<<k<<"].value: "<<kvdram[(dramoffset + i)].data[k].value<<endl; } // FIXME. REMOVEME
		// exit(EXIT_SUCCESS);
		
		#ifdef FORCDFINISH
		kvbuffer[i] = kvdram[((dramoffset + i) & (FORCDFINISH_DRAMSZ_KVS - 1))];
		#else 
		kvbuffer[i] = kvdram[(dramoffset + i)];
		#endif
	}
	#ifdef _DEBUGMODE_STATS
	kvpairsread{{ddrs}}_transfers += 1;
	#endif
	return;
}
{%endfor%}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}readAU_V_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int ssdpartitonid, unsigned int workerid, uint512_dt * kvdram, unsigned int baseaddr_kvs, unsigned int offset_kvs, unsigned int kvsize_kvs, uint512_dt verticesbuffer[APPLYVERTEXBUFFERSZ_KVS]){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::readAU_V{{ddrs}}{{sw}} read. workerid: "<<workerid<<std::endl;
	#endif
	int verticesbuffersz_kvs = APPLYVERTEXBUFFERSZ_KVS;
	
	tracker_t kvbuffer1_tracker_kvs;
	unsigned int vertexreadsz_kvs = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid);
	unsigned int curroffset_kvs = offset_kvs;
	unsigned int nextoffset_kvs = offset_kvs + vertexreadsz_kvs; 
	if(curroffset_kvs >= kvsize_kvs){ kvbuffer1_tracker_kvs.weof = 0; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs < kvsize_kvs)) { kvbuffer1_tracker_kvs.weof = vertexreadsz_kvs; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs >= kvsize_kvs)) { kvbuffer1_tracker_kvs.weof = (kvsize_kvs - curroffset_kvs) * VECTOR_SIZE; }
	else {
		kvbuffer1_tracker_kvs.weof = 0; 
		#ifdef _DEBUGMODE_CHECKS2
		cout<<"read{{ddrs}}{{sw}}:: should NEVER get here: kvbuffer1_tracker_kvs.weof: "<<(kvbuffer1_tracker_kvs.weof * VECTOR_SIZE)<<", kvsize_kvs: "<<kvsize_kvs<<", KVDATA_BATCHSIZE: "<<KVDATA_BATCHSIZE<<endl;
		exit(EXIT_FAILURE);
		#endif
	}
	
	kvbuffersz_dtype rwsize_kvs = kvbuffer1_tracker_kvs.weof;
	dramsz_dtype dramoffset = baseaddr_kvs + offset_kvs;
	if(rwsize_kvs > FORCDFINISH_APPLYVERTEXBUFFERSZ_KVS){ rwsize_kvs = vertexreadsz_kvs; }
	if((dramoffset + rwsize_kvs - 1) >= _x3PADDEDKVDATA_SIZE_KVS){ dramoffset = 0; }
	READBURSTKVS{{ddrs}}{{sw}}_LOOP: for(kvbuffersz_dtype i=0; i<rwsize_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=verticesbuffersz_kvs avg=verticesbuffersz_kvs
	#pragma HLS PIPELINE II=1
		#ifdef _DEBUGMODE_CHECKS2
		checkforoutofbounds_kernel((offset_kvs + i), (VERTICESDATASZ_FORDRAMX / VECTOR_SIZE), "readAU_V{{ddrs}}{{sw}}:: out-of-bounds seen at read 5", baseaddr_kvs, offset_kvs, dramoffset);	
		checkforoutofbounds_kernel((dramoffset + i), _x3PADDEDKVDATA_SIZE_KVS, "readAU_V{{ddrs}}{{sw}}:: out-of-bounds seen at read 6", baseaddr_kvs, offset_kvs, dramoffset);		
		checkforoutofbounds_kernel((dramoffset + i), _x3PADDEDKVDATA_SIZE_KVS, "readAU_V{{ddrs}}{{sw}}:: out-of-bounds seen at read 6", (curroffset_kvs * 1), kvsize_kvs, kvbuffer1_tracker_kvs.weof);		
		checkforoutofbounds_kernel((dramoffset + i), _x3PADDEDKVDATA_SIZE_KVS, "readAU_V{{ddrs}}{{sw}}:: out-of-bounds seen at read 6", baseaddr_kvs, offset_kvs, dramoffset);
		checkforoutofbounds_kernel(i, {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid), "readAU_V{{ddrs}}{{sw}}:: out-of-bounds seen at read 7A", kvbuffer1_tracker_kvs.weof, i, {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid));
		#endif
		#ifdef _DEBUGMODE_STATS
		kvpairsread{{ddrs}} += VECTOR_SIZE;
		#endif
		
		#ifdef FORCDFINISH
		verticesbuffer[i] = kvdram[((dramoffset + i) & (FORCDFINISH_DRAMSZ_KVS - 1))];
		#else 
		verticesbuffer[i] = kvdram[(dramoffset + i)]; 
		#endif 
	}
	#ifdef _DEBUGMODE_STATS
	kvpairsread{{ddrs}}_transfers += 1;
	#endif
	return;
}
{%endfor%}
{%endfor%}
{%endfor%}

// PARTITION
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}partition_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int ssdpartitonid, unsigned int workerid, unsigned int subworkerid, unsigned int kvreadoffset_kvs, unsigned int kvsize_kvs, unsigned int currentLOP, unsigned int destpartitionoffset, unsigned int upperlimit, unsigned int destpartitionrange,
		uint512_dt kvbuffer_src[KVSRCBUFFERSZ_KVS], uint512_dt kvbuffer_dest[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset[NUM_PARTITIONS]
		#ifdef _PARTITIONED_KVBUFFERSTATS
		,smalluint_t kvbufferstats_size[NUM_PARTITIONS]
		#else 
		,smalluint_t kvbufferstats_tmp_size[NUM_PARTITIONS]
		#endif 
		,smallmargin_t ov[NUM_PARTITIONS], uint512_dt ovkvs_tmp[NUM_PARTITIONS]){
	
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"kernelprocess:: partition. workerid: "<<workerid<<", KVBUFFERSZ: "<<KVBUFFERSZ<<", kvreadoffset_kvs: "<<kvreadoffset_kvs<<", kvsize_kvs: "<<kvsize_kvs<<std::endl;
	#endif
	int kvbuffersz = KVBUFFERSZ;  // NB: debugging purposes only
	int kvbuffersz_kvs = KVBUFFERSZ_KVS;  // NB: debugging purposes only
	int vector_size = VECTOR_SIZE;  // NB: debugging purposes only
	
	#ifdef _PARTITIONED_KVBUFFERSTATS
	smalluint_t kvbufferstats_tmp_size[NUM_PARTITIONS];
	#pragma HLS ARRAY_PARTITION variable=kvbufferstats_tmp_size complete
	#endif	
	#ifdef _PARTITIONED_KVBUFFERSTATS // >>> sync
	READ_KVSTATSTMP{{ddrs}}{{sw}}_LOOP1: for(unsigned int p=0; p<NUM_PARTITIONS; p++){ kvbufferstats_tmp_size[p] = kvbufferstats_size[p]; }
	#endif 
	
	tracker_t kvbuffer1_kvs_tracker;
	unsigned int curroffset_kvs = kvreadoffset_kvs + (subworkerid * KVBUFFERSZ_KVS);
	unsigned int nextoffset_kvs = kvreadoffset_kvs + ((subworkerid + 1) * KVBUFFERSZ_KVS);
	if(curroffset_kvs >= kvsize_kvs){ kvbuffer1_kvs_tracker.weof = 0; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs < kvsize_kvs)) { kvbuffer1_kvs_tracker.weof = KVBUFFERSZ_KVS; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs >= kvsize_kvs)) { kvbuffer1_kvs_tracker.weof = kvsize_kvs - curroffset_kvs; }
	else {
		kvbuffer1_kvs_tracker.weof = 0; 
		#ifdef _DEBUGMODE_CHECKS2
		cout<<"extractstats2_{{ddrs}}{{sw}}:: should NEVER get here: kvbuffer1_kvs_tracker.weof: "<<kvbuffer1_kvs_tracker.weof<<", kvsize_kvs: "<<kvsize_kvs<<", kvreadoffset_kvs: "<<kvreadoffset_kvs<<", next kvreadoffset_kvs: "<<(kvreadoffset_kvs + ((subworkerid + 1) * KVBUFFERSZ_KVS))<<", KVDATA_BATCHSIZE: "<<KVDATA_BATCHSIZE<<endl;
		exit(EXIT_FAILURE);
		#endif
	}

	#ifdef _DEBUGMODE_PRINTS
	printkvbuffer_kernel(kvbuffer_src, KVBUFFERSZ, "extractstats2_.extractstats.kvbuffer_src");
	#endif
	EXTRACTSTATS{{ddrs}}{{sw}}_INIT_LOOP0: for (int p = 0; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE
		kvbufferstats_offset[p] = 0;
		kvbufferstats_tmp_size[p] = 0;
	}	
	
	#ifdef _DEBUGMODE_CHECKS2
	state_moduleid = 8;
	state_kvbuffer1_kvs_tracker = kvbuffer1_kvs_tracker.weof;
	#endif
	keyvalue_t kventry1;
	unsigned int rwsize_kvs = kvbuffer1_kvs_tracker.weof;
	if(rwsize_kvs >= FORCDFINISH_KVSRCBUFFERSZ){ rwsize_kvs = KVBUFFERSZ_KVS; }
	EXTRACTSTATS{{ddrs}}{{sw}}_MAIN_LOOP1: for (unsigned int j = 0; j<rwsize_kvs; j++){
	#pragma HLS PIPELINE
	#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_kvs avg=kvbuffersz_kvs
	uint512_dt tmpV1 = kvbuffer_src[j];
	#ifdef OOO 
	kventry1.key = tmpV1.range(31, 0);
	kventry1.value = tmpV1.range(63, 32);
	#endif 
		EXTRACTSTATS{{ddrs}}{{sw}}_MAIN_LOOP1B: for(unsigned int k=0; k<VECTOR_SIZE; k++){
			// #pragma HLS UNROLL
			#ifdef _WIDEWORD			
			#ifndef OOO
			// kventry1 = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3(tmpV1, k);
			unsigned int _k2 = k * 2;
			unsigned int _k2plus1 = _k2 + 1;
			kventry1.key = tmpV1.range(DATATYPE_SIZE * (_k2 + 1) - 1, _k2 * DATATYPE_SIZE);
			kventry1.value = tmpV1.range(DATATYPE_SIZE * (_k2plus1 + 1) - 1, _k2plus1 * DATATYPE_SIZE);
			#endif			
			#else 
			kventry1.key = tmpV1.data[k].key;
			kventry1.value = tmpV1.data[k].value;
			#endif 
			
			unsigned int p = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc4(currentLOP, kventry1, upperlimit, ssdpartitonid);
			#ifdef _DEBUGMODE_
			checkforoutofbounds_kernel(p, NUM_PARTITIONS, "extractstats2_.extractstats:: out-of-bounds seen at write 5");
			#endif
			kvbufferstats_tmp_size[p] += 1;
			
			#ifdef _WIDEWORD
			#ifdef OOO
			tmpV1 = tmpV1 >> 64;
			kventry1.key = tmpV1.range(31, 0);
			kventry1.value = tmpV1.range(63, 32);
			#endif 
			#endif 			
		}
	}
	// kvbufferstats_tmp_size[0] -=  // NB: this eliminates any edge conditions associated with partially alligned kvbuffer_src. NB: ensure extras are set to zero in host!
	
	kvbufferstats_offset[0] = 0;
	EXTRACTSTATS{{ddrs}}{{sw}}_ALLIGNOFFSETS_LOOP1: for (int p = 1; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE
		kvbufferstats_offset[p] = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}allignup_KV((kvbufferstats_offset[(p-1)] + kvbufferstats_tmp_size[(p-1)] + ov[(p-1)].size));
	}
	#ifdef _DEBUGMODE_PRINTS
	printstats2_kernel(kvbufferstats_tmp_size, NUM_PARTITIONS, "", 0, 0, 0);
	#endif

	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel:: extractstats2_.extractstats2_. workerid: "<<workerid<<std::endl;
	#endif
	EXTRACTSTATS{{ddrs}}{{sw}}_INIT2_LOOP1: for (unsigned int p = 0; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE
		kvbufferstats_tmp_size[p] = 0;
	}
	
	EXTRACTSTATS{{ddrs}}{{sw}}_RESOLVEEDGECONDITIONS_LOOP1: for(unsigned int p=0; p<NUM_PARTITIONS; p++){ // append ovs back to kvbuffer
	#pragma HLS PIPELINE
		#ifdef _DEBUGMODE_PRINTS
		print4ints_kernel("extractstats2_::PARTITION{{ddrs}}{{sw}}_LOOP1A", "p", p, "p", p, "ov[p].begin", ov[p].begin, "ov[p].size", ov[p].size);
		printovs2_kernel(ov, p, "[kernel::extractstats2_]", {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII(ov[p].begin, kvbuffer_dest).key, 0, 0);
		#endif

		keyvalue_t kventry;
		#pragma HLS DATA_PACK variable=kventry
		unsigned int rwsize = ov[p].size;
		if(rwsize >= FORCDFINISH_VECTOR_SIZE){ rwsize = 0; }
		#ifdef _DEBUGMODE_CHECKS2
		checkforoutofbounds_kernel(ov[p].size, VECTOR_SIZE, "kernel::PARTITION{{ddrs}}{{sw}}_LOOP2:: out-of-bounds seen 58", p, 0, 0); 
		#endif
		
		#ifdef _DEBUGMODE_CHECKS
		checkforoutofbounds_kernel((kvbufferstats_offset[p] + kvbufferstats_tmp_size[p]), KVSRCBUFFERSZ, "out-of-bounds seen at extractstats2_ 6", p, 0, 0);
		#endif
		kvbuffer_dest[((kvbufferstats_offset[p] + kvbufferstats_tmp_size[p]) / VECTOR_SIZE)] = ovkvs_tmp[p];
		#ifdef _DEBUGMODE_CHECKS
		checkentryforoutofbounds_kernel(destpartitionoffset, p, currentLOP, {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETTREEDEPTH(ssdpartitonid), {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid), ({%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII((kvbufferstats_offset[p] + kvbufferstats_tmp_size[p]), kvbuffer_dest).key - upperlimit), "", p, i, (ov[p].begin+0));
		#endif
			
		kvbufferstats_tmp_size[p] += rwsize;
		#ifdef _DEBUGMODE_CHECKS
		if(p<(NUM_PARTITIONS-1)){ checkforoutofbounds_kernel((kvbufferstats_offset[p] + kvbufferstats_tmp_size[p]), kvbufferstats_offset[p+1], "kernel::PARTITION{{ddrs}}{{sw}}_LOOP1A:: out-of-bounds seen 35", 0, 0, 0); }
		else { checkforoutofbounds_kernel((kvbufferstats_offset[p] + kvbufferstats_tmp_size[p]), KVSRCBUFFERSZ, "kernel::PARTITION{{ddrs}}{{sw}}_LOOP1A:: out-of-bounds seen 36", 0, 0, 0); }
		#endif
		
		ov[p].begin = 0;
		ov[p].size = 0;
	}

	#ifdef _DEBUGMODE_CHECKS2
	state_moduleid = 9;
	state_kvbuffer1_kvs_tracker = kvbuffer1_kvs_tracker.weof;
	#endif 
	keyvalue_t kventry2;
	unsigned int rwsize2_kvs = kvbuffer1_kvs_tracker.weof;
	if(rwsize2_kvs >= FORCDFINISH_KVSRCBUFFERSZ_KVS){ rwsize2_kvs = KVBUFFERSZ_KVS; }
	PARTITION{{ddrs}}{{sw}}_MAIN_LOOP1: for (unsigned int j = 0; j<rwsize2_kvs; j++){
	#pragma HLS PIPELINE
	#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_kvs avg=kvbuffersz_kvs
	uint512_dt tmpV1 = kvbuffer_src[j];
	#ifdef OOO 
	kventry2.key = tmpV1.range(31, 0);
	kventry2.value = tmpV1.range(63, 32);
	#endif 
		PARTITION{{ddrs}}{{sw}}_MAIN_LOOP1B: for(unsigned int k=0; k<VECTOR_SIZE; k++){
		// #pragma HLS PIPELINE
		// #pragma HLS UNROLL
		#pragma HLS LOOP_TRIPCOUNT min=0 max=vector_size avg=vector_size
			#ifdef _WIDEWORD			
			#ifndef OOO
			// kventry2 = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3(tmpV1, k);
			unsigned int _k2 = k * 2;
			unsigned int _k2plus1 = _k2 + 1;
			kventry2.key = tmpV1.range(DATATYPE_SIZE * (_k2 + 1) - 1, _k2 * DATATYPE_SIZE);
			kventry2.value = tmpV1.range(DATATYPE_SIZE * (_k2plus1 + 1) - 1, _k2plus1 * DATATYPE_SIZE);
			#endif
			#else
			kventry2.key = tmpV1.data[k].key;
			kventry2.value = tmpV1.data[k].value;
			#endif			
			
			unsigned int p = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc4(currentLOP, kventry2, upperlimit, ssdpartitonid);
			{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII(kvbuffer_dest, (kvbufferstats_offset[p] + kvbufferstats_tmp_size[p]), kventry2); 
			kvbufferstats_tmp_size[p] += 1;
			
			#ifdef _DEBUGMODE_CHECKS2
			if(p<(NUM_PARTITIONS-1)){ checkforoutofbounds_kernel((kvbufferstats_offset[p] + kvbufferstats_tmp_size[p]), (kvbufferstats_offset[p+1] + 1), "kernel::PARTITION{{ddrs}}{{sw}}_LOOP2:: out-of-bounds seen at partition2_ 37", p, 0, 0); }
			else { checkforoutofbounds_kernel((kvbufferstats_offset[p] + kvbufferstats_tmp_size[p]), KVSRCBUFFERSZ, "kernel::PARTITION{{ddrs}}{{sw}}_LOOP2:: out-of-bounds seen at partition2_ 38", p, 0, 0); }
			#endif
			
			#ifdef _WIDEWORD
			#ifdef OOO
			tmpV1 = tmpV1 >> 64;
			kventry2.key = tmpV1.range(31, 0);
			kventry2.value = tmpV1.range(63, 32);
			#endif	
			#endif 
		}
	}
	/* #ifdef _DEBUGMODE_PRINTS
	for(unsigned int p=0; p<NUM_PARTITIONS; p++){ cout<<"partition_ddr{{ddrs}}_w{{w}}_sw{{sw}}: kvbufferstats_tmp_size["<<p<<"]: "<<kvbufferstats_tmp_size[p]<<endl; }
	exit(EXIT_SUCCESS);
	#endif */
	
	// Store overflows
	uint512_dt tmpV1;
	PARTITION{{ddrs}}{{sw}}_RESOLVEEDGECONDITIONS_LOOP2: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		ov[p].begin = kvbufferstats_offset[p] + {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}alligndown_KV(kvbufferstats_tmp_size[p]);
		ov[p].size = kvbufferstats_tmp_size[p] - {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}alligndown_KV(kvbufferstats_tmp_size[p]);
		unsigned int ovbegin_kvs = ov[p].begin / VECTOR_SIZE;
		unsigned int ovsize = ov[p].size;
		#ifdef _DEBUGMODE_CHECKS2
		checkforoutofbounds_kernel(ovsize, VECTOR_SIZE, "kernel::PARTITION{{ddrs}}{{sw}}_LOOP2:: out-of-bounds seen at partition2_ 58", p, 0, 0); 
		checkforoutofbounds_kernel(ovbegin_kvs, KVDESTBUFFERSZ_KVS, "out-of-bounds seen at partition2_ 235", p, ovbegin_kvs, KVDESTBUFFERSZ_KVS);
		#endif
		
		uint512_dt tmpV1 = kvbuffer_dest[ovbegin_kvs];
		ovkvs_tmp[p] = tmpV1;
		#ifdef _DEBUGMODE_PRINTS
		print4ints_kernel("partition2_", "p", p, "p", p, "ov[p].begin", ov[p].begin, "ov[p].size", ov[p].size);
		printkvs2_kernel(ovkvs_tmp[p], "printing ovkvs_tmp's");
		#endif
	}
	
	#ifdef _PARTITIONED_KVBUFFERSTATS // >>> sync
	WRITEBACK_KVSTATSTMP{{ddrs}}{{sw}}_LOOP1: for(unsigned int p=0; p<NUM_PARTITIONS; p++){ kvbufferstats_size[p] = kvbufferstats_tmp_size[p]; }
	#endif	
	#ifdef _DEBUGMODE_PRINTS
	printkvbuffer_kernel(kvbuffer_dest, kvbuffer1_kvs_tracker.weof, "extractstats2_.extractstats2_.kvbuffer_dest");
	#endif
	return;
}
{%endfor%}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_seq']%}
#ifdef _SEPERATE_EXTRACTANDPARTITIONFUNC
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}extractstats2_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int ssdpartitonid, unsigned int workerid, unsigned int subworkerid, unsigned int kvreadoffset_kvs, unsigned int kvsize_kvs, unsigned int currentLOP, unsigned int destpartitionoffset, unsigned int upperlimit, unsigned int destpartitionrange,
		uint512_dt kvbuffer_src[KVSRCBUFFERSZ_KVS], uint512_dt kvbuffer_dest[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset[NUM_PARTITIONS], smalluint_t kvbufferstats_size[NUM_PARTITIONS], smallmargin_t ov[NUM_PARTITIONS], uint512_dt ovkvs_tmp[NUM_PARTITIONS]){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel:: extractstats2_. workerid: "<<workerid<<", KVBUFFERSZ: "<<KVBUFFERSZ<<std::endl;
	#endif
	int kvbuffersz = KVBUFFERSZ;  // NB: debugging purposes only
	int kvbuffersz_kvs = KVBUFFERSZ_KVS;  // NB: debugging purposes only
	int vector_size = VECTOR_SIZE;  // NB: debugging purposes only
	
	tracker_t kvbuffer1_kvs_tracker;
	unsigned int curroffset_kvs = kvreadoffset_kvs + (subworkerid * KVBUFFERSZ_KVS);
	unsigned int nextoffset_kvs = kvreadoffset_kvs + ((subworkerid + 1) * KVBUFFERSZ_KVS);
	if(curroffset_kvs >= kvsize_kvs){ kvbuffer1_kvs_tracker.weof = 0; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs < kvsize_kvs)) { kvbuffer1_kvs_tracker.weof = KVBUFFERSZ_KVS; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs >= kvsize_kvs)) { kvbuffer1_kvs_tracker.weof = kvsize_kvs - curroffset_kvs; }
	else {
		kvbuffer1_kvs_tracker.weof = 0; 
		#ifdef _DEBUGMODE_CHECKS2
		cout<<"extractstats2_{{ddrs}}{{sw}}:: should NEVER get here: kvbuffer1_kvs_tracker.weof: "<<kvbuffer1_kvs_tracker.weof<<", kvsize_kvs: "<<kvsize_kvs<<", kvreadoffset_kvs: "<<kvreadoffset_kvs<<", next kvreadoffset_kvs: "<<(kvreadoffset_kvs + ((subworkerid + 1) * KVBUFFERSZ_KVS))<<", KVDATA_BATCHSIZE: "<<KVDATA_BATCHSIZE<<endl;
		exit(EXIT_FAILURE);
		#endif
	}

	#ifdef _DEBUGMODE_PRINTS
	printkvbuffer_kernel(kvbuffer_src, KVBUFFERSZ, "extractstats2_.extractstats.kvbuffer_src");
	#endif
	EXTRACTSTATS{{ddrs}}{{sw}}_INIT_LOOP0: for (int p = 0; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE
		kvbufferstats_offset[p] = 0;
		kvbufferstats_size[p] = 0;
	}	
	
	keyvalue_t kventry1;
	// #pragma HLS DATA_PACK variable=kventry1
	unsigned int rwsize_kvs = kvbuffer1_kvs_tracker.weof;
	if(rwsize_kvs >= FORCDFINISH_KVSRCBUFFERSZ){ rwsize_kvs = 0; }	
	EXTRACTSTATS{{ddrs}}{{sw}}_MAIN_LOOP1: for (unsigned int j = 0; j<rwsize_kvs; j++){
	#pragma HLS PIPELINE
	#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_kvs avg=kvbuffersz_kvs
	uint512_dt tmpV1 = kvbuffer_src[j];
		EXTRACTSTATS{{ddrs}}{{sw}}_MAIN_LOOP1B: for(unsigned int k=0; k<VECTOR_SIZE; k++){
			// #pragma HLS UNROLL
			#ifdef _WIDEWORD
			// kventry1 = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3(tmpV1, k);
			unsigned int _k2 = k * 2;
			unsigned int _k2plus1 = _k2 + 1;
			kventry1.key = tmpV1.range(DATATYPE_SIZE * (_k2 + 1) - 1, _k2 * DATATYPE_SIZE);
			kventry1.value = tmpV1.range(DATATYPE_SIZE * (_k2plus1 + 1) - 1, _k2plus1 * DATATYPE_SIZE);
			#else 
			kventry1.key = tmpV1.data[k].key;
			kventry1.value = tmpV1.data[k].value;
			#endif 
			
			unsigned int p = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc4(currentLOP, kventry1, upperlimit, ssdpartitonid);
			#ifdef _DEBUGMODE_
			checkforoutofbounds_kernel(p, NUM_PARTITIONS, "extractstats2_.extractstats:: out-of-bounds seen at write 5");
			#endif
			kvbufferstats_size[p] += 1; 
		}
	}
	
	kvbufferstats_offset[0] = 0;
	EXTRACTSTATS{{ddrs}}{{sw}}_ALLIGNOFFSETS_LOOP1: for (int p = 1; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE
		kvbufferstats_offset[p] = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}allignup_KV((kvbufferstats_offset[(p-1)] + kvbufferstats_size[(p-1)] + ov[(p-1)].size));
	}

	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel:: extractstats2_.extractstats2_. workerid: "<<workerid<<std::endl;
	#endif
	EXTRACTSTATS{{ddrs}}{{sw}}_INIT2_LOOP1: for (unsigned int p = 0; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE
		kvbufferstats_size[p] = 0;
	}
	
	EXTRACTSTATS{{ddrs}}{{sw}}_RESOLVEEDGECONDITIONS_LOOP1: for(unsigned int p=0; p<NUM_PARTITIONS; p++){ // append ovs back to kvbuffer
	#pragma HLS PIPELINE
		#ifdef _DEBUGMODE_PRINTS
		print4ints_kernel("extractstats2_::PARTITION{{ddrs}}{{sw}}_LOOP1A", "p", p, "p", p, "ov[p].begin", ov[p].begin, "ov[p].size", ov[p].size);
		printovs2_kernel(ov, p, "[kernel::extractstats2_]", {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII(ov[p].begin, kvbuffer_dest).key, 0, 0);
		#endif

		keyvalue_t kventry;
		#pragma HLS DATA_PACK variable=kventry
		unsigned int rwsize = ov[p].size;
		if(rwsize >= FORCDFINISH_VECTOR_SIZE){ rwsize = 0; }
		#ifdef _DEBUGMODE_CHECKS2
		checkforoutofbounds_kernel(ov[p].size, VECTOR_SIZE, "kernel::PARTITION{{ddrs}}{{sw}}_LOOP2:: out-of-bounds seen 58", p, 0, 0); 
		#endif
		
		#ifdef _DEBUGMODE_CHECKS
		checkforoutofbounds_kernel((kvbufferstats_offset[p] + kvbufferstats_size[p]), KVSRCBUFFERSZ, "out-of-bounds seen at extractstats2_ 6", p, 0, 0);
		#endif
		kvbuffer_dest[((kvbufferstats_offset[p] + kvbufferstats_size[p]) / VECTOR_SIZE)] = ovkvs_tmp[p];
		#ifdef _DEBUGMODE_CHECKS
		checkentryforoutofbounds_kernel(destpartitionoffset, p, currentLOP, {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETTREEDEPTH(ssdpartitonid), {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid), ({%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII((kvbufferstats_offset[p] + kvbufferstats_size[p]), kvbuffer_dest).key - upperlimit), "", p, i, (ov[p].begin+0));
		#endif
				
		kvbufferstats_size[p] += rwsize;
		#ifdef _DEBUGMODE_CHECKS
		if(p<(NUM_PARTITIONS-1)){ checkforoutofbounds_kernel((kvbufferstats_offset[p] + kvbufferstats_size[p]), kvbufferstats_offset[p+1], "kernel::PARTITION{{ddrs}}{{sw}}_LOOP1A:: out-of-bounds seen 35", 0, 0, 0); }
		else { checkforoutofbounds_kernel((kvbufferstats_offset[p] + kvbufferstats_size[p]), KVSRCBUFFERSZ, "kernel::PARTITION{{ddrs}}{{sw}}_LOOP1A:: out-of-bounds seen 36", 0, 0, 0); }
		#endif
		
		ov[p].begin = 0;
		ov[p].size = 0;
	}
	
	#ifdef _DEBUGMODE_PRINTS
	printkvbuffer_kernel(kvbuffer_dest, kvbuffer1_tracker.weof, "extractstats2_.extractstats2_.kvbuffer_dest");
	#endif
	return;
}
#endif 
{%endfor%}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_seq']%}
#ifdef _SEPERATE_EXTRACTANDPARTITIONFUNC
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}partition2_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int ssdpartitonid, unsigned int workerid, unsigned int subworkerid, unsigned int kvreadoffset_kvs, unsigned int kvsize_kvs, unsigned int currentLOP, unsigned int destpartitionoffset, unsigned int upperlimit, unsigned int destpartitionrange,
		uint512_dt kvbuffer_src[KVSRCBUFFERSZ_KVS], uint512_dt kvbuffer_dest[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset[NUM_PARTITIONS], smalluint_t kvbufferstats_size[NUM_PARTITIONS], smallmargin_t ov[NUM_PARTITIONS], uint512_dt ovkvs_tmp[NUM_PARTITIONS]){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel:: partition2_. workerid: "<<workerid<<", KVBUFFERSZ: "<<KVBUFFERSZ<<std::endl;
	#endif
	int kvbuffersz = KVBUFFERSZ;  // NB: debugging purposes only
	int kvbuffersz_kvs = KVBUFFERSZ_KVS;  // NB: debugging purposes only
	int vector_size = VECTOR_SIZE;  // NB: debugging purposes only

	tracker_t kvbuffer1_kvs_tracker;
	unsigned int curroffset_kvs = kvreadoffset_kvs + (subworkerid * KVBUFFERSZ_KVS);
	unsigned int nextoffset_kvs = kvreadoffset_kvs + ((subworkerid + 1) * KVBUFFERSZ_KVS);
	if(curroffset_kvs >= kvsize_kvs){ kvbuffer1_kvs_tracker.weof = 0; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs < kvsize_kvs)) { kvbuffer1_kvs_tracker.weof = KVBUFFERSZ_KVS; }
	else if ((curroffset_kvs < kvsize_kvs) && (nextoffset_kvs >= kvsize_kvs)) { kvbuffer1_kvs_tracker.weof = kvsize_kvs - curroffset_kvs; }
	else {
		kvbuffer1_kvs_tracker.weof = 0; 
		#ifdef _DEBUGMODE_CHECKS2
		cout<<"partition2_{{ddrs}}{{sw}}:: should NEVER get here: kvbuffer1_kvs_tracker.weof: "<<kvbuffer1_kvs_tracker.weof<<", kvsize_kvs: "<<kvsize_kvs<<", kvreadoffset_kvs: "<<kvreadoffset_kvs<<", next kvreadoffset_kvs: "<<(kvreadoffset_kvs + ((subworkerid + 1) * KVBUFFERSZ_KVS))<<", KVDATA_BATCHSIZE: "<<KVDATA_BATCHSIZE<<endl;
		exit(EXIT_FAILURE);
		#endif
	}

	keyvalue_t kventry2;
	// #pragma HLS DATA_PACK variable=kventry2
	unsigned int rwsize2 = kvbuffer1_kvs_tracker.weof;
	if(rwsize2 >= FORCDFINISH_KVSRCBUFFERSZ_KVS){ rwsize2 = 0; }
	PARTITION{{ddrs}}{{sw}}_MAIN_LOOP1: for (unsigned int j = 0; j<rwsize2; j++){
	#pragma HLS PIPELINE
	#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_kvs avg=kvbuffersz_kvs
	uint512_dt tmpV1 = kvbuffer_src[j];
		PARTITION{{ddrs}}{{sw}}_MAIN_LOOP1B: for(unsigned int k=0; k<VECTOR_SIZE; k++){
		// #pragma HLS PIPELINE
		// #pragma HLS UNROLL
		#pragma HLS LOOP_TRIPCOUNT min=0 max=vector_size avg=vector_size
			#ifdef _WIDEWORD
			// kventry2 = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3(tmpV1, k);
			unsigned int _k2 = k * 2;
			unsigned int _k2plus1 = _k2 + 1;
			kventry2.key = tmpV1.range(DATATYPE_SIZE * (_k2 + 1) - 1, _k2 * DATATYPE_SIZE);
			kventry2.value = tmpV1.range(DATATYPE_SIZE * (_k2plus1 + 1) - 1, _k2plus1 * DATATYPE_SIZE);
			#else
			kventry2.key = tmpV1.data[k].key;
			kventry2.value = tmpV1.data[k].value;
			#endif			
			
			unsigned int p = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}hashfunc4(currentLOP, kventry2, upperlimit, ssdpartitonid);
			{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII(kvbuffer_dest, (kvbufferstats_offset[p] + kvbufferstats_size[p]), kventry2); 
			kvbufferstats_size[p] += 1; 
			#ifdef _DEBUGMODE_CHECKS2
			if(p<(NUM_PARTITIONS-1)){ checkforoutofbounds_kernel((kvbufferstats_offset[p] + kvbufferstats_size[p]), (kvbufferstats_offset[p+1] + 1), "kernel::PARTITION{{ddrs}}{{sw}}_LOOP2:: out-of-bounds seen at partition2_ 37", p, 0, 0); }
			else { checkforoutofbounds_kernel((kvbufferstats_offset[p] + kvbufferstats_size[p]), KVSRCBUFFERSZ, "kernel::PARTITION{{ddrs}}{{sw}}_LOOP2:: out-of-bounds seen at partition2_ 38", p, 0, 0); }
			#endif
		}
	}
	
	// Store overflows
	uint512_dt tmpV1;
	PARTITION{{ddrs}}{{sw}}_RESOLVEEDGECONDITIONS_LOOP2: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		ov[p].begin = kvbufferstats_offset[p] + {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}alligndown_KV(kvbufferstats_size[p]);
		ov[p].size = kvbufferstats_size[p] - {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}alligndown_KV(kvbufferstats_size[p]);
		unsigned int ovbegin_kvs = ov[p].begin / VECTOR_SIZE;
		unsigned int ovsize = ov[p].size;
		#ifdef _DEBUGMODE_CHECKS2
		checkforoutofbounds_kernel(ovsize, VECTOR_SIZE, "kernel::PARTITION{{ddrs}}{{sw}}_LOOP2:: out-of-bounds seen at partition2_ 58", p, 0, 0); 
		checkforoutofbounds_kernel(ovbegin_kvs, KVDESTBUFFERSZ_KVS, "out-of-bounds seen at partition2_ 235", p, ovbegin_kvs, KVDESTBUFFERSZ_KVS);
		#endif
		
		uint512_dt tmpV1 = kvbuffer_dest[ovbegin_kvs];
		ovkvs_tmp[p] = tmpV1;
		#ifdef _DEBUGMODE_PRINTS
		print4ints_kernel("partition2_", "p", p, "p", p, "ov[p].begin", ov[p].begin, "ov[p].size", ov[p].size);
		printkvs2_kernel(ovkvs_tmp[p], "printing ovkvs_tmp's");
		#endif
	}	

	#ifdef _DEBUGMODE_PRINTS
	printkvbuffer_kernel(kvbuffer_dest, kvbuffer1_kvs_tracker.weof, "partition2_.partition2_.kvbuffer_dest");
	#endif
	return;
}
#endif 
{%endfor%}
{%endfor%}
{%endfor%}

// APPLY
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}reduce_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int IterCount, unsigned int ssdpartitonid, unsigned int workerid, unsigned int verticesreadoffset_vs, unsigned int kvreadoffset_kvs, unsigned int kvsize_kvsTTT, metadata_t sourcestatbuffer, uint512_dt verticesbuffer[APPLYVERTEXBUFFERSZ_KVS], uint512_dt kvbuffer[KVSRCBUFFERSZ_APPLY_KVS]){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel:: reduce. workerid: "<<workerid<<", KVSRCBUFFERSZ_APPLY: "<<KVSRCBUFFERSZ_APPLY<<std::endl;
	#endif
	
	int kvbuffersz = KVSRCBUFFERSZ_APPLY; // NB: debugging purposes only
	unsigned int kvbuffersz_kvs = KVSRCBUFFERSZ_APPLY_KVS;  // NB: debugging purposes only

	tracker_t kvbuffer1_tracker_kvs;
	unsigned int kvsize_kvs = (sourcestatbuffer.size + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
	unsigned int kvsize_lower_kvs = sourcestatbuffer.size / VECTOR_SIZE;
	unsigned int curroffset_kvs = kvreadoffset_kvs + (0 * KVSRCBUFFERSZ_APPLY_KVS); // subworkerid
	unsigned int nextoffset_kvs = kvreadoffset_kvs + ((0 + 1) * KVSRCBUFFERSZ_APPLY_KVS);
	if(curroffset_kvs >= kvsize_lower_kvs){ kvbuffer1_tracker_kvs.weof = 0; }
	else if ((curroffset_kvs < kvsize_lower_kvs) && (nextoffset_kvs < kvsize_lower_kvs)) { kvbuffer1_tracker_kvs.weof = KVSRCBUFFERSZ_APPLY_KVS; }
	else if ((curroffset_kvs < kvsize_lower_kvs) && (nextoffset_kvs >= kvsize_lower_kvs)) { kvbuffer1_tracker_kvs.weof = (kvsize_lower_kvs - curroffset_kvs); }
	else {
		kvbuffer1_tracker_kvs.weof = 0; 
		#ifdef _DEBUGMODE_CHECKS
		cout<<"reduce_ddr{{ddrs}}_sw{{sw}}:: should NEVER get here: kvbuffer1_tracker_kvs.weof: "<<kvbuffer1_tracker_kvs.weof<<", kvsize_lower_kvs: "<<kvsize_lower_kvs<<", kvreadoffset_kvs: "<<kvreadoffset_kvs<<", next kvreadoffset_kvs: "<<(kvreadoffset_kvs + (({{sw}} + 1) * KVSRCBUFFERSZ_APPLY_KVS))<<", KVDATA_BATCHSIZE: "<<KVDATA_BATCHSIZE<<endl;
		exit(EXIT_FAILURE);
		#endif
	}
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"reduce_ddr{{ddrs}}_sw{{sw}}:: kvbuffer1_tracker_kvs.weof: "<<kvbuffer1_tracker_kvs.weof<<", KVSRCBUFFERSZ_APPLY: "<<KVSRCBUFFERSZ_APPLY<<std::endl;
	exit(EXIT_SUCCESS);
	#endif
	vertex_t voffset = verticesreadoffset_vs * VECTOR_SIZE;
	keyvalue_t kventry;
	keyvalue_t kv; 
	
	unsigned int rwsize_kvs = kvbuffer1_tracker_kvs.weof;
	if(rwsize_kvs > FORCDFINISH_KVSRCBUFFERSZ_APPLY){ rwsize_kvs = 0; }
	REDUCE_ddr{{ddrs}}_w{{w}}_sw{{sw}}_LOOP1: for (unsigned int i = 0; i<rwsize_kvs; i++){
	#pragma HLS PIPELINE
	#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_kvs avg=kvbuffersz_kvs
	uint512_dt tmpV1 = kvbuffer[i];
		REDUCE_ddr{{ddrs}}_w{{w}}_sw{{sw}}_LOOP1B: for(unsigned int k=0; k<VECTOR_SIZE; k++){
			#ifdef _WIDEWORD
			kventry = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3(tmpV1, k);
			#else 
			kventry.key = tmpV1.data[k].key;
			kventry.value = tmpV1.data[k].value;
			#endif 
			
			#ifdef _DEBUGMODE_CHECKS2
			if((kventry.key - voffset) >= {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION(ssdpartitonid)){ cout<<"out-of-bounds seen at reduce_ddr{{ddrs}}_w{{w}}_sw{{sw}} 5: kventry.key: "<<kventry.key<<", voffset: "<<voffset<<", APPLYVERTEXBUFFERSZ_PERSSDPARTITION("<<ssdpartitonid<<"): "<<GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION(ssdpartitonid)<<", KVSRCBUFFERSZ_APPLY_KVS: "<<KVSRCBUFFERSZ_APPLY_KVS<<", kvbuffer1_tracker_kvs.weof: "<<kvbuffer1_tracker_kvs.weof<<", i: "<<i<<", k: "<<k<<endl; exit(EXIT_FAILURE); }
			#endif
			unsigned int loc = kventry.key - voffset; 
			if(loc >= FORCDFINISH_APPLYVERTEXBUFFERSZ){ loc = 0; }
			
			keyvalue_t vprop = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIV(loc, verticesbuffer);
			unsigned int temp = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}reducefunc(vprop.key, vprop.value, kventry.value, IterCount);
	
			#if defined(BC_ALGORITHM)
			// reducefunc(keyy_t vid, value_t value, value_t edgeval, unsigned int IterCount)
			// ret = min(value, IterCount);
			if(temp == vprop.value){ vprop.key = kventry.key; } // REMOVEME. DIRECTIVE
			#endif
			vprop.value = temp;
			{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII(verticesbuffer, loc, vprop);					
		}
	}
	
	uint512_dt tmpV1 = kvbuffer[(kvsize_kvs - 1)];
	unsigned int keyvalues_overflow = sourcestatbuffer.size - alligndown_KV(sourcestatbuffer.size);
	REDUCEOV_ddr{{ddrs}}_w{{w}}_sw{{sw}}_LOOP1B: for(unsigned int k=0; k<keyvalues_overflow; k++){
		#ifdef _WIDEWORD
		kventry = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventry3(tmpV1, k);
		#else 
		kventry.key = tmpV1.data[k].key;
		kventry.value = tmpV1.data[k].value;
		#endif 
	
		#ifdef _DEBUGMODE_CHECKS2
		if((kventry.key - voffset) >= {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION(ssdpartitonid)){ cout<<"out-of-bounds seen at reduce_ddr{{ddrs}}_w{{w}}_sw{{sw}} 5: kventry.key: "<<kventry.key<<", voffset: "<<voffset<<", APPLYVERTEXBUFFERSZ_PERSSDPARTITION("<<ssdpartitonid<<"): "<<GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION(ssdpartitonid)<<", KVSRCBUFFERSZ_APPLY_KVS: "<<KVSRCBUFFERSZ_APPLY_KVS<<", kvbuffer1_tracker_kvs.weof: "<<kvbuffer1_tracker_kvs.weof<<", i: "<<(kvsize_kvs - 1)<<", k: "<<k<<endl; exit(EXIT_FAILURE); }
		#endif
		
		unsigned int loc = kventry.key - voffset; 
		if(loc >= FORCDFINISH_APPLYVERTEXBUFFERSZ){ loc = 0; }
		
		keyvalue_t vprop = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryIV(loc, verticesbuffer);
		unsigned int temp = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}reducefunc(vprop.key, vprop.value, kventry.value, IterCount);
		
		#if defined(BC_ALGORITHM)
		// reducefunc(keyy_t vid, value_t value, value_t edgeval, unsigned int IterCount)
		// ret = min(value, IterCount);
		if(temp == vprop.value){ vprop.key = kventry.key; } // REMOVEME. DIRECTIVE
		#endif
		vprop.value = temp;
		{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}setkventryII(verticesbuffer, loc, vprop);
	}
	return;
}
{%endfor%}
{%endfor%}
{%endfor%}

// WRITE
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}write_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int ssdpartitonid, unsigned int workerid, unsigned int currentLOP, unsigned int destpartitionoffset,
		uint512_dt kvbuffer[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset[NUM_PARTITIONS], smalluint_t kvbufferstats_size[NUM_PARTITIONS], uint512_dt * kvdram, metadata_t kvdeststats_tmp[NUM_PARTITIONS], unsigned int baseaddr_kvs){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::write{{ddrs}}{{sw}}. workerid: "<<workerid<<std::endl;
	#endif
	unsigned int kvbuffersz_kvs = KVBUFFERSZ_KVS;  // NB: debugging purposes only
	unsigned int kvbuffersz_perpartition_kvs = KVBUFFERSZ_KVS / NUM_PARTITIONS;  // NB: debugging purposes only
	WRITEBURSTKVS{{ddrs}}{{sw}}_LOOP1A: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		unsigned int offset = kvbufferstats_offset[p] / VECTOR_SIZE;
		unsigned int size_kvs = kvbufferstats_size[p] / VECTOR_SIZE;
		unsigned int dramoffset_g = kvdeststats_tmp[p].offset / VECTOR_SIZE;
		unsigned int dramoffset_l = kvdeststats_tmp[p].size / VECTOR_SIZE;
		dramsz_dtype dramoffset = baseaddr_kvs + dramoffset_g + dramoffset_l;

		kvbuffersz_dtype rwsize_kvs = size_kvs;
		if(rwsize_kvs > FORCDFINISH_KVDESTBUFFERSZ_KVS){ rwsize_kvs = 0; } 
		if((dramoffset + rwsize_kvs - 1) >= _x3PADDEDKVDATA_SIZE_KVS){ dramoffset = 0; }
		if((offset + rwsize_kvs) >= FORCDFINISH_KVDESTBUFFERSZ_KVS){ offset = 0; }
		WRITEBURSTKVS{{ddrs}}{{sw}}_LOOP1B: for(kvbuffersz_dtype i=0; i<rwsize_kvs; i++){ 
		#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_perpartition_kvs avg=kvbuffersz_perpartition_kvs
		#pragma HLS PIPELINE II=1
			#ifdef _DEBUGMODE_CHECKS
			checkforoutofbounds_kernel((offset + i), KVDESTBUFFERSZ_KVS, "out-of-bounds seen at write{{ddrs}}{{sw}} 5", 0, 0, 0);
			checkforoutofbounds_kernel((dramoffset_g + dramoffset_l + i), PADDEDKVDATA_BATCHSIZE_KVS, "out-of-bounds seen at write{{ddrs}}{{sw}} 6", 0, 0, 0);
			if(p<(NUM_PARTITIONS-1)){ checkforoutofbounds_kernel((dramoffset_g + dramoffset_l + i), kvdeststats_tmp[p+1].offset, "out-of-bounds seen at write{{ddrs}}{{sw}} 7", 0, 0, 0); }
			else { checkforoutofbounds_kernel((dramoffset_g + dramoffset_l + i), PADDEDKVDATA_BATCHSIZE, "out-of-bounds seen at write{{ddrs}}{{sw}} 8", 0, 0, 0); }
			#endif
			#ifdef _DEBUGMODE_STATS
			kvpairswritten{{ddrs}} += VECTOR_SIZE;
			#endif
			
			#ifdef FORCDFINISH
			kvdram[((dramoffset + i) & (FORCDFINISH_DRAMSZ_KVS - 1))] = kvbuffer[(offset + i)];
			#else 
			kvdram[(dramoffset + i)] = kvbuffer[(offset + i)];
			#endif 
		}
		kvdeststats_tmp[p].size += rwsize_kvs * VECTOR_SIZE;
		#ifdef _DEBUGMODE_STATS
		kvpairswritten{{ddrs}}_transfers += 1;
		#endif
	}
	return;
}
{%endfor%}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}writeremainingovs_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int ssdpartitonid, unsigned int workerid, uint512_dt * kvdram, metadata_t kvdeststats_tmp[NUM_PARTITIONS], uint512_dt ovkvs_tmp_ddr[NUM_PARTITIONS], smallmargin_t ov[NUM_PARTITIONS], unsigned int baseaddr_kvs){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::writeremainingovs_ddr{{ddrs}}{{sw}}. workerid: "<<workerid<<std::endl;
	#endif
	
	WRITEBURSTKVS{{ddrs}}{{sw}}_LOOP1A: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE II=1
		unsigned int dramoffset_g = kvdeststats_tmp[p].offset / VECTOR_SIZE;
		unsigned int dramoffset_l = kvdeststats_tmp[p].size / VECTOR_SIZE;
		dramsz_dtype dramoffset = baseaddr_kvs + dramoffset_g + dramoffset_l;
		
		#ifdef FORCDFINISH
		kvdram[(dramoffset & (FORCDFINISH_DRAMSZ_KVS - 1))] = ovkvs_tmp_ddr[p];
		#else 
		kvdram[dramoffset] = ovkvs_tmp_ddr[p];
		#endif 
		
		kvdeststats_tmp[p].size += ov[p].size; // VECTOR_SIZE;
		
		#ifdef _DEBUGMODE_STATS
		kvpairswritten{{ddrs}} += ov[p].size; // VECTOR_SIZE;
		#endif
		#ifdef _DEBUGMODE_STATS
		kvpairswritten{{ddrs}}_transfers += 1;
		#endif
	}
	return;
}
{%endfor%}
{%endfor%}
{%endfor%}

// BRAM 2 TMP TRANSFERS
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
#ifdef _BUFFERB4WRITE
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}mergeoffsetsandsizes_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int workerid
		,smalluint_t DESTtmpkvbufferstats_offset[NUM_PARTITIONS], smalluint_t DESTtmpkvbufferstats_size[NUM_PARTITIONS]
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,smalluint_t kvbufferstats_sw{{sw}}_size[NUM_PARTITIONS]
		{%endfor%}
		){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"mergeoffsetsandsizes_ddr{{ddrs}}_w{{w}}:: workerid: "<<workerid<<std::endl;
	#endif
	
	MERGE_ddr{{ddrs}}_w{{w}}_LOOP1: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE
		DESTtmpkvbufferstats_size[p] = 
		{%for sw in context['NUMSUBWORKERS_seq']%}
		{%if(sw==0)%}{%else%}+{%endif%}kvbufferstats_sw{{sw}}_size[p]
		{%endfor%}
		;
	}
	
	DESTtmpkvbufferstats_offset[0] = 0;
	MERGE_ddr{{ddrs}}_w{{w}}_LOOP2: for (int p = 1; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE
		DESTtmpkvbufferstats_offset[p] = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}allignup_KV((DESTtmpkvbufferstats_offset[(p-1)] + DESTtmpkvbufferstats_size[(p-1)]));		
		#ifdef _DEBUGMODE_CHECKS2
		checkforoutofbounds_kernel(DESTtmpkvbufferstats_offset[p], TOTALDESTTMPKVBUFFERSZ, "mergeoffsetsandsizes_ddr{{ddrs}}_w{{w}}:: out-of-bounds seen at mergeoffsetsandsizes_ddr{{ddrs}}_w{{w}} 36", p, DESTtmpkvbufferstats_offset[p], 0); 
		#endif		
	}
	
	MERGE_ddr{{ddrs}}_w{{w}}_LOOP3: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE
		DESTtmpkvbufferstats_size[p] = 0;
	}
	return;
}
#endif
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_seq']%}
#ifdef _BUFFERB4WRITE
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}write_bram2tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int ssdpartitonid, unsigned int workerid, 
		uint512_dt kvbuffer[KVDESTBUFFERSZ_KVS], uint512_dt DESTtmpkvbuffer[TOTALDESTTMPKVBUFFERSZ_KVS], smallmetadata_t DESTtmpkvbuffer_weof[NUM_PARTITIONS], smalluint_t kvbufferstats_offset[NUM_PARTITIONS], smalluint_t kvbufferstats_size[NUM_PARTITIONS], unsigned int baseaddr_kvs){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"writetotmp{{ddrs}}{{sw}}:: write_bram2tmp. workerid: "<<workerid<<std::endl;
	#endif
	unsigned int kvbuffersz_kvs = KVBUFFERSZ_KVS;  // NB: debugging purposes only
	unsigned int kvbuffersz_perpartition_kvs = KVBUFFERSZ_KVS / NUM_PARTITIONS;  // NB: debugging purposes only
	unsigned int desttmpkvbuffersz_kvs = DESTTMPKVBUFFERSZ_KVS;
	WRITE_BRAM2TMP{{ddrs}}{{sw}}_LOOP1A: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		if((DESTtmpkvbuffer_weof[p].size + kvbufferstats_size[p]) >= DESTTMPKVBUFFERSZ){ continue; }
			
		unsigned int offset = kvbufferstats_offset[p] / VECTOR_SIZE;
		unsigned int size_kvs = kvbufferstats_size[p] / VECTOR_SIZE;
		unsigned int desttmpbaseoffset_kvs = (DESTtmpkvbuffer_weof[p].offset + DESTtmpkvbuffer_weof[p].size) / VECTOR_SIZE;
		unsigned int size_desttmp_kvs = DESTtmpkvbuffer_weof[p].size / VECTOR_SIZE;
		#ifdef _DEBUGMODE_CHECKS2
		if(size_kvs > KVDESTBUFFERSZ_KVS){ std::cout<<"writetotmp{{ddrs}}{{sw}}:: ERRRRRRRRRRRRRRRR size_kvs: "<<size_kvs<<", KVDESTBUFFERSZ_KVS: "<<KVDESTBUFFERSZ_KVS<<std::endl; exit(EXIT_FAILURE); }
		#endif 
		
		unsigned int desttmpoffset_kvs = (p * DESTTMPKVBUFFERSZ_KVS) + desttmpbaseoffset_kvs;
		WRITE_BRAM2TMP{{ddrs}}{{sw}}_LOOP1B: for(unsigned int i=0; i<size_kvs; i++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_perpartition_kvs avg=kvbuffersz_perpartition_kvs
		#pragma HLS PIPELINE II=1
			#ifdef _DEBUGMODE_STATS
			kvpairswritten_bram2tmp{{ddrs}} += VECTOR_SIZE;
			#endif
			DESTtmpkvbuffer[(desttmpoffset_kvs + i)] = kvbuffer[(offset + i)]; 
		}
		DESTtmpkvbuffer_weof[p].size += size_kvs * VECTOR_SIZE;
		#ifdef _DEBUGMODE_STATS
		kvpairswritten_bram2tmp{{ddrs}}_transfers += 1;
		#endif
	}
	return;
}
#endif 
{%endfor%}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_seq']%}
#ifdef _BUFFERB4WRITE
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}accel1_write_bram2tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int ssdpartitonid, unsigned int workerid
		,uint512_dt kvbuffer[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset[NUM_PARTITIONS], smalluint_t kvbufferstats_size[NUM_PARTITIONS]
		,uint512_dt DESTtmpkvbuffer[TOTALDESTTMPKVBUFFERSZ_KVS], smalluint_t DESTtmpkvbufferstats_offset[NUM_PARTITIONS], smalluint_t DESTtmpkvbufferstats_size[NUM_PARTITIONS]){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"accel3_write_bram2tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}:: workerid: "<<workerid<<std::endl;
	#endif
	unsigned int kvbuffersz_kvs = KVBUFFERSZ_KVS;  // NB: debugging purposes only
	unsigned int kvbuffersz_perpartition_kvs = KVBUFFERSZ_KVS / NUM_PARTITIONS;  // NB: debugging purposes only
	unsigned int desttmpkvbuffersz_kvs = DESTTMPKVBUFFERSZ_KVS;  // NB: debugging purposes only
	WRITE_BRAM2TMP{{ddrs}}{{sw}}_LOOP1A: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE		
		unsigned int offset_kvs = kvbufferstats_offset[p] / VECTOR_SIZE;
		unsigned int size_kvs = kvbufferstats_size[p] / VECTOR_SIZE;
		unsigned int desttmpkvbuffer_baseoffset_kvs = DESTtmpkvbufferstats_offset[p] / VECTOR_SIZE;
		unsigned int desttmpkvbuffer_size_kvs = DESTtmpkvbufferstats_size[p] / VECTOR_SIZE;
		unsigned int desttmpkvbuffer_offset_kvs = desttmpkvbuffer_baseoffset_kvs + desttmpkvbuffer_size_kvs;
		
		#ifdef _DEBUGMODE_CHECKS2
		if(desttmpkvbuffer_size_kvs > TOTALDESTTMPKVBUFFERSZ){ std::cout<<"accel3_write_bram2tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}:: ERROR desttmpkvbuffer_size_kvs: "<<desttmpkvbuffer_size_kvs<<", TOTALDESTTMPKVBUFFERSZ: "<<TOTALDESTTMPKVBUFFERSZ<<std::endl; exit(EXIT_FAILURE); }
		#endif 
		
		WRITE_BRAM2TMP{{ddrs}}{{sw}}_LOOP1B: for(unsigned int i=0; i<size_kvs; i++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_perpartition_kvs avg=kvbuffersz_perpartition_kvs
		#pragma HLS PIPELINE II=1
			#ifdef _DEBUGMODE_STATS
			kvpairswritten_bram2tmp{{ddrs}} += VECTOR_SIZE;
			#endif
			DESTtmpkvbuffer[(desttmpkvbuffer_offset_kvs + i)] = kvbuffer[(offset_kvs + i)]; 
		}
		
		DESTtmpkvbufferstats_size[p] += size_kvs * VECTOR_SIZE;
		#ifdef _DEBUGMODE_STATS
		kvpairswritten_bram2tmp{{ddrs}}_transfers += 1;
		#endif
	}
	return;
}
#endif
{%endfor%}
{%endfor%}
{%endfor%}

// BRAM 2 DRAM TRANSFERS
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_seq']%}
#ifdef _BUFFERB4WRITE
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}write_bram2dram_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int ssdpartitonid, unsigned int workerid, 
		uint512_dt kvbuffer[KVDESTBUFFERSZ_KVS], smallmetadata_t DESTtmpkvbuffer_weof[NUM_PARTITIONS], smalluint_t kvbufferstats_offset[NUM_PARTITIONS], smalluint_t kvbufferstats_size[NUM_PARTITIONS], uint512_dt * kvdram, metadata_t kvdeststats_tmp[NUM_PARTITIONS], unsigned int baseaddr_kvs){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"writetotmp{{ddrs}}{{sw}}:: write_bram2tmp. workerid: "<<workerid<<std::endl;
	#endif
	unsigned int kvbuffersz_kvs = KVBUFFERSZ_KVS;  // NB: debugging purposes only
	unsigned int kvbuffersz_perpartition_kvs = KVBUFFERSZ_KVS / NUM_PARTITIONS;  // NB: debugging purposes only
	unsigned int desttmpkvbuffersz_kvs = DESTTMPKVBUFFERSZ_KVS;
	WRITE_BRAM2DRAM{{ddrs}}{{sw}}_LOOP1A: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		if((DESTtmpkvbuffer_weof[p].size + kvbufferstats_size[p]) < DESTTMPKVBUFFERSZ){ continue; }
			
		unsigned int offset = kvbufferstats_offset[p] / VECTOR_SIZE;
		kvbuffersz_dtype size_kvs = kvbufferstats_size[p] / VECTOR_SIZE;
		unsigned int dramoffset_g = kvdeststats_tmp[p].offset / VECTOR_SIZE;
		unsigned int dramoffset_l = kvdeststats_tmp[p].size / VECTOR_SIZE;
		dramsz_dtype dramoffset = baseaddr_kvs + dramoffset_g + dramoffset_l;
		unsigned int size_desttmp_kvs = DESTtmpkvbuffer_weof[p].size / VECTOR_SIZE;
		#ifdef _DEBUGMODE_CHECKS2
		if(size_kvs > KVDESTBUFFERSZ_KVS){ std::cout<<"writetotmp{{ddrs}}{{sw}}:: ERROR 45 size_kvs: "<<size_kvs<<", KVDESTBUFFERSZ_KVS: "<<KVDESTBUFFERSZ_KVS<<std::endl; exit(EXIT_FAILURE); }
		#endif
		
		WRITE_BRAM2DRAM{{ddrs}}{{sw}}_LOOP1B: for(kvbuffersz_dtype i=0; i<size_kvs; i++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=0 avg=0
		#pragma HLS PIPELINE II=1
			#ifdef _DEBUGMODE_CHECKS
			checkforoutofbounds_kernel((offset + i), KVDESTBUFFERSZ_KVS, "out-of-bounds seen at write_bram2tmp{{ddrs}}{{sw}} 5", 0, 0, 0);
			checkforoutofbounds_kernel((dramoffset_g + dramoffset_l + i), PADDEDKVDATA_BATCHSIZE_KVS, "out-of-bounds seen at write_bram2tmp{{ddrs}}{{sw}} 6", 0, 0, 0);
			if(p<(NUM_PARTITIONS-1)){ checkforoutofbounds_kernel((dramoffset_g + dramoffset_l + i), kvdeststats_tmp[p+1].offset, "out-of-bounds seen at write_bram2tmp{{ddrs}}{{sw}} 7", 0, 0, 0); }
			else { checkforoutofbounds_kernel((dramoffset_g + dramoffset_l + i), PADDEDKVDATA_BATCHSIZE, "out-of-bounds seen at write_bram2tmp{{ddrs}}{{sw}} 8", 0, 0, 0); }
			#endif
			#ifdef _DEBUGMODE_STATS
			kvpairswritten{{ddrs}} += VECTOR_SIZE;
			#endif
			
			#ifdef FORCDFINISH
			kvdram[((dramoffset + i) & (FORCDFINISH_DRAMSZ_KVS - 1))] = kvbuffer[(offset + i)];
			#else 
			kvdram[(dramoffset + i)] = kvbuffer[(offset + i)];
			#endif 
		}
		kvdeststats_tmp[p].size += size_kvs * VECTOR_SIZE;
		#ifdef _DEBUGMODE_STATS
		kvpairswritten{{ddrs}}_transfers += 1;
		#endif
	}
	return;
}
#endif 
{%endfor%}
{%endfor%}
{%endfor%}

// WRITE VERTICES TO DRAM (APPLY PHASE)
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}writeAU_Vs_ddr{{ddrs}}_w{{w}}_sw{{sw}}(unsigned int ssdpartitonid, unsigned int workerid, uint512_dt * kvdram, unsigned int offset_vs, unsigned int baseaddr_vs, uint512_dt verticesbuffer[APPLYVERTEXBUFFERSZ_KVS]){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::writeAU_Vs{{ddrs}}{{sw}} read. workerid: "<<workerid<<std::endl;
	#endif
	unsigned int verticesbuffersz_kvs = APPLYVERTEXBUFFERSZ_KVS;  // NB: debugging purposes only
	
	kvbuffersz_dtype rwsize_kvs = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid);
	if(rwsize_kvs > FORCDFINISH_APPLYVERTEXBUFFERSZ_KVS){ rwsize_kvs = 0; } 
	dramsz_dtype dramoffset = baseaddr_vs + offset_vs;
	if((dramoffset + rwsize_kvs - 1) >= _x3PADDEDKVDATA_SIZE_KVS){ dramoffset = 0; }
	WRITEBURSTKVS{{ddrs}}{{sw}}_AU_LOOP: for(kvbuffersz_dtype i=0; i<rwsize_kvs; i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=verticesbuffersz_kvs avg=verticesbuffersz_kvs
	#pragma HLS PIPELINE II=1
		#ifdef _DEBUGMODE_CHECKS
		checkforoutofbounds_kernel((offset_vs + i), _x3PADDEDKVDATA_SIZE_KVS, "writeAU_Vs{{ddrs}}{{sw}}:: out-of-bounds seen at read 5", 0, 0, 0);
		checkforoutofbounds_kernel(i, {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid), "writeAU_Vs{{ddrs}}{{sw}}:: out-of-bounds seen at read 6", 0, 0, 0);
		#endif
		#ifdef _DEBUGMODE_STATS
		kvpairswritten{{ddrs}} += VECTOR_SIZE;
		#endif
		// kvdram[(dramoffset + i)] = verticesbuffer[i];
		// kvdram[((dramoffset + i) % _x3PADDEDKVDATA_SIZE_KVS)] = verticesbuffer[i]; 
		#ifdef FORCDFINISH
		kvdram[((dramoffset + i) & (FORCDFINISH_DRAMSZ_KVS - 1))] = verticesbuffer[i];
		#else 
		kvdram[(dramoffset + i)] = verticesbuffer[i];
		#endif 
	}
	#ifdef _DEBUGMODE_STATS
	kvpairswritten{{ddrs}}_transfers += 1;
	#endif
	return;
}
{%endfor%}
{%endfor%}
{%endfor%}

// READ MANY
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}readmany_ddr{{ddrs}}_w{{w}}(unsigned int beginworkerid, uint512_dt * kvdram, unsigned int baseaddr_kvs, unsigned int kvreadoffset_kvs, unsigned int kvsize_kvs
	{%for sw in context['NUMSUBWORKERS_seq']%}
	,uint512_dt kvbuffer{{sw}}[KVSRCBUFFERSZ_KVS]
	{%endfor%}
	){
	{%for sw in context['NUMSUBWORKERS_seq']%}
	unsigned int worker{{sw}}id = beginworkerid + {{sw}};
	unsigned int baseaddr{{sw}}_kvs = baseaddr_kvs;
	unsigned int offset{{sw}}_kvs = kvreadoffset_kvs + ({{sw}} * KVBUFFERSZ_KVS);
	unsigned int kvsize{{sw}}_kvs = kvsize_kvs;
	
	{%endfor%}		
	{%for sw in context['NUMSUBWORKERS_seq']%}
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}read_ddr{{ddrs}}_w{{w}}_sw{{sw}}(worker{{sw}}id, kvdram, baseaddr{{sw}}_kvs, offset{{sw}}_kvs, kvsize{{sw}}_kvs, kvbuffer{{sw}});
	/// read_ddr{{ddrs}}_w{{w}}_sw{{sw}}((beginworkerid + {{sw}}), kvdram, baseaddr_kvs, (kvreadoffset_kvs + ({{sw}} * KVBUFFERSZ_KVS)), kvsize_kvs, kvbuffer{{sw}});
	{%endfor%}
	return;
}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}readmanyAU_Vs_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int beginworkerid, uint512_dt * kvdram, unsigned int baseaddr_kvs, unsigned int kvreadoffset_kvs, unsigned int kvsize_kvs
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	,uint512_dt verticesbuffer{{sw}}[APPLYVERTEXBUFFERSZ_KVS]
	{%endfor%}
	){
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}readAU_V_ddr{{ddrs}}_w{{w}}_sw{{sw}}(ssdpartitonid, (beginworkerid + {{sw}}), kvdram, baseaddr_kvs, (kvreadoffset_kvs + ({{sw}} * {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid))), kvsize_kvs, verticesbuffer{{sw}});
	{%endfor%}
	return;
}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}readmanyAU_VUs_ddr{{ddrs}}_w{{w}}(unsigned int beginworkerid, uint512_dt * kvdram, unsigned int baseaddr_kvs, metadata_t sourcestatbuffer[NUMSUBWORKERS], unsigned int kvreadoffset_kvs, unsigned int kvsize_kvs
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	,uint512_dt kvbuffer{{sw}}[KVSRCBUFFERSZ_APPLY_KVS]
	{%endfor%}
	){
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	unsigned int worker{{sw}}id = beginworkerid + {{sw}}; 
	unsigned int baseaddr{{sw}}_kvs = baseaddr_kvs;
	unsigned int offset{{sw}}_kvs = (sourcestatbuffer[{{sw}}].offset / VECTOR_SIZE) + kvreadoffset_kvs;
	unsigned int kvsize{{sw}}_kvs = (sourcestatbuffer[{{sw}}].offset + sourcestatbuffer[{{sw}}].size + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
	// cout<<"readmanyAU_VUs_ddr:: kvsize{{sw}}_kvs: "<<kvsize{{sw}}_kvs<<", sourcestatbuffer[{{sw}}].offset: "<<sourcestatbuffer[{{sw}}].offset<<", sourcestatbuffer[{{sw}}].size: "<<sourcestatbuffer[{{sw}}].size<<", kvreadoffset_kvs: "<<kvreadoffset_kvs<<endl;
	{%endfor%}
	
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}readAU_VU_ddr{{ddrs}}_w{{w}}_sw0(worker{{sw}}id, kvdram, baseaddr{{sw}}_kvs, offset{{sw}}_kvs, kvsize{{sw}}_kvs, kvbuffer{{sw}});
	{%endfor%}
	return;
}
{%endfor%}
{%endfor%}

// PARTITION MANY
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}partitionmany_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int beginworkerid, unsigned int kvreadoffset_kvs, unsigned int kvsize_kvs, unsigned int currentLOP, unsigned int destpartitionoffset, unsigned int upperlimit, unsigned int destpartitionrange
	{%for sw in context['NUMSUBWORKERS_seq']%}
	,uint512_dt kvbuffer{{sw}}1[KVSRCBUFFERSZ_KVS], uint512_dt kvbuffer{{sw}}2[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset{{sw}}[NUM_PARTITIONS], smalluint_t kvbufferstats_size{{sw}}[NUM_PARTITIONS], smallmargin_t ov{{sw}}[NUM_PARTITIONS], uint512_dt ovkvs_tmp{{sw}}[NUM_PARTITIONS]
	{%endfor%}
	){
	{%for sw in context['NUMSUBWORKERS_seq']%}
	unsigned int ssdpartiton{{sw}}id = ssdpartitonid;
	unsigned int worker{{sw}}id =  beginworkerid + {{sw}};
	unsigned int subworker{{sw}}id = {{sw}};
	unsigned int kvreadoffset{{sw}}_kvs = kvreadoffset_kvs;
	unsigned int kvsize{{sw}}_kvs = kvsize_kvs;
	unsigned int currentLOP{{sw}} = currentLOP;
	unsigned int destpartitionoffset{{sw}} = destpartitionoffset;
	unsigned int upperlimit{{sw}} = upperlimit;
	unsigned int destpartitionrange{{sw}} = destpartitionrange;	
	{%endfor%}
	
	{%for sw in context['NUMSUBWORKERS_seq']%}
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}partition_ddr{{ddrs}}_w{{w}}_sw{{sw}}(ssdpartiton{{sw}}id, worker{{sw}}id, subworker{{sw}}id, kvreadoffset{{sw}}_kvs, kvsize{{sw}}_kvs, currentLOP{{sw}}, destpartitionoffset{{sw}}, upperlimit{{sw}}, destpartitionrange{{sw}}, kvbuffer{{sw}}1, kvbuffer{{sw}}2, kvbufferstats_offset{{sw}}, kvbufferstats_size{{sw}}, ov{{sw}}, ovkvs_tmp{{sw}});
	{%endfor%}
	return;
}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
#ifdef _SEPERATE_EXTRACTANDPARTITIONFUNC
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}extractmanystats2_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int beginworkerid, unsigned int kvreadoffset_kvs, unsigned int kvsize_kvs, unsigned int currentLOP, unsigned int destpartitionoffset, unsigned int upperlimit, unsigned int destpartitionrange
	{%for sw in context['NUMSUBWORKERS_seq']%}
	,uint512_dt kvbuffer{{sw}}1[KVSRCBUFFERSZ_KVS], uint512_dt kvbuffer{{sw}}2[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset{{sw}}[NUM_PARTITIONS], smalluint_t kvbufferstats_size{{sw}}[NUM_PARTITIONS], smallmargin_t ov{{sw}}[NUM_PARTITIONS], uint512_dt ovkvs_tmp{{sw}}[NUM_PARTITIONS]
	{%endfor%}
	){	
	{%for sw in context['NUMSUBWORKERS_seq']%}
	unsigned int ssdpartiton{{sw}}id = ssdpartitonid;
	unsigned int worker{{sw}}id =  beginworkerid + {{sw}};
	unsigned int subworker{{sw}}id = {{sw}};
	unsigned int kvreadoffset{{sw}}_kvs = kvreadoffset_kvs;
	unsigned int kvsize{{sw}}_kvs = kvsize_kvs;
	unsigned int currentLOP{{sw}} = currentLOP;
	unsigned int destpartitionoffset{{sw}} = destpartitionoffset;
	unsigned int upperlimit{{sw}} = upperlimit;
	unsigned int destpartitionrange{{sw}} = destpartitionrange;
	
	{%endfor%}		
	{%for sw in context['NUMSUBWORKERS_seq']%}
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}extractstats2_ddr{{ddrs}}_w{{w}}_sw{{sw}}(ssdpartiton{{sw}}id, worker{{sw}}id, subworker{{sw}}id, kvreadoffset{{sw}}_kvs, kvsize{{sw}}_kvs, currentLOP{{sw}}, destpartitionoffset{{sw}}, upperlimit{{sw}}, destpartitionrange{{sw}}, kvbuffer{{sw}}1, kvbuffer{{sw}}2, kvbufferstats_offset{{sw}}, kvbufferstats_size{{sw}}, ov{{sw}}, ovkvs_tmp{{sw}});
	{%endfor%}
	return;
}
#endif 
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
#ifdef _SEPERATE_EXTRACTANDPARTITIONFUNC
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}partitionmany2_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int beginworkerid, unsigned int kvreadoffset_kvs, unsigned int kvsize_kvs, unsigned int currentLOP, unsigned int destpartitionoffset, unsigned int upperlimit, unsigned int destpartitionrange
	{%for sw in context['NUMSUBWORKERS_seq']%}
	,uint512_dt kvbuffer{{sw}}1[KVSRCBUFFERSZ_KVS], uint512_dt kvbuffer{{sw}}2[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset{{sw}}[NUM_PARTITIONS], smalluint_t kvbufferstats_size{{sw}}[NUM_PARTITIONS], smallmargin_t ov{{sw}}[NUM_PARTITIONS], uint512_dt ovkvs_tmp{{sw}}[NUM_PARTITIONS]
	{%endfor%}
	){
	{%for sw in context['NUMSUBWORKERS_seq']%}
	unsigned int ssdpartiton{{sw}}id = ssdpartitonid;
	unsigned int worker{{sw}}id =  beginworkerid + {{sw}};
	unsigned int subworker{{sw}}id = {{sw}};
	unsigned int kvreadoffset{{sw}}_kvs = kvreadoffset_kvs;
	unsigned int kvsize{{sw}}_kvs = kvsize_kvs;
	unsigned int currentLOP{{sw}} = currentLOP;
	unsigned int destpartitionoffset{{sw}} = destpartitionoffset;
	unsigned int upperlimit{{sw}} = upperlimit;
	unsigned int destpartitionrange{{sw}} = destpartitionrange;	
	{%endfor%}
	
	{%for sw in context['NUMSUBWORKERS_seq']%}
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}partition2_ddr{{ddrs}}_w{{w}}_sw{{sw}}(ssdpartiton{{sw}}id, worker{{sw}}id, subworker{{sw}}id, kvreadoffset{{sw}}_kvs, kvsize{{sw}}_kvs, currentLOP{{sw}}, destpartitionoffset{{sw}}, upperlimit{{sw}}, destpartitionrange{{sw}}, kvbuffer{{sw}}1, kvbuffer{{sw}}2, kvbufferstats_offset{{sw}}, kvbufferstats_size{{sw}}, ov{{sw}}, ovkvs_tmp{{sw}});
	{%endfor%}
	return;
}
#endif 
{%endfor%}
{%endfor%}

// APPLY MANY
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}reducemany_ddr{{ddrs}}_w{{w}}(unsigned int IterCount, unsigned int ssdpartitonid, unsigned int beginworkerid, unsigned int verticesreadoffset_vs, metadata_t sourcestatbuffer[NUMSUBWORKERS], unsigned int kvreadoffset_kvs
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	,uint512_dt verticesbuffer{{sw}}[APPLYVERTEXBUFFERSZ_KVS]
	{%endfor%}
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	,uint512_dt kvbuffer{{sw}}[KVSRCBUFFERSZ_APPLY_KVS]
	{%endfor%}	
	){		
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	unsigned int ssdpartiton{{sw}}id = ssdpartitonid; 
	unsigned int worker{{sw}}id = beginworkerid + {{sw}}; 
	unsigned int verticesreadoffset{{sw}}_vs = verticesreadoffset_vs + ({{sw}} * {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid)); 
	unsigned int kvreadoffset{{sw}}_kvs = kvreadoffset_kvs; 
	unsigned int kvsize{{sw}}_kvs = (sourcestatbuffer[{{sw}}].size + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
	{%endfor%}
	
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	#ifdef _DEBUGMODE_PRINTS
	cout<<"reduce_ddr{{ddrs}}_sw{{sw}}: verticesreadoffset: "<<(verticesreadoffset_vs * VECTOR_SIZE)<<", verticesreadoffset for subworker:{{sw}}: "<<((verticesreadoffset_vs + ({{sw}} * {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid))) * VECTOR_SIZE)<<endl;
	#endif
	{%endfor%}
	
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}reduce_ddr{{ddrs}}_w{{w}}_sw{{sw}}(IterCount, ssdpartiton{{sw}}id, worker{{sw}}id, verticesreadoffset{{sw}}_vs, kvreadoffset{{sw}}_kvs, kvsize{{sw}}_kvs, sourcestatbuffer[{{sw}}], verticesbuffer{{sw}}, kvbuffer{{sw}}); // FIXME
	{%endfor%}
	return;
}
{%endfor%}
{%endfor%}

// WRITE MANY
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}writemany_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int beginworkerid, uint512_dt * kvdram, metadata_t kvdeststats_tmp[NUM_PARTITIONS], unsigned int baseaddr_kvs, unsigned int currentLOP, unsigned int destpartitionoffset	
	{%for sw in context['NUMSUBWORKERS_seq']%}
	,uint512_dt kvbuffer{{sw}}[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset{{sw}}[NUM_PARTITIONS], smalluint_t kvbufferstats_size{{sw}}[NUM_PARTITIONS]
	{%endfor%}
	){
	{%for sw in context['NUMSUBWORKERS_seq']%}
	unsigned int ssdpartiton{{sw}}id = ssdpartitonid;
	unsigned int worker{{sw}}id = beginworkerid + {{sw}};
	unsigned int currentLOP{{sw}} = currentLOP;
	unsigned int destpartitionoffset{{sw}} = destpartitionoffset;
	unsigned int baseaddr{{sw}}_kvs = baseaddr_kvs;
	
	{%endfor%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}write_ddr{{ddrs}}_w{{w}}_sw{{sw}}(ssdpartiton{{sw}}id, worker{{sw}}id, currentLOP{{sw}}, destpartitionoffset{{sw}}, kvbuffer{{sw}}, kvbufferstats_offset{{sw}}, kvbufferstats_size{{sw}}, kvdram, kvdeststats_tmp, baseaddr{{sw}}_kvs);
	{%endfor%}
	return;
}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}writemanyAU_Vs_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int beginworkerid, uint512_dt * kvdram, unsigned int baseaddr_vs, unsigned int kvreadoffset_kvs
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	,uint512_dt verticesbuffer{{sw}}[APPLYVERTEXBUFFERSZ_KVS]
	{%endfor%}
	){
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}writeAU_Vs_ddr{{ddrs}}_w{{w}}_sw{{sw}}(ssdpartitonid, (beginworkerid + {{sw}}), kvdram, (kvreadoffset_kvs + ({{sw}} * {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid))), baseaddr_vs, verticesbuffer{{sw}});
	{%endfor%}
	return;
}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
#ifdef _BUFFERB4WRITE
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}writemany_bram2tmp_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int beginworkerid, uint512_dt DESTtmpkvbuffer[TOTALDESTTMPKVBUFFERSZ_KVS], smallmetadata_t DESTtmpkvbuffer_weof[NUM_PARTITIONS], unsigned int baseaddr_kvs, unsigned int currentLOP, unsigned int destpartitionoffset
	{%for sw in context['NUMSUBWORKERS_seq']%}
	,uint512_dt kvbuffer{{sw}}[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset{{sw}}[NUM_PARTITIONS], smalluint_t kvbufferstats_size{{sw}}[NUM_PARTITIONS]
	{%endfor%}
	,unsigned int ibegin_kvs, unsigned int iend_kvs
	){
	#pragma HLS INLINE OFF
	{%for sw in context['NUMSUBWORKERS_seq']%}
	unsigned int ssdpartiton{{sw}}id = ssdpartitonid;
	unsigned int worker{{sw}}id = beginworkerid + {{sw}};
	unsigned int baseaddr{{sw}}_kvs = baseaddr_kvs;
	
	{%endfor%}
	{%for sw in context['NUMSUBWORKERS_seq']%} // FIXME? use single logic?
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}write_bram2tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}(ssdpartiton{{sw}}id, worker{{sw}}id, kvbuffer{{sw}}, DESTtmpkvbuffer, DESTtmpkvbuffer_weof, kvbufferstats_offset{{sw}}, kvbufferstats_size{{sw}}, baseaddr{{sw}}_kvs);	
	{%endfor%}
	return;
}
#endif 
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
#ifdef _BUFFERB4WRITE
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}accel1_writemany_bram2tmp_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int beginworkerid
	,uint512_dt DESTtmpkvbuffer[TOTALDESTTMPKVBUFFERSZ_KVS], smalluint_t DESTtmpkvbufferstats_offset[NUM_PARTITIONS], smalluint_t DESTtmpkvbufferstats_size[NUM_PARTITIONS]
	{%for sw in context['NUMSUBWORKERS_seq']%}
	,uint512_dt kvbuffer{{sw}}[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset_sw{{sw}}[NUM_PARTITIONS], smalluint_t kvbufferstats_size_sw{{sw}}[NUM_PARTITIONS]
	{%endfor%}
	,unsigned int dummy
	){
	{%for sw in context['NUMSUBWORKERS_seq']%}
	unsigned int ssdpartiton_sw{{sw}}id = ssdpartitonid;
	unsigned int worker_sw{{sw}}id = beginworkerid + {{sw}};
	{%endfor%}
	
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}mergeoffsetsandsizes_ddr{{ddrs}}_w{{w}}(ssdpartitonid, beginworkerid 
		,DESTtmpkvbufferstats_offset, DESTtmpkvbufferstats_size
		{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
		,kvbufferstats_size_sw{{sw}}
		{%endfor%}
		);
	
	{%for sw in context['NUMSUBWORKERS_seq']%}
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}accel1_write_bram2tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}(ssdpartiton_sw{{sw}}id, worker_sw{{sw}}id
			,kvbuffer{{sw}}, kvbufferstats_offset_sw{{sw}}, kvbufferstats_size_sw{{sw}}
			,DESTtmpkvbuffer, DESTtmpkvbufferstats_offset, DESTtmpkvbufferstats_size);
	{%endfor%}
	return;
}
#endif 
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
#ifdef _BUFFERB4WRITE
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}writemany_bram2dram_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int beginworkerid, uint512_dt * kvdram, metadata_t kvdeststats_tmp[NUM_PARTITIONS], smallmetadata_t DESTtmpkvbuffer_weof[NUM_PARTITIONS], unsigned int baseaddr_kvs, unsigned int currentLOP, unsigned int destpartitionoffset
	{%for sw in context['NUMSUBWORKERS_seq']%}
	,uint512_dt kvbuffer{{sw}}[KVDESTBUFFERSZ_KVS], smalluint_t kvbufferstats_offset{{sw}}[NUM_PARTITIONS], smalluint_t kvbufferstats_size{{sw}}[NUM_PARTITIONS]
	{%endfor%}
	,unsigned int ibegin_kvs, unsigned int iend_kvs
	){
	{%for sw in context['NUMSUBWORKERS_seq']%}
	unsigned int ssdpartiton{{sw}}id = ssdpartitonid;
	unsigned int worker{{sw}}id = beginworkerid + {{sw}};
	unsigned int baseaddr{{sw}}_kvs = baseaddr_kvs;
	
	{%endfor%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}write_bram2dram_ddr{{ddrs}}_w{{w}}_sw{{sw}}(ssdpartiton{{sw}}id, worker{{sw}}id, kvbuffer{{sw}}, DESTtmpkvbuffer_weof, kvbufferstats_offset{{sw}}, kvbufferstats_size{{sw}}, kvdram, kvdeststats_tmp, baseaddr{{sw}}_kvs);	
	{%endfor%}
	return;
}
#endif 
{%endfor%}
{%endfor%}

// WRITE TMP 2 DRAM
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
#ifdef _BUFFERB4WRITE
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}write_tmp2dram_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int workerid, unsigned int currentLOP, unsigned int destpartitionoffset, 
		uint512_dt * kvdram, metadata_t kvdeststats_tmp[NUM_PARTITIONS], uint512_dt DESTtmpkvbuffer[TOTALDESTTMPKVBUFFERSZ_KVS], smallmetadata_t DESTtmpkvbuffer_weof[NUM_PARTITIONS], unsigned int baseaddr_kvs, unsigned int ibegin_kvs, unsigned int iend_kvs){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::write_tmp2dram{{ddrs}}. workerid: "<<workerid<<std::endl;
	#endif
	int kvbuffersz_kvs = KVBUFFERSZ_KVS; // NB: debugging purposes only
	unsigned int kvbuffersz_perpartition_kvs = (KVBUFFERSZ_KVS  / NUM_PARTITIONS) * NUMSUBWORKERS;  // NB: debugging purposes only

	WRITE_TMP2DRAM_ddr{{ddrs}}_w{{w}}_LOOP1A: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		unsigned int dramoffset_g = kvdeststats_tmp[p].offset / VECTOR_SIZE;
		unsigned int dramoffset_l = kvdeststats_tmp[p].size / VECTOR_SIZE;
		dramsz_dtype dramoffset = baseaddr_kvs + dramoffset_g + dramoffset_l;
		unsigned int desttmpbaseoffset_kvs = DESTtmpkvbuffer_weof[p].offset / VECTOR_SIZE;
		kvbuffersz_dtype size_desttmp_kvs = DESTtmpkvbuffer_weof[p].size / VECTOR_SIZE;	
		// if((size_desttmp_kvs < ((NM - 1) * KVSRCBUFFERSZ_KVS)) && (ibegin_kvs + (NUMWORKERS * NUMSUBWORKERS * KVBUFFERSZ_KVS) < iend_kvs)){ continue; }
		if((size_desttmp_kvs < ((NM - 1) * DESTTMPSLICESZ_KVS)) && (ibegin_kvs + (NUMWORKERS * NUMSUBWORKERS * KVBUFFERSZ_KVS) < iend_kvs)){ continue; }

		unsigned int desttmpoffset_kvs = (p * DESTTMPKVBUFFERSZ_KVS) + desttmpbaseoffset_kvs;
		WRITE_TMP2DRAM_ddr{{ddrs}}_w{{w}}_LOOP1B: for(kvbuffersz_dtype i=0; i<size_desttmp_kvs; i++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_perpartition_kvs avg=kvbuffersz_perpartition_kvs
		#pragma HLS PIPELINE II=1
			#ifdef _DEBUGMODE_CHECKS
			checkforoutofbounds_kernel((offset + i), KVSRCBUFFERSZ_KVS, "out-of-bounds seen at write_tmp2dram{{ddrs}} 5", 0, 0, 0);
			checkforoutofbounds_kernel((dramoffset_g + dramoffset_l + i), PADDEDKVDATA_BATCHSIZE_KVS, "out-of-bounds seen at write_tmp2dram{{ddrs}} 6", 0, 0, 0);
			if(p<(NUM_PARTITIONS-1)){ checkforoutofbounds_kernel((dramoffset_g + dramoffset_l + i), kvdeststats_tmp[p+1].offset, "out-of-bounds seen at write_tmp2dram{{ddrs}} 7", 0, 0, 0); }
			else { checkforoutofbounds_kernel((dramoffset_g + dramoffset_l + i), PADDEDKVDATA_BATCHSIZE, "out-of-bounds seen at write_tmp2dram{{ddrs}} 8", 0, 0, 0); }
			#endif
			#ifdef _DEBUGMODE_STATS
			kvpairswritten_tmp2dram{{ddrs}} += VECTOR_SIZE;
			#endif
			
			#ifdef FORCDFINISH
			kvdram[((dramoffset + i) & (FORCDFINISH_DRAMSZ_KVS - 1))] = DESTtmpkvbuffer[(desttmpoffset_kvs + i)]; 
			#else 
			kvdram[(dramoffset + i)] = DESTtmpkvbuffer[(desttmpoffset_kvs + i)]; 
			#endif 
		}
		kvdeststats_tmp[p].size += size_desttmp_kvs * VECTOR_SIZE;
		DESTtmpkvbuffer_weof[p].size = 0;
		#ifdef _DEBUGMODE_CHECKS2
		if(p<(NUM_PARTITIONS-1)){ checkforoutofbounds_kernel((kvdeststats_tmp[p].offset + kvdeststats_tmp[p].size), kvdeststats_tmp[(p+1)].offset, "out-of-bounds seen at write_tmp2dram_ddr{{ddrs}}_w{{w}} 65", (kvdeststats_tmp[p].offset + kvdeststats_tmp[p].size), kvdeststats_tmp[(p+1)].offset, 0); }
		#endif	
		#ifdef _DEBUGMODE_STATS
		kvpairswritten_tmp2dram{{ddrs}}_transfers += 1;
		#endif
	}
	return;
}
#endif 
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['BUNDLEFACTOR_seq']%}
#ifdef _BUFFERB4WRITE
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}accel1_write_tmp2dram_ddr{{ddrs}}_w{{w}}(unsigned int ssdpartitonid, unsigned int workerid
		,uint512_dt * kvdram, metadata_t kvdeststats_tmp[NUM_PARTITIONS]
		,uint512_dt DESTtmpkvbuffer[TOTALDESTTMPKVBUFFERSZ_KVS], smalluint_t DESTtmpkvbufferstats_offset[NUM_PARTITIONS], smalluint_t DESTtmpkvbufferstats_size[NUM_PARTITIONS]
		,unsigned int baseaddr_kvs){
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<"Kernel::accel1_write_tmp2dram_ddr{{ddrs}}_w{{w}}. workerid: "<<workerid<<std::endl;
	#endif
	int kvbuffersz_kvs = KVBUFFERSZ_KVS; // NB: debugging purposes only
	unsigned int kvbuffersz_perpartition_kvs = (KVBUFFERSZ_KVS  / NUM_PARTITIONS) * NUMSUBWORKERS;  // NB: debugging purposes only

	WRITE_TMP2DRAM_ddr{{ddrs}}_w{{w}}_LOOP1A: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		unsigned int dramoffset_g_kvs = kvdeststats_tmp[p].offset / VECTOR_SIZE;
		unsigned int dramoffset_l_kvs = kvdeststats_tmp[p].size / VECTOR_SIZE;
		dramsz_dtype dramoffset = baseaddr_kvs + dramoffset_g_kvs + dramoffset_l_kvs;
		unsigned int desttmpoffset_kvs = DESTtmpkvbufferstats_offset[p] / VECTOR_SIZE;
		kvbuffersz_dtype desttmpsize_kvs = DESTtmpkvbufferstats_size[p] / VECTOR_SIZE;
		#ifdef _DEBUGMODE_CHECKS2
		checkforoutofbounds_kernel(dramoffset, _x3PADDEDKVDATA_SIZE_KVS, "out-of-bounds seen at accel1_write_tmp2dram_ddr{{ddrs}}_w{{w}} 5", 0, 0, 0);
		checkforoutofbounds_kernel(desttmpoffset_kvs, TOTALDESTTMPKVBUFFERSZ_KVS, "out-of-bounds seen at accel1_write_tmp2dram_ddr{{ddrs}}_w{{w}} 6", 0, 0, 0);
		checkforoutofbounds_kernel(desttmpsize_kvs, TOTALDESTTMPKVBUFFERSZ_KVS, "out-of-bounds seen at accel1_write_tmp2dram_ddr{{ddrs}}_w{{w}} 7", 0, 0, 0);
		#endif		
		
		WRITE_TMP2DRAM_ddr{{ddrs}}_w{{w}}_LOOP1B: for(kvbuffersz_dtype i=0; i<desttmpsize_kvs; i++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=kvbuffersz_perpartition_kvs avg=kvbuffersz_perpartition_kvs
		#pragma HLS PIPELINE II=1
			#ifdef _DEBUGMODE_STATS
			kvpairswritten_tmp2dram{{ddrs}} += VECTOR_SIZE;
			#endif
			
			#ifdef FORCDFINISH
			kvdram[((dramoffset + i) & (FORCDFINISH_DRAMSZ_KVS - 1))] = DESTtmpkvbuffer[(desttmpoffset_kvs + i)]; 
			#else 
			kvdram[(dramoffset + i)] = DESTtmpkvbuffer[(desttmpoffset_kvs + i)]; 
			#endif
			
			#ifdef _DEBUGMODE_CHECKS2
			if(p<(NUM_PARTITIONS-1)){ checkforoutofbounds_kernel(((dramoffset + i) * VECTOR_SIZE), ((baseaddr_kvs * VECTOR_SIZE) + kvdeststats_tmp[p+1].offset), "out-of-bounds seen at accel1_write_tmp2dram_ddr{{ddrs}}_w{{w}} 85", p, (p+1), 0); }
			#endif
		}
		
		kvdeststats_tmp[p].size += desttmpsize_kvs * VECTOR_SIZE;
		DESTtmpkvbufferstats_size[p] = 0;
		#ifdef _DEBUGMODE_CHECKS2
		// if(p<(NUM_PARTITIONS-1)){ checkforoutofbounds_kernel((kvdeststats_tmp[p].offset + kvdeststats_tmp[p].size), kvdeststats_tmp[(p+1)].offset, "out-of-bounds seen at accel3_write_tmp2dram_ddr{{ddrs}}_w{{w}} 15", (kvdeststats_tmp[p].offset + kvdeststats_tmp[p].size), kvdeststats_tmp[(p+1)].offset, 0); }
		#endif	
		#ifdef _DEBUGMODE_STATS
		kvpairswritten_tmp2dram{{ddrs}}_transfers += 1;
		#endif
	}
	return;
}
#endif
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}topkernel_instancePU{{ddrs}}(
		unsigned int command,
		uint512_dt * kvdram,
		metadata_t * kvstats,
		unsigned int treedepth,
		unsigned int finalnumpartitions,
		unsigned int vbegin,
		unsigned int ssdpartitonid,
		unsigned int paddedkvdatabatchsz_kvs

		#ifdef _SHARED_SRCBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,uint512_dt srckvbuffer_ddr{{ddrs}}_w0_sw{{sw}}[KVSRCBUFFERSZ_KVS]
		{%endfor%}
		#endif
		#ifdef _SHARED_DESTBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,uint512_dt destkvbuffer_ddr{{ddrs}}_w0_sw{{sw}}[KVDESTBUFFERSZ_KVS]
		{%endfor%}
		#endif
		#ifdef _SHARED_DESTBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,uint512_dt ovkvs_tmp_ddr{{ddrs}}_w0_sw{{sw}}[NUM_PARTITIONS]
		{%endfor%}
		#endif
        ){
	if(command != ON){ return; }
	
	unsigned int maxtreedepthsz = TREEDEPTH_FORSSDPARTITION0; // NB: debugging purposes only
	unsigned int steps = treedepth + 1;
	// unsigned int steps = 2 + 1; // FIXME. CHANGEBACK

	// Source kv buffer
	#ifdef _SHARED_SRCBUFFER
	{%for w in context['NUMWORKERS_FROM2nd_seq']%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	uint512_dt srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}[KVSRCBUFFERSZ_KVS];
	{%endfor%}
	{%endfor%}
	#endif

	{%for w in context['NUMWORKERS_seq']%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	#ifndef _SHARED_SRCBUFFER
	uint512_dt srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}[KVSRCBUFFERSZ_KVS];
	#endif
	#ifdef _USEURAM_SRCKVBUFFER
	#pragma HLS RESOURCE variable=srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}} core=XPM_MEMORY uram 
	#endif 
	{%endfor%}
	{%endfor%}
	
	// Destination kv buffer
	#ifdef _SHARED_DESTBUFFER
	{%for w in context['NUMWORKERS_FROM2nd_seq']%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	uint512_dt destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}[KVDESTBUFFERSZ_KVS];
	{%endfor%}
	{%endfor%}
	#endif
	
	{%for w in context['NUMWORKERS_seq']%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	#ifndef _SHARED_DESTBUFFER
	uint512_dt destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}[KVDESTBUFFERSZ_KVS]; 
	#endif
	#ifndef _WIDEWORD
	#pragma HLS DATA_PACK variable=srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}
	#pragma HLS DATA_PACK variable=destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}
	#endif
	{%endfor%}
	{%endfor%}
	
	// Overflow kv buffer
	#ifdef _SHARED_DESTBUFFER
	{%for w in context['NUMWORKERS_FROM2nd_seq']%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	uint512_dt ovkvs_tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}[NUM_PARTITIONS];
	{%endfor%}
	{%endfor%}
	#endif
	
	#ifndef _SHARED_DESTBUFFER
	{%for w in context['NUMWORKERS_seq']%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	uint512_dt ovkvs_tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}[NUM_PARTITIONS];
	{%endfor%}
	{%endfor%}
	#endif
	
	// Other structures
	{%for w in context['NUMWORKERS_seq']%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	smalluint_t kvbufferstats_offset_w{{w}}_sw{{sw}}[NUM_PARTITIONS];
	smalluint_t kvbufferstats_size_w{{w}}_sw{{sw}}[NUM_PARTITIONS];	
	smallmargin_t ov_w{{w}}_sw{{sw}}[NUM_PARTITIONS];
	{%endfor%}
	{%endfor%}
	
	// Mergers
	#ifdef _MERGED_SRCANDDESTANDOVSTMPBUFFER
	{%for w in context['NUMWORKERS_FROM2nd_seq']%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	#pragma HLS ARRAY_MAP variable=srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}} instance=array4_ddr{{ddrs}}_w{{w}}_sw{{sw}} horizontal
	#pragma HLS ARRAY_MAP variable=destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}} instance=array4_ddr{{ddrs}}_w{{w}}_sw{{sw}} horizontal
	#pragma HLS ARRAY_MAP variable=ovkvs_tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}} instance=array4_ddr{{ddrs}}_w{{w}}_sw{{sw}} horizontal
	{%endfor%}
	{%endfor%}
	#endif
	
	// ALL 
	// Destination tmp kv Buffer
	#ifdef _BUFFERB4WRITE
	{%for w,sepw in zip(context['NUMWORKERS_seq'], context['BUNDLEFACTOR_lseq'])%}
	uint512_dt DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}[TOTALDESTTMPKVBUFFERSZ_KVS];
	smallmetadata_t DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}_weof[NUM_PARTITIONS];	
	smalluint_t DESTtmpkvbufferstats_ddrs{{ddrs}}_w{{w}}_offset[NUM_PARTITIONS];
	smalluint_t DESTtmpkvbufferstats_ddrs{{ddrs}}_w{{w}}_size[NUM_PARTITIONS];	
	#ifdef _USEURAM_DESTTMPKVBUFFER
	#pragma HLS RESOURCE variable=DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}} core=XPM_MEMORY uram 
	#endif 
	{%endfor%}
	#endif

	READ_PARTITION_WRITE_LOOP1: for(unsigned int currentLOP=1; currentLOP<(steps % 8); currentLOP++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=maxtreedepthsz avg=maxtreedepthsz
		#ifdef _DEBUGMODE_PRINTS_TMP
		std::cout<<std::endl;
		std::cout<<"### kernel::topkernel_instancePU{{ddrs}} Started: currentLOP: "<<currentLOP<<" ###"<<std::endl;
		#endif 
		#ifdef _DEBUGMODE_PRINTS
		printkvbuffer_kernel(kvdram, 32, "kernel::topkernel_instancePU{{ddrs}}:: printing kvdram");
		#endif
		#ifdef _DEBUGMODE_STATS
		kvpairsread{{ddrs}} = 0;
		kvpairswritten{{ddrs}} = 0;
		kvpairsread{{ddrs}}_transfers = 0;
		kvpairswritten{{ddrs}}_transfers = 0;
		#ifdef _BUFFERB4WRITE
		kvpairswritten_bram2tmp{{ddrs}} = 0;
		kvpairswritten_tmp2dram{{ddrs}} = 0;
		kvpairswritten_bram2tmp{{ddrs}}_transfers = 0;
		kvpairswritten_tmp2dram{{ddrs}}_transfers = 0;
		#endif 
		kvpairswritten_interm2dest_parallel{{ddrs}} = 0;
		kvpairswritten_interm2dest_seqential{{ddrs}} = 0;
		INapplyphase = 0;
		#endif
		
		metadata_t kvdeststats_tmp[NUM_PARTITIONS];
		unsigned int sourcebaseaddr_kvs = 0;
		unsigned int destbaseaddr_kvs = 0;

		INITKVDRAMREACKER_LOOP: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
			#pragma HLS PIPELINE II=1
			kvdeststats_tmp[p].size = 0;
		}
		
		if((currentLOP % 2) == 1){
			sourcebaseaddr_kvs = 0;
			destbaseaddr_kvs = paddedkvdatabatchsz_kvs;
		} else {
			sourcebaseaddr_kvs = paddedkvdatabatchsz_kvs;
			destbaseaddr_kvs = 0;
		}
		
		#ifdef _BUFFERB4WRITE
		{%for w,sepw in zip(context['NUMWORKERS_seq'], context['BUNDLEFACTOR_lseq'])%}
		INITDESTTMPKVBUFFERWEOF_LOOP1{{w}}: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
			DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}_weof[p].offset = 0;
			DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}_weof[p].size = 0;
			DESTtmpkvbufferstats_ddrs{{ddrs}}_w{{w}}_offset[p] = 0;
			DESTtmpkvbufferstats_ddrs{{ddrs}}_w{{w}}_size[p] = 0;
		}
		{%endfor%}
		#endif 

		unsigned int num_source_partitions = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}get_num_source_partitions(currentLOP);
		unsigned int nextsourceoffset_partition = 0;
		unsigned int nextdestoffset_partition = 0;
		unsigned int nextsourceoffset_kv = 0;
		unsigned int nextdestoffset_kv = 0;
		unsigned int sourceskipsize_partition = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getsourceskipsize(currentLOP, finalnumpartitions);
		unsigned int destskipsize_partition = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getdestskipsize(currentLOP, finalnumpartitions);
		unsigned int sourceskipsize_kv = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getsourceskipsize(currentLOP, {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid));
		unsigned int destskipsize_kv = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getdestskipsize(currentLOP, {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid));
		unsigned int destpartitionrange = (1 << ({%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION_POW(ssdpartitonid) - (NUM_PARTITIONS_POW * currentLOP)));
		#ifdef _DEBUGMODE_PRINTS_TMP
		print4ints_kernel(">>> kernel::topkernel_instancePU{{ddrs}}", "currentLOP", currentLOP, "tree depth", treedepth, "num_source_partitions", num_source_partitions, "number of kvs in each final partition", destskipsize_kv);
		print4ints_kernel(">>> kernel::topkernel_instancePU{{ddrs}}", "currentLOP", currentLOP, "tree depth", treedepth, "num_source_partitions", num_source_partitions, "number of destination partitions", ({%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid) / destskipsize_kv));		
		#endif
		#ifdef _DEBUGMODE_PRINTS_TMP
		print4ints_kernel(">>> kernel::topkernel_instancePU{{ddrs}}", "currentLOP", currentLOP, "num_source_partitions", num_source_partitions, "tree depth", treedepth, "", 0);
		print4ints_kernel(">>> kernel::topkernel_instancePU{{ddrs}}", "sourceskipsize_partition", sourceskipsize_partition, "destskipsize_partition", destskipsize_partition, "sourceskipsize_kv", sourceskipsize_kv, "destskipsize_kv", destskipsize_kv);
		#endif
		
		unsigned int avgnum_source_partitions = (1 << (TREE_DEPTH * NUM_PARTITIONS_POW)); // NB: debugging purposes only
		if(num_source_partitions > finalnumpartitions){ num_source_partitions = 0; } 
		READ_PARTITION_WRITE_LOOP2: for(unsigned int source_partition=0; source_partition<num_source_partitions; source_partition++){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=avgnum_source_partitions avg=avgnum_source_partitions
			#ifdef _DEBUGMODE_PRINTS_TMP
			print4ints_kernel("kernel::topkernel_instancePU{{ddrs}}", "ssdpartitonid", ssdpartitonid, "source_partition", source_partition, "num_source_partitions", num_source_partitions, "tree depth", {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETTREEDEPTH(ssdpartitonid));
			#endif
			
			#ifdef _BUFFERB4WRITE
			{%for w,sepw in zip(context['NUMWORKERS_seq'], context['BUNDLEFACTOR_lseq'])%}
			INITDESTTMPKVBUFFERWEOF_LOOP2{{w}}: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
				DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}_weof[p].offset = 0;
				DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}_weof[p].size = 0;
				DESTtmpkvbufferstats_ddrs{{ddrs}}_w{{w}}_offset[p] = 0;
				DESTtmpkvbufferstats_ddrs{{ddrs}}_w{{w}}_size[p] = 0;	
			}
			{%endfor%}
			#endif 

			{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}loaddeststats(kvstats, kvdeststats_tmp, nextdestoffset_partition, currentLOP, finalnumpartitions);
			#ifdef _DEBUGMODE_PRINTS
			printstats_kernel(kvdeststats_tmp, NUM_PARTITIONS, "kernel::kvdeststats_tmp", source_partition, 0, 0);
			print4ints_kernel("kernel::topkernel_instancePU{{ddrs}}", "source_partition", source_partition, "num_source_partitions", num_source_partitions, "destpartitionoffset", nextdestoffset_partition, "nextsourceoffset_partition", nextsourceoffset_partition);
			#endif

			{%for w in context['NUMWORKERS_seq']%}
			{%for sw in context['NUMSUBWORKERS_seq']%}
			INITOV_LOOP_w{{w}}_sw{{sw}}1: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
				ov_w{{w}}_sw{{sw}}[p].begin = 0; ov_w{{w}}_sw{{sw}}[p].size = 0;
			}
			{%endfor%}
			{%endfor%}
			
			INITKVDRAMREACKER_LOOP2: for(unsigned int p=0; p<NUM_PARTITIONS; p++){
				#pragma HLS PIPELINE II=1
				kvdeststats_tmp[p].size = 0;
			}
			
			if(nextsourceoffset_partition >= FORCDFINISH_KVSTATS_SIZE){ nextsourceoffset_partition = 0; } 
			metadata_t sourcestat = kvstats[(nextsourceoffset_partition % FORCDFINISH_KVSTATS_SIZE)]; 
			unsigned int begin_kvs = sourcestat.offset / VECTOR_SIZE;
			unsigned int size_kvs = (sourcestat.size + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
			
			unsigned int alligndownsize_kvs = sourcestat.size / VECTOR_SIZE;
			unsigned int offset_kvs = sourcebaseaddr_kvs + begin_kvs + alligndownsize_kvs;
			unsigned int topk = sourcestat.size % VECTOR_SIZE;
			unsigned int sizek = allignup_KV(sourcestat.size) - sourcestat.size;
			#ifdef SW 
			// for(unsigned int k=0; k<sizek; k++){ kvdram[offset_kvs].data[(topk + k)].key=kvdram[offset_kvs].data[0].key; kvdram[offset_kvs].data[(topk + k)].value=0; }
			for(unsigned int k=0; k<sizek; k++){ kvdram[offset_kvs].data[(topk + k)].key=INVALIDDATA; kvdram[offset_kvs].data[(topk + k)].value=INVALIDDATA; }
			#else
			keyvalue_t INVkv; INVkv.key = INVALIDDATA; INVkv.value = INVALIDDATA; 
			for(unsigned int k=0; k<sizek; k++){ setkventryII(kvdram, ((offset_kvs * VECTOR_SIZE) + topk + k), INVkv); }
			#endif 
			#ifdef _DEBUGMODE_PRINTS
			std::cout<<"kernel::topkernel_instancePU{{ddrs}}:: begin_kvs "<<begin_kvs<<", size_kvs: "<<size_kvs<<", begin: "<<(begin_kvs * VECTOR_SIZE)<<", size: "<<(size_kvs * VECTOR_SIZE)<<", (sourcestat.size % VECTOR_SIZE): "<<(sourcestat.size % VECTOR_SIZE)<<endl;
			#endif
			
			unsigned int avgikvs_sz = PADDEDKVDATA_BATCHSIZE_KVS / avgnum_source_partitions; // NB: debugging purposes only
			unsigned int avgtripcnt = avgikvs_sz / (NUMWORKERS * NUMSUBWORKERS * KVBUFFERSZ_KVS); // NB: debugging purposes only			
			unsigned int ikvs_sz = begin_kvs + size_kvs;
			if(ikvs_sz >= paddedkvdatabatchsz_kvs){ begin_kvs = 0; ikvs_sz = 0; } 
			if(begin_kvs > ikvs_sz){ begin_kvs = 0; ikvs_sz = 0; } 
			READ_PARTITION_WRITE_LOOP3: for(unsigned int i_kvs=begin_kvs; i_kvs<ikvs_sz; i_kvs+=(NUMWORKERS * NUMSUBWORKERS * KVBUFFERSZ_KVS)){
				#pragma HLS LOOP_TRIPCOUNT min=0 max=avgtripcnt avg=avgtripcnt
				#ifdef _DEBUGMODE_PRINTS // 
				std::cout<<"kernel::topkernel_instancePU{{ddrs}}::Current Iteration:: offset_kvs: "<<i_kvs<<", last offset: "<<ikvs_sz<<", skip size (kvs): "<<(NUMWORKERS * NUMSUBWORKERS * KVBUFFERSZ_KVS)<<", source_partition: "<<source_partition<<", currentLOP: "<<currentLOP<<endl;
				#endif
				#ifdef _DEBUGMODE_CHECKS2
				state_i_kvs = i_kvs;
				state_ikvs_sz = ikvs_sz;
				#endif 
				
				{%for w,sepw in zip(context['NUMWORKERS_seq'], context['BUNDLEFACTOR_lseq'])%}
				unsigned int ssdpartiton{{w}}id = ssdpartitonid;
				unsigned int beginworker{{w}}id = {{w}} * NUMSUBWORKERS;
				unsigned int baseaddr{{w}}_kvs = sourcebaseaddr_kvs;
				unsigned int kvreadoffset{{w}}_kvs = i_kvs + ({{w}} * NUMSUBWORKERS * KVBUFFERSZ_KVS);
				unsigned int kvsize{{w}}_kvs = begin_kvs + size_kvs;
				unsigned int currentLOP{{w}} = currentLOP;
				unsigned int destpartitionoffset{{w}} = nextdestoffset_partition;
				unsigned int upperlimit{{w}} = vbegin + nextsourceoffset_kv;
				unsigned int destpartitionrange{{w}} = destpartitionrange;
				unsigned int ibegin{{w}}_kvs = i_kvs;
				unsigned int iend{{w}}_kvs = ikvs_sz;
				unsigned int destbaseaddr{{w}}_kvs = destbaseaddr_kvs;
				unsigned int finalnumpartitions{{w}} = finalnumpartitions;
				{%endfor%}
				
				{%for w,sepw in zip(context['NUMWORKERS_seq'], context['BUNDLEFACTOR_lseq'])%}
				#ifdef _DEBUGMODE_PRINTS
				std::cout<<"Worker {{w}} started"<<std::endl;
				{%for sw in context['NUMSUBWORKERS_seq']%}
				for(unsigned int p=0; p<NUM_PARTITIONS; p++){
					printovs2_kernel(ov_w{{w}}_sw{{sw}}, p, "[kernel::READ_PARTITION_WRITE_LOOP]::_w{{w}}_sw{{sw}}", {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}getkventryII(ov_w{{w}}_sw{{sw}}[p].begin, destkvbuffer_w{{w}}_sw{{sw}}).key, 0, 0);
				}
				{%endfor%}
				#endif
				
				readmany_ddr{{ddrs}}_w{{sepw}}(beginworker{{w}}id, kvdram, baseaddr{{w}}_kvs, kvreadoffset{{w}}_kvs, kvsize{{w}}_kvs
					{%for sw in context['NUMSUBWORKERS_seq']%}
					,srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}
					{%endfor%}
					);
					
				#ifdef _SEPERATE_EXTRACTANDPARTITIONFUNC
				extractmanystats2_ddr{{ddrs}}_w{{sepw}}(ssdpartiton{{w}}id, beginworker{{w}}id, kvreadoffset{{w}}_kvs, kvsize{{w}}_kvs, currentLOP{{w}}, destpartitionoffset{{w}}, upperlimit{{w}}, destpartitionrange{{w}}
					{%for sw in context['NUMSUBWORKERS_seq']%}
					,srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}, destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}, kvbufferstats_offset_w{{w}}_sw{{sw}}, kvbufferstats_size_w{{w}}_sw{{sw}}, ov_w{{w}}_sw{{sw}}, ovkvs_tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}
					{%endfor%}
					);
				#endif 
					
				#ifdef _SEPERATE_EXTRACTANDPARTITIONFUNC
				partitionmany2_ddr{{ddrs}}_w{{sepw}}(ssdpartiton{{w}}id, beginworker{{w}}id, kvreadoffset{{w}}_kvs, kvsize{{w}}_kvs, currentLOP{{w}}, destpartitionoffset{{w}}, upperlimit{{w}}, destpartitionrange{{w}}
					{%for sw in context['NUMSUBWORKERS_seq']%}
					,srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}, destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}, kvbufferstats_offset_w{{w}}_sw{{sw}}, kvbufferstats_size_w{{w}}_sw{{sw}}, ov_w{{w}}_sw{{sw}}, ovkvs_tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}
					{%endfor%}
					);
				#endif  
					
				#ifndef _SEPERATE_EXTRACTANDPARTITIONFUNC
				partitionmany_ddr{{ddrs}}_w{{sepw}}(ssdpartiton{{w}}id, beginworker{{w}}id, kvreadoffset{{w}}_kvs, kvsize{{w}}_kvs, currentLOP{{w}}, destpartitionoffset{{w}}, upperlimit{{w}}, destpartitionrange{{w}}
					{%for sw in context['NUMSUBWORKERS_seq']%}
					,srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}, destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}, kvbufferstats_offset_w{{w}}_sw{{sw}}, kvbufferstats_size_w{{w}}_sw{{sw}}, ov_w{{w}}_sw{{sw}}, ovkvs_tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}
					{%endfor%}
					);
				#endif
				
				#ifdef _BUFFERB4WRITE
				#ifdef _BUFFERB4WRITE_DEPRECIATED
				writemany_bram2tmp_ddr{{ddrs}}_w{{sepw}}(ssdpartiton{{w}}id, beginworker{{w}}id, DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}, DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}_weof, destbaseaddr{{w}}_kvs, currentLOP{{w}}, destpartitionoffset{{w}}
					{%for sw in context['NUMSUBWORKERS_seq']%}
					,destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}, kvbufferstats_offset_w{{w}}_sw{{sw}}, kvbufferstats_size_w{{w}}_sw{{sw}}
					{%endfor%}
					,ibegin{{w}}_kvs, iend{{w}}_kvs
					);
				#else 
				accel1_writemany_bram2tmp_ddr{{ddrs}}_w{{sepw}}(ssdpartiton{{w}}id, beginworker{{w}}id
					,DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}, DESTtmpkvbufferstats_ddrs{{ddrs}}_w{{w}}_offset, DESTtmpkvbufferstats_ddrs{{ddrs}}_w{{w}}_size
					{%for sw in context['NUMSUBWORKERS_seq']%}
					,destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}, kvbufferstats_offset_w{{w}}_sw{{sw}}, kvbufferstats_size_w{{w}}_sw{{sw}}
					{%endfor%}
					,NAp
					);
				#endif
				#endif 
				
				#ifdef _BUFFERB4WRITE
				#ifdef _BUFFERB4WRITE_DEPRECIATED
				write_tmp2dram_ddr{{ddrs}}_w{{sepw}}(ssdpartiton{{w}}id, beginworker{{w}}id, currentLOP{{w}}, destpartitionoffset{{w}}, kvdram, kvdeststats_tmp, DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}, DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}_weof, destbaseaddr{{w}}_kvs, ibegin{{w}}_kvs, iend{{w}}_kvs);
				#else 
				accel1_write_tmp2dram_ddr{{ddrs}}_w{{sepw}}(ssdpartiton{{w}}id, beginworker{{w}}id
					,kvdram, kvdeststats_tmp, DESTtmpkvbuffer_ddrs{{ddrs}}_w{{w}}, DESTtmpkvbufferstats_ddrs{{ddrs}}_w{{w}}_offset, DESTtmpkvbufferstats_ddrs{{ddrs}}_w{{w}}_size, destbaseaddr{{w}}_kvs);
				#endif
				#endif
					
				#ifndef _BUFFERB4WRITE
				writemany_ddr{{ddrs}}_w{{sepw}}(ssdpartiton{{w}}id, beginworker{{w}}id, kvdram, kvdeststats_tmp, destbaseaddr{{w}}_kvs, currentLOP{{w}}, destpartitionoffset{{w}}
					{%for sw in context['NUMSUBWORKERS_seq']%}
					,destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}, kvbufferstats_offset_w{{w}}_sw{{sw}}, kvbufferstats_size_w{{w}}_sw{{sw}}
					{%endfor%}
					);
				#endif
				{%endfor%}
			}
			
			// edge conditions
			// kvdeststats_tmp[0].size -= sizek;
			{%for w,sepw in zip(context['NUMWORKERS_seq'], context['BUNDLEFACTOR_lseq'])%}
			{%for sw in context['NUMSUBWORKERS_seq']%}
			writeremainingovs_ddr{{ddrs}}_w{{sepw}}_sw{{sw}}(ssdpartitonid, ({{w}} * NUMSUBWORKERS), kvdram, kvdeststats_tmp, ovkvs_tmp_ddr{{ddrs}}_w{{w}}_sw{{sw}}, ov_w{{w}}_sw{{sw}}, destbaseaddr_kvs);
			{%endfor%}
			{%endfor%}
			kvdeststats_tmp[0].size -= sizek;
			// if(currentLOP == 1){ cout<<"------------------------------------------------------------------------ kvdeststats_tmp[0].size: "<<kvdeststats_tmp[0].size<<endl; }
			
			#ifdef _DEBUGMODE_CHECKS
			check_kvdram_kernel(kvdram, destbaseaddr_kvs, kvdeststats_tmp, nextdestoffset_partition, currentLOP, {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETTREEDEPTH(ssdpartitonid), finalnumpartitions, {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid));
			#endif
			#ifdef _DEBUGMODE_STATSX
			std::cout<<"### source partition ended: kvpairsread{{ddrs}}: "<<kvpairsread{{ddrs}}<<", kvpairswritten{{ddrs}}: "<<kvpairswritten{{ddrs}}<<" ###"<<std::endl;
			#endif
			{%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}storedeststats(kvstats, kvdeststats_tmp, nextdestoffset_partition, currentLOP, finalnumpartitions);
			nextsourceoffset_partition += sourceskipsize_partition;
			nextdestoffset_partition += (destskipsize_partition * NUM_PARTITIONS);
			nextsourceoffset_kv += sourceskipsize_kv;
			nextdestoffset_kv += destskipsize_kv;
		}
		
		#ifdef _DEBUGMODE_STATS
		std::cout<<">>>"<<endl;
		std::cout<<"### topkernel_instancePU::Summary:: KV PAIRS READ (DRAM {{ddrs_}}): "<<kvpairsread{{ddrs}}<<" ("<<kvpairsread{{ddrs}}_transfers<<" TRANSFERS)"<<endl;		
		std::cout<<"### topkernel_instancePU::Summary:: KV PAIRS WRITTEN (DRAM {{ddrs_}}): "<<kvpairswritten{{ddrs}}<<" ("<<kvpairswritten{{ddrs}}_transfers<<" TRANSFERS)"<<endl;
		#ifdef _BUFFERB4WRITE
		std::cout<<">>>"<<endl;
		std::cout<<"### topkernel_instancePU::Summary:: KV PAIRS WRITTEN FROM BRAM TO TMP (DRAM {{ddrs_}}): "<<kvpairswritten_bram2tmp{{ddrs}}<<" ("<<kvpairswritten_bram2tmp{{ddrs}}_transfers<<" TRANSFERS)"<<endl;	
		std::cout<<"### topkernel_instancePU::Summary:: KV PAIRS WRITTEN FROM TMP TO DRAM (DRAM {{ddrs_}}): "<<kvpairswritten_tmp2dram{{ddrs}}<<" ("<<kvpairswritten_tmp2dram{{ddrs}}_transfers<<" TRANSFERS)"<<endl;
		std::cout<<"### topkernel_instancePU::Summary:: TOTAL KV PAIRS WRITTEN TO DRAM (DRAM {{ddrs_}}): "<<(kvpairswritten{{ddrs}} + kvpairswritten_tmp2dram{{ddrs}})<<" ("<<(kvpairswritten{{ddrs}} + kvpairswritten_tmp2dram{{ddrs}})<<" TRANSFERS)"<<endl;
		#endif	
		std::cout<<std::endl;
		#endif
	}
	return;
}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}topkernel_instanceAU{{ddrs}}(
		unsigned int command,
		unsigned int IterCount,
		uint512_dt * kvdram,
		metadata_t * kvstats,
		unsigned int treedepth,
		unsigned int finalnumpartitions,
		unsigned int vbegin,
		unsigned int ssdpartitonid,
		unsigned int paddedkvdatabatchsz_kvs
		
		#ifdef _SHARED_SRCBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,uint512_dt srckvbuffer_ddr{{ddrs}}_w0_sw{{sw}}[KVSRCBUFFERSZ_KVS]
		{%endfor%}
		#endif
		#ifdef _SHARED_DESTBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,uint512_dt destkvbuffer_ddr{{ddrs}}_w0_sw{{sw}}[KVDESTBUFFERSZ_KVS]
		{%endfor%}
		#endif
		#ifdef _SHARED_DESTBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,uint512_dt ovkvs_tmp_ddr{{ddrs}}_w0_sw{{sw}}[NUM_PARTITIONS]
		{%endfor%}
		#endif
        ){
	if(command != ON){ return; }

	unsigned int currentLOP = treedepth + 1;
	#ifdef _DEBUGMODE_PRINTS
	std::cout<<std::endl;
	std::cout<<"### kernel::topkernel_instanceAU{{ddrs}} Started: currentLOP: "<<currentLOP<<" ###"<<std::endl;
	printkvbuffer_kernel(kvdram, 32, "kernel::topkernel_instanceAU{{ddrs}}:: printing kvdram");
	#endif
	#ifdef _DEBUGMODE_STATS
	kvpairsread{{ddrs}} = 0;
	kvpairswritten{{ddrs}} = 0;
	INapplyphase = 1;
	#endif

	unsigned int sourcebaseaddr_kvs = 0;
	unsigned int destbaseaddr_vs = 0;
	if((treedepth % 2) == 1){
		sourcebaseaddr_kvs = paddedkvdatabatchsz_kvs;
	} else {
		sourcebaseaddr_kvs = 0;
	}
	destbaseaddr_vs = 2 * paddedkvdatabatchsz_kvs; // third part houses the vertices 
	
	// src kvbuffer
	#ifndef _SHARED_SRCBUFFER
	{%for w in context['NUMWORKERS_APPLYPH_seq']%}
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	uint512_dt srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}[KVSRCBUFFERSZ_APPLY_KVS];
	#ifndef _WIDEWORD
	#pragma HLS DATA_PACK variable=srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}
	#endif
	{%endfor%}
	{%endfor%}
	#endif
	
	#ifndef _SHARED_DESTBUFFER
	{%for w in context['NUMWORKERS_APPLYPH_seq']%}
	{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
	uint512_dt destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}[APPLYVERTEXBUFFERSZ_KVS];
	#ifndef _WIDEWORD
	#pragma HLS DATA_PACK variable=destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}
	/// #pragma HLS RESOURCE variable=destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}} core=XPM_MEMORY uram // utilizes URAM
	#endif
	{%endfor%}
	{%endfor%}
	#endif
	
	unsigned int num_source_partitions = {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}get_num_source_partitions(currentLOP);
	#ifdef _DEBUGMODE_PRINTS_TMP
	print4ints_kernel("kernel::kernel", "currentLOP", currentLOP, "num_source_partitions", num_source_partitions, "tree depth", treedepth, "vbegin", vbegin);
	#endif

	READ_PARTITION_WRITE_LOOP1: for(unsigned int source_partition=0; source_partition<num_source_partitions; source_partition+=NUMSUBWORKERS_APPLYPH){
		#ifdef _DEBUGMODE_PRINTS_TMP
		print4ints_kernel("kernel::topkernel_instanceAU{{ddrs}}", "ssdpartitonid", ssdpartitonid, "source_partition", source_partition, "num_source_partitions", num_source_partitions, "skip size", NUMSUBWORKERS_APPLYPH);
		#endif

		metadata_t sourcestatbuffer[NUMSUBWORKERS_APPLYPH];
		for(unsigned int i=0; i<NUMSUBWORKERS_APPLYPH; i++){
			sourcestatbuffer[i] = kvstats[((source_partition + i) % FORCDFINISH_KVSTATS_SIZE)]; 
			#ifdef _DEBUGMODE_PRINTS
			cout<<">>> sourcestatbuffer["<<i<<"].offset: "<<sourcestatbuffer[i].offset<<", kvstats["<<(source_partition + i)<<"].offset: "<<kvstats[(source_partition + i)].offset<<", kvstats["<<(source_partition + i)<<"].size: "<<kvstats[(source_partition + i)].size<<endl;
			#endif
		}
		#ifdef _DEBUGMODE_PRINTS
		for(unsigned int i=0; i<NUMSUBWORKERS_APPLYPH; i++){ std::cout<<"kernel::topkernel_instanceAU{{ddrs}}:: begin_kvs[i] "<<(sourcestatbuffer[i].offset / VECTOR_SIZE)<<", size_kvs[i]: "<<(sourcestatbuffer[i].size / VECTOR_SIZE)<<endl; }
		#endif

		#ifdef _DEBUGMODE_PRINTS
		std::cout<<"kernel::topkernel_instanceAU{{ddrs}}:: next read offset: "<<(source_partition * {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION(ssdpartitonid))<<endl;
		#endif
		/** [NUMSUBWORKERS_APPLYPH] consecutive locations are loaded into each verticesbuffer */
		{%for w in context['NUMWORKERS_APPLYPH_seq']%}
		readmanyAU_Vs_ddr{{ddrs}}_w0(ssdpartitonid, ({{w}} * NUMSUBWORKERS_APPLYPH), kvdram, destbaseaddr_vs, (source_partition * {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid)), {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETKVDATA_RANGE_PERSSDPARTITION(ssdpartitonid) /// FIXME KVDATA_BATCHSIZE?
				{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
				,destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}
				{%endfor%}
				);
		{%endfor%}
		
		unsigned int maxsz = 0;
		for(unsigned int sw=0; sw<NUMSUBWORKERS_APPLYPH; sw++){ maxsz = max(sourcestatbuffer[sw].size, maxsz); } // get max number of iterations
		unsigned int max_ikvs = ceildiv(maxsz, (NUMWORKERS_APPLYPH * KVSRCBUFFERSZ_APPLY));

		READ_PARTITION_WRITE_LOOP2: for(unsigned int i=0; i<max_ikvs; i++){
			unsigned int i_kvs = i * NUMWORKERS_APPLYPH * KVSRCBUFFERSZ_APPLY_KVS;
			#ifdef _DEBUGMODE_PRINTS
			std::cout<<"kernel::topkernel_instanceAU{{ddrs}}::Current Iteration:: i: "<<i<<", i_kvs: "<<i_kvs<<", max_ikvs: "<<max_ikvs<<", skip size (kvs): "<<(NUMWORKERS_APPLYPH * NUMSUBWORKERS_APPLYPH * KVBUFFERSZ_KVS)<<endl;
			#endif
		
			/** Each subworker is assigned to a last-level partition. */
			{%for w,sepw in zip(context['NUMWORKERS_APPLYPH_seq'], context['BUNDLEFACTOR_APPLYPH_lseq'])%}
			unsigned int ssdpartiton{{w}}id = ssdpartitonid; 
			unsigned int beginworker{{w}}id = {{w}} * NUMSUBWORKERS_APPLYPH; 
			unsigned int verticesreadoffset{{w}}_vs = ((vbegin / VECTOR_SIZE) + (source_partition * {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid))); 
			unsigned int kvreadoffset{{w}}_kvs = i_kvs + ({{w}} * KVSRCBUFFERSZ_APPLY_KVS);
			unsigned int sourcebaseaddr{{w}}_kvs = sourcebaseaddr_kvs;			
			{%endfor%}
			
			{%for w,sepw in zip(context['NUMWORKERS_APPLYPH_seq'], context['BUNDLEFACTOR_APPLYPH_lseq'])%}
			readmanyAU_VUs_ddr{{ddrs}}_w{{sepw}}(beginworker{{w}}id, kvdram, sourcebaseaddr{{w}}_kvs, sourcestatbuffer, kvreadoffset{{w}}_kvs, PADDEDKVDATA_BATCHSIZE /// FIXME KVDATA_BATCHSIZE or PADDEDKVDATA_BATCHSIZE?
				{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
				,srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}
				{%endfor%}
				);		
			
			/** Each subworker's key-values' is committed to its vertices' */
			reducemany_ddr{{ddrs}}_w{{sepw}}(IterCount, ssdpartitonid, beginworker{{w}}id, verticesreadoffset{{w}}_vs, sourcestatbuffer, kvreadoffset{{w}}_kvs 
				{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
				,destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}
				{%endfor%}
				{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
				,srckvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}
				{%endfor%}
				);	
			{%endfor%}
		}

		#ifdef _DEBUGMODE_PRINTS
		std::cout<<"kernel::topkernel_instanceAU{{ddrs}}:: next write offset: "<<(source_partition * {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid))<<endl;
		#endif
		{%for w in context['NUMWORKERS_APPLYPH_seq']%}
		writemanyAU_Vs_ddr{{ddrs}}_w0(ssdpartitonid, ({{w}} * NUMSUBWORKERS_APPLYPH), kvdram, destbaseaddr_vs, (source_partition * {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}GETAPPLYVERTEXBUFFERSZ_PERSSDPARTITION_KVS(ssdpartitonid))
				{%for sw in context['NUMSUBWORKERS_APPLYPH_seq']%}
				,destkvbuffer_ddr{{ddrs}}_w{{w}}_sw{{sw}}
				{%endfor%}
				);
		{%endfor%}
	}
	#ifdef _DEBUGMODE_STATS
	std::cout<<"### topkernel_instanceAU ended::Summary:: kvpairsread{{ddrs}}: "<<kvpairsread{{ddrs}}<<", kvpairswritten{{ddrs}}: "<<kvpairswritten{{ddrs}}<<" ########"<<std::endl<<std::endl;
	#endif
	return;
}
{%endfor%}

extern "C" {
void {%if(context['XWARE'] == "SW")%}kernelprocess::{%endif%}topkernel(
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		{%if(ddrs==0)%}{%else%},{%endif%}uint512_dt * kvdram{{ddrs_}}
		{%endfor%}
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		,metadata_t * kvstats{{ddrs_}}
		{%endfor%}
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		,int * messages{{ddrs_}}
		{%endfor%}
        ){
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE m_axi port=kvdram{{ddrs_}}  offset=slave bundle=gmem{{ddrs}}
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE m_axi port=kvstats{{ddrs_}}  offset=slave bundle=gmem{{context['NUMINSTANCES'] + ddrs}}
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE m_axi port=messages{{ddrs_}}  offset=slave bundle=gmem{{context['NUMINSTANCES'] + context['NUMINSTANCES'] + ddrs}}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE s_axilite port=kvdram{{ddrs_}}  bundle=control
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE s_axilite port=kvstats{{ddrs_}}  bundle=control
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE s_axilite port=messages{{ddrs_}} bundle=control
{%endfor%}
#pragma HLS INTERFACE s_axilite port=return bundle=control

#ifndef _WIDEWORD
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS DATA_PACK variable=kvdram{{ddrs_}}
{%endfor%}
#endif 
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS DATA_PACK variable=kvstats{{ddrs_}}
{%endfor%}

	#if defined(_DEBUGMODE_PRINTS_TMP) || defined(_DEBUGMODE_STATS)
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	std::cout<<std::endl;
	std::cout<<"Kernel Started: messages{{ddrs_}}[MESSAGES_KVDATASIZEID]: "<<messages{{ddrs_}}[MESSAGES_KVDATASIZEID]<<std::endl;
	std::cout<<"Kernel Started: final number of partitions: "<<messages{{ddrs_}}[MESSAGES_FINALNUMPARTITIONSID]<<std::endl;
	std::cout<<"Kernel Started: messages{{ddrs_}}[MESSAGES_COMMANDID]: "<<messages{{ddrs_}}[MESSAGES_COMMANDID]<<std::endl;
	std::cout<<"Kernel Started: messages{{ddrs_}}[MESSAGES_ITERATIONID]: "<<messages{{ddrs_}}[MESSAGES_ITERATIONID]<<std::endl;
	std::cout<<"Kernel Started: messages{{ddrs_}}[MESSAGES_SSDPARTITIONID]: "<<messages{{ddrs_}}[MESSAGES_SSDPARTITIONID]<<std::endl;
	std::cout<<"Kernel Started: messages{{ddrs_}}[DRAM_VOFFSET]: "<<messages{{ddrs_}}[DRAM_VOFFSET]<<std::endl;
	std::cout<<"Kernel Started: messages{{ddrs_}}[DRAM_VSIZE]: "<<messages{{ddrs_}}[DRAM_VSIZE]<<std::endl;
	std::cout<<"Kernel Started: messages{{ddrs_}}[DRAM_TREEDEPTH]: "<<messages{{ddrs_}}[DRAM_TREEDEPTH]<<std::endl;
	std::cout<<"Kernel Started: messages{{ddrs_}}[DRAM_FINALNUMPARTITIONS]: "<<messages{{ddrs_}}[DRAM_FINALNUMPARTITIONS]<<std::endl;
	std::cout<<"Kernel Started: messages{{ddrs_}}[MESSAGES_PADDEDKVDATA_BATCHSIZE_KVS_ID]: "<<messages{{ddrs_}}[MESSAGES_PADDEDKVDATA_BATCHSIZE_KVS_ID]<<std::endl;
	{%endfor%}	
	#endif
	#ifdef _DEBUGMODE_PRINTS
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	printkvbuffer(kvdram{{ddrs}}, 32, "kernel.kvdram{{ddrs_}}");
	{%endfor%}
	#endif
	
	#ifdef _SHARED_SRCBUFFER
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	uint512_dt srckvbuffer_ddr{{ddrs}}_w0_sw{{sw}}[KVSRCBUFFERSZ_KVS];
	{%endfor%}
	{%endfor%}
	#endif
	
	#ifdef _SHARED_DESTBUFFER
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	uint512_dt destkvbuffer_ddr{{ddrs}}_w0_sw{{sw}}[KVDESTBUFFERSZ_KVS];
	{%endfor%}
	{%endfor%}
	#endif
	
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	uint512_dt ovkvs_tmp_ddr{{ddrs}}_w0_sw{{sw}}[NUM_PARTITIONS];
	{%endfor%}
	{%endfor%}	
	
	#ifdef _SHARED_SRCBUFFER
	#ifdef _SHARED_DESTBUFFER
	#ifdef _MERGED_SRCANDDESTANDOVSTMPBUFFER
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	#pragma HLS ARRAY_MAP variable=srckvbuffer_ddr{{ddrs}}_w0_sw{{sw}} instance=array4_ddr{{ddrs}}_w0_sw{{sw}} horizontal
	#pragma HLS ARRAY_MAP variable=destkvbuffer_ddr{{ddrs}}_w0_sw{{sw}} instance=array4_ddr{{ddrs}}_w0_sw{{sw}} horizontal
	#pragma HLS ARRAY_MAP variable=ovkvs_tmp_ddr{{ddrs}}_w0_sw{{sw}} instance=array4_ddr{{ddrs}}_w0_sw{{sw}} horizontal
	{%endfor%}
	{%endfor%}
	#endif
	#endif
	#endif
	
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}	
	unsigned int dram{{ddrs_}}_processcommand = messages{{ddrs_}}[(MESSAGES_PROCESSCOMMANDID )];
	unsigned int dram{{ddrs_}}_partitioncommand = messages{{ddrs_}}[(MESSAGES_PARTITIONCOMMANDID )];
	unsigned int dram{{ddrs_}}_reducecommand = messages{{ddrs_}}[(MESSAGES_APPLYUPDATESCOMMANDID )];
	unsigned int dram{{ddrs_}}_iteration_idx = messages{{ddrs_}}[(MESSAGES_ITERATIONID)]; 
	unsigned int dram{{ddrs_}}_ssdpartitonid = messages{{ddrs_}}[(MESSAGES_SSDPARTITIONID)];
	unsigned int dram{{ddrs_}}_vbegin = messages{{ddrs_}}[(DRAM_VOFFSET)]; 
	unsigned int dram{{ddrs_}}_vsize = messages{{ddrs_}}[(DRAM_VSIZE)]; 
	unsigned int dram{{ddrs_}}_treedepth = messages{{ddrs_}}[(DRAM_TREEDEPTH)]; 
	unsigned int dram{{ddrs_}}_finalnumpartitions = messages{{ddrs_}}[(DRAM_FINALNUMPARTITIONS)]; 
	unsigned int dram{{ddrs_}}_paddedkvdatabatchszkvs = messages{{ddrs_}}[MESSAGES_PADDEDKVDATA_BATCHSIZE_KVS_ID];
	unsigned int dram{{ddrs_}}_IterCount = messages{{ddrs_}}[GRAPH_ITERATIONID];
	{%endfor%}
	
	#ifndef FPGA_IMPL
	std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();
	#endif
	
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	topkernel_instancePU{{ddrs}}(
		dram{{ddrs_}}_partitioncommand,
		kvdram{{ddrs_}},
		kvstats{{ddrs_}},
		dram{{ddrs_}}_treedepth,
		dram{{ddrs_}}_finalnumpartitions,
		dram{{ddrs_}}_vbegin,
		dram{{ddrs_}}_ssdpartitonid,
		dram{{ddrs_}}_paddedkvdatabatchszkvs
		#ifdef _SHARED_SRCBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,srckvbuffer_ddr{{ddrs}}_w0_sw{{sw}}
		{%endfor%}
		#endif 
		#ifdef _SHARED_DESTBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,destkvbuffer_ddr{{ddrs}}_w0_sw{{sw}}
		{%endfor%}
		#endif 
		#ifdef _SHARED_DESTBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,ovkvs_tmp_ddr{{ddrs}}_w0_sw{{sw}}
		{%endfor%}
		#endif 
		);
	// return;
		
	topkernel_instanceAU{{ddrs}}(
		dram{{ddrs_}}_reducecommand,
		dram{{ddrs_}}_IterCount,
		kvdram{{ddrs_}},
		kvstats{{ddrs_}},
		dram{{ddrs_}}_treedepth,
		dram{{ddrs_}}_finalnumpartitions,
		dram{{ddrs_}}_vbegin,
		dram{{ddrs_}}_ssdpartitonid,
		dram{{ddrs_}}_paddedkvdatabatchszkvs
		#ifdef _SHARED_SRCBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,srckvbuffer_ddr{{ddrs}}_w0_sw{{sw}}
		{%endfor%}
		#endif 
		#ifdef _SHARED_DESTBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,destkvbuffer_ddr{{ddrs}}_w0_sw{{sw}}
		{%endfor%}
		#endif 
		#ifdef _SHARED_DESTBUFFER
		{%for sw in context['NUMSUBWORKERS_seq']%}
		,ovkvs_tmp_ddr{{ddrs}}_w0_sw{{sw}}
		{%endfor%}
		#endif
		);
	// return;
	{%endfor%}	
	#ifndef FPGA_IMPL
	#ifdef _DEBUGMODE_TIMERS
	std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();
	std::cout << "Kernel Finished: Time difference = " << std::chrono::duration_cast<std::chrono::nanoseconds> (end - begin).count() << "[nanao seconds]" << std::endl;
	std::cout << "Kernel Finished: Time difference = " << std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count() << "[micro seconds]" << std::endl;
	std::cout << "Kernel Finished: Time difference = " << std::chrono::duration_cast<std::chrono::milliseconds> (end - begin).count() << "[milli seconds]" << std::endl;
	std::cout << "Kernel Finished: Time difference = " << std::chrono::duration_cast<std::chrono::seconds> (end - begin).count() << "[seconds]" << std::endl;
	std::cout << std::endl;
	#endif 
	#endif 
	return;
}
}

{%if(context['XWARE'] == "SW")%}
kernelprocess::kernelprocess(){}
kernelprocess::~kernelprocess(){}
{%endif%}
