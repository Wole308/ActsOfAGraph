#include "{{context['PROJECT_BASEPATH']}}/src/common.h"
{%if(context['XWARE'] != "HW")%}
#include <string>
#include <string.h>
#include <iostream>
#include <vector>
#include <string.h>
#include <stdio.h>
#include <ctime>
#include <functional>
#include <sys/time.h>
#include <time.h>
#include <stdlib.h>
#include <iomanip>
#include <cmath>
#include <fstream>
{%endif%}
#include "{{context['PROJECT_BASEPATH']}}/kernels/acts.h"
using namespace std;
#define ADDCONSTRAINER

#ifndef FPGA_IMPL
acts::acts(){}
acts::~acts(){}
#endif
#ifndef HW

unsigned int globalvar_totalkvstatsread;
unsigned int globalvar_totalkvsreadV;

unsigned int globalvar_totalkvsread4statscollection;
unsigned int globalvar_totalkvstatswritten;

unsigned int globalvar_totalkvsread;
unsigned int globalstats_totalkvswritten;

unsigned int globalstats_totalkvspartitioned;
unsigned int globalstats_totalkvscombined;
unsigned int globalstats_totalkvspartitionswritten;

unsigned int globalstats_totalkvsreduced;
unsigned int globalstats_totalkvsreducewritten;
#endif 
#ifdef _LDEBUGMODE_HEADER
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}checkoutofbounds(string message, unsigned int data, unsigned int upper_bound, unsigned int msgdata1, unsigned int msgdata2, unsigned int msgdata3){
	if(data >= upper_bound){ std::cout<<"acts::checkoutofbounds: ERROR. out of bounds. message: "<<message<<", data: "<<data<<", upper_bound: "<<upper_bound<<", msgdata1: "<<msgdata1<<", msgdata2: "<<msgdata2<<", msgdata3: "<<msgdata3<<std::endl; exit(EXIT_FAILURE); }
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}checkforequal(string message, unsigned int data1, unsigned int data2){
	if(data1 == data2){ cout<<"acts::checkforequal: ERROR. data1 == data2. message: "<<message<<", data1: "<<data1<<", data2: "<<data2<<endl; exit(EXIT_FAILURE); }
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}print1(string messagea, unsigned int dataa){
	cout<<messagea<<": "<<dataa<<endl;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}print4(string messagea, string messageb, string messagec, string messaged, unsigned int dataa, unsigned int datab, unsigned int datac, unsigned int datad){
	cout<<messagea<<": "<<dataa<<", "<<messageb<<": "<<datab<<", "<<messagec<<": "<<datac<<", "<<messaged<<": "<<datad<<endl;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}print5(string messagea, string messageb, string messagec, string messaged, string messagee, unsigned int dataa, unsigned int datab, unsigned int datac, unsigned int datad, unsigned int datae){
	cout<<messagea<<": "<<dataa<<", "<<messageb<<": "<<datab<<", "<<messagec<<": "<<datac<<", "<<messaged<<": "<<datad<<", "<<messagee<<": "<<datae<<endl;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}print6(string messagea, string messageb, string messagec, string messaged, string messagee, string messagef, unsigned int dataa, unsigned int datab, unsigned int datac, unsigned int datad, unsigned int datae, unsigned int datef){
	cout<<messagea<<": "<<dataa<<", "<<messageb<<": "<<datab<<", "<<messagec<<": "<<datac<<", "<<messaged<<": "<<datad<<", "<<messagee<<": "<<datae<<", "<<messagef<<": "<<datef<<endl;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}printkeyvalues(string message, keyvalue_t * keyvalues, unsigned int size){
	cout<<endl<<"printkeyvalues:"<<message<<endl;
	for(unsigned int p=0; p<size; p++){ cout<<"keyvalues["<<p<<"].key: "<<keyvalues[p].key<<", keyvalues["<<p<<"].value: "<<keyvalues[p].value<<endl; }
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}printkeyvalues(string message, keyvalue_t * keyvalues1, keyvalue_t * keyvalues2, unsigned int size){
	cout<<endl<<"printkeyvalues:"<<message<<endl;
	for(unsigned int p=0; p<size; p++){ cout<<"["<<keyvalues1[p].key<<":"<<keyvalues1[p].value<<"]["<<keyvalues2[p].key<<":"<<keyvalues2[p].value<<"]"<<endl; }
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}printkeyvalues(string message, uint512_dt * keyvalues, unsigned int size_kvs){
	cout<<endl<<"printkeyvalues:"<<message<<endl;
	for(unsigned int i=0; i<size_kvs; i++){ 
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
			cout<<"keyvalues["<<i<<"].data[{{v}}].key: "<<(unsigned int)keyvalues[i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}})<<", keyvalues["<<i<<"].data[{{v}}].value: "<<(unsigned int)keyvalues[i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}})<<endl;
		{%endfor%}
		#else 
		for(unsigned int v=0; v<VECTOR_SIZE; v++){ cout<<"keyvalues["<<i<<"].data["<<v<<"].key: "<<keyvalues[i].data[v].key<<", keyvalues["<<i<<"].data["<<v<<"].value: "<<keyvalues[i].data[v].value<<endl; }
		#endif 
	}
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}getvaluecount(string message, keyvalue_t * keyvalues, unsigned int size){
	unsigned int totalnumkeyvalues = 0;
	for(unsigned int p=0; p<size; p++){ totalnumkeyvalues += keyvalues[p].value; }
	cout<<"total values counted: "<<totalnumkeyvalues<<endl;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}printparameters(){
	cout<<endl<<"acts::printparameters: test started."<<endl;
	cout<<"acts::printparameters:: KVDATA_BATCHSIZE: "<<KVDATA_BATCHSIZE<<endl;
	cout<<"acts::printparameters:: KVDATA_BATCHSIZE_KVS: "<<KVDATA_BATCHSIZE_KVS<<endl;
	
	cout<<"acts::printparameters:: PADDEDBUFFER_SIZE: "<<PADDEDBUFFER_SIZE<<endl;
	
	cout<<"acts::printparameters:: KVDRAMSZ: "<<KVDRAMSZ<<endl;
	cout<<"acts::printparameters:: KVDRAMSZ_KVS: "<<KVDRAMSZ_KVS<<endl;
	
	cout<<"acts::printparameters:: KVSOURCEDRAMSZ: "<<KVSOURCEDRAMSZ<<endl;
	cout<<"acts::printparameters:: KVSOURCEDRAMSZ_KVS: "<<KVSOURCEDRAMSZ_KVS<<endl;
	
	cout<<"acts::printparameters:: PADDEDKVSOURCEDRAMSZ: "<<PADDEDKVSOURCEDRAMSZ<<endl;
	cout<<"acts::printparameters:: PADDEDKVSOURCEDRAMSZ_KVS: "<<PADDEDKVSOURCEDRAMSZ_KVS<<endl;
	
	cout<<"acts::printparameters:: SRCBUFFER_SIZE: "<<SRCBUFFER_SIZE<<endl;
	cout<<"acts::printparameters:: SRCBUFFER_SIZE * VECTOR_SIZE: "<<SRCBUFFER_SIZE * VECTOR_SIZE<<endl;
	
	cout<<"acts::printparameters:: PADDEDDESTBUFFER_SIZE: "<<PADDEDDESTBUFFER_SIZE<<endl;
	cout<<"acts::printparameters:: PADDEDDESTBUFFER_SIZE * VECTOR_SIZE: "<<PADDEDDESTBUFFER_SIZE * VECTOR_SIZE<<endl;
	
	cout<<"acts::printparameters:: PADDEDBUFFER_SIZE / NUM_PARTITIONS: "<<PADDEDBUFFER_SIZE / NUM_PARTITIONS<<endl;
	
	cout<<"acts::printparameters:: PADDEDDESTBUFFER_SIZE * NUMSUBWORKERS (total dest_kvs memory): "<<(PADDEDDESTBUFFER_SIZE * NUMSUBWORKERS)<<endl;
	cout<<"acts::printparameters:: PADDEDDESTBUFFER_SIZE * VECTOR_SIZE * NUMSUBWORKERS (total dest memory): "<<(PADDEDDESTBUFFER_SIZE * VECTOR_SIZE * NUMSUBWORKERS)<<endl;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}printglobalvars(){
	cout<<"printglobalvars: "<<endl;
	cout<<"acts::printglobalvars:: globalvar_totalkvsread: "<<globalvar_totalkvsread<<endl;
	cout<<"acts::printglobalvars:: globalvar_totalkvsreadV: "<<globalvar_totalkvsreadV<<endl;
	
	cout<<"acts::printglobalvars:: globalstats_totalkvswritten: "<<globalstats_totalkvswritten<<endl;
	
	cout<<"acts::printglobalvars:: globalvar_totalkvstatsread: "<<globalvar_totalkvstatsread<<endl;
	cout<<"acts::printglobalvars:: globalvar_totalkvsread4statscollection: "<<globalvar_totalkvsread4statscollection<<endl;
	cout<<"acts::printglobalvars:: globalvar_totalkvstatswritten: "<<globalvar_totalkvstatswritten<<endl;	

	cout<<"acts::printglobalvars:: globalstats_totalkvspartitioned: "<<globalstats_totalkvspartitioned<<endl;
	cout<<"acts::printglobalvars:: globalstats_totalkvscombined: "<<globalstats_totalkvscombined<<endl;
	cout<<"acts::printglobalvars:: globalstats_totalkvspartitionswritten: "<<globalstats_totalkvspartitionswritten<<endl;
	
	cout<<"acts::printglobalvars:: globalstats_totalkvsreduced: "<<globalstats_totalkvsreduced<<endl;
	cout<<"acts::printglobalvars:: globalstats_totalkvsreducewritten: "<<globalstats_totalkvsreducewritten<<endl;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}clearglobalvars(){
	cout<<"clearglobalvars: "<<endl;
	globalvar_totalkvsread = 0;
	globalstats_totalkvswritten = 0;
	globalstats_totalkvspartitionswritten = 0;
	globalstats_totalkvspartitioned = 0;
	globalstats_totalkvscombined = 0;
	globalvar_totalkvstatsread = 0;
	globalvar_totalkvsread4statscollection = 0;
	globalvar_totalkvstatswritten = 0;
	globalstats_totalkvsreduced = 0;
	globalstats_totalkvsreducewritten = 0;
	globalvar_totalkvsreadV = 0;
}
keyvalue_t ** Debugger_Sizes1;
keyvalue_t ** Debugger_Sizes2;
unsigned int debugger_i;
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}createDebuggers(){
	Debugger_Sizes1 = new keyvalue_t*[DEBUGGER_SIZE];
	Debugger_Sizes2 = new keyvalue_t*[DEBUGGER_SIZE];
	for(int i = 0; i < DEBUGGER_SIZE; ++i){
		Debugger_Sizes1[i] = new keyvalue_t[NUM_PARTITIONS];
		Debugger_Sizes2[i] = new keyvalue_t[NUM_PARTITIONS];
	}
	initializeDebuggers();
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}initializeDebuggers(){
	for(unsigned int i=0; i<DEBUGGER_SIZE; i++){ // reset
		for(unsigned int p=0; p<NUM_PARTITIONS; p++){
			Debugger_Sizes1[i][p].key = 0;
			Debugger_Sizes1[i][p].value = 0;
			Debugger_Sizes2[i][p].key = 0;
			Debugger_Sizes2[i][p].value = 0;
		}
	}
	debugger_i = 0;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}debuggerA(keyvalue_t ** Debugger_Sizes, keyvalue_t sizes[NUM_PARTITIONS], unsigned int committype){
	checkoutofbounds("acts::debuggerA 34", debugger_i, DEBUGGER_SIZE, debugger_i, DEBUGGER_SIZE, NAp);
	for(partition_type p=0; p<NUM_PARTITIONS; p++){
		Debugger_Sizes[debugger_i][p].key = 0;
		if(committype == 0){ Debugger_Sizes[debugger_i][p].value += sizes[p].value; }
		else if(committype == 1){ Debugger_Sizes[debugger_i][p].value = sizes[p].value; }
		else {}
	}
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}IsEqual(keyvalue_t ** data1, keyvalue_t ** data2, unsigned int _1stdimsize, unsigned int _2nddimsize){
	for(unsigned int i=0; i<_1stdimsize; i++){
		for(unsigned int p=0; p<_2nddimsize; p++){
			if((data1[i][p].key == data2[i][p].key) && (data1[i][p].value == data2[i][p].value)){} 
			else {
				cout<<"ERROR:IsEqual: unequal values seen: i: "<<i<<", p: "<<p<<endl;
				cout<<"data1["<<i<<"]["<<p<<"].key: "<<data1[i][p].key<<", data1["<<i<<"]["<<p<<"].value: "<<data1[i][p].value<<endl;
				cout<<"data2["<<i<<"]["<<p<<"].key: "<<data2[i][p].key<<", data2["<<i<<"]["<<p<<"].value: "<<data2[i][p].value<<endl;
				exit(EXIT_FAILURE);
			}
		}
	}
	cout<<"SUCCESS:IsEqual: test passed. _1stdimsize: "<<_1stdimsize<<", _2nddimsize: "<<_2nddimsize<<endl;
	return;
}
#endif
#ifdef _DEBUGMODE_STATS
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}globalstats_countkvstatsread(unsigned int count){
	globalvar_totalkvstatsread += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}globalvar_countkvsread4statscollection(unsigned int count){
	globalvar_totalkvsread4statscollection += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}globalstats_countkvstatswritten(unsigned int count){
	globalvar_totalkvstatswritten += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}globalstats_countkvsread(unsigned int count){
	globalvar_totalkvsread += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}globalstats_countkvswritten(unsigned int count){
	globalstats_totalkvswritten += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}globalstats_countkvspartitionswritten(unsigned int count){
	globalstats_totalkvspartitionswritten += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}globalstats_countkvspartitioned(unsigned int count){
	globalstats_totalkvspartitioned += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}globalstats_countkvscombined(unsigned int count){
	globalstats_totalkvscombined += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}globalstats_countkvsreduced(unsigned int count){
	globalstats_totalkvsreduced += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}globalstats_countkvsreducewritten(unsigned int count){
	globalstats_totalkvsreducewritten += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}globalstats_countkvsreadV(unsigned int count){
	globalvar_totalkvsreadV += count;
	return;
}
#endif 

unsigned int {%if(context['XWARE'] == "SW")%}acts::{%endif%}allignhigher_KV(unsigned int val){
	unsigned int fac = (val + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
	return (fac * VECTOR_SIZE);
}
unsigned int {%if(context['XWARE'] == "SW")%}acts::{%endif%}allignlower_KV(unsigned int val){
	unsigned int fac = val / VECTOR_SIZE;
	return (fac * VECTOR_SIZE);
}
unsigned int {%if(context['XWARE'] == "SW")%}acts::{%endif%}ceildiv(unsigned int val1, unsigned int val2){
	return (val1 + (val2 - 1)) / val2;
}	
unsigned int {%if(context['XWARE'] == "SW")%}acts::{%endif%}max(unsigned int val1, unsigned int val2){
	if(val1 > val2){ return val1; }
	else { return val2; }
}
unsigned int {%if(context['XWARE'] == "SW")%}acts::{%endif%}min(unsigned int A, unsigned int B){
	#pragma HLS INLINE
	if(A<B){ return A; }
	else { return B; }
}
unsigned int {%if(context['XWARE'] == "SW")%}acts::{%endif%}hsub(unsigned int A, unsigned int B){
	#pragma HLS INLINE
	if(A < B){ return 0; }
	else { return A - B; }
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}checkandforce(unsigned int data, unsigned int upper_bound, unsigned int * datatoforce, unsigned int forceval){
	#pragma HLS INLINE
	return;
	/* if(data >= upper_bound){ *datatoforce = forceval; }
	return; */
}
int {%if(context['XWARE'] == "SW")%}acts::{%endif%}WithinValidRange(unsigned int val1, unsigned int val2){
	#pragma HLS INLINE
	if(val1 < val2){ return 1; }
	else { return 0; }
}

unsigned int {%if(context['XWARE'] == "SW")%}acts::{%endif%}getpartition(keyvalue_t keyvalue, unsigned int currentLOP, vertex_t upperlimit){
	partition_type val = ((keyvalue.key - upperlimit) >> (KVDATA_RANGE_PERSSDPARTITION_POW - (NUM_PARTITIONS_POW * currentLOP)));
	partition_type hashedval = (((1 << NUM_PARTITIONS_POW) - 1) & (val >> (1 - 1)));
	#ifdef _DEBUGMODE_CHECKS2
	checkoutofbounds("acts::getpartition 35", hashedval, NUM_PARTITIONS, NAp, NAp, NAp);
	#endif
	return hashedval;
}
keyvalue_t {%if(context['XWARE'] == "SW")%}acts::{%endif%}getkeyvalue(uint512_dt * buffer, batch_type addr, batch_type maxaddr_kvs){
	#pragma HLS INLINE
	if(addr >= (maxaddr_kvs * VECTOR_SIZE)){ addr = 0; } // FIXME. FORCEDFINISH
	keyvalue_t keyvalue;
	batch_type idy = addr / VECTOR_SIZE;
	vector_type idx = addr % VECTOR_SIZE;
	#ifdef _DEBUGMODE_CHECKS2
	if(idy >= maxaddr_kvs){ cout<<"getkeyvalue:: ERROR 45. addr: "<<addr<<", idy: "<<idy<<", idx: "<<idx<<endl; exit(EXIT_FAILURE); }
	checkoutofbounds("acts::getkeyvalue 35", idy, maxaddr_kvs, NAp, NAp, NAp);
	#endif
	
	#ifdef _WIDEWORD
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else {%endif%}if(idx=={{v}}){	
		keyvalue.key = buffer[idy].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}});
		keyvalue.value = buffer[idy].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}});
	}
	{%endfor%}
	else {}
	#else
	keyvalue = buffer[idy].data[idx];
	#endif
	return keyvalue;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}setkeyvalue(uint512_dt * buffer, batch_type addr, keyvalue_t keyvalue, batch_type maxaddr_kvs){
	#pragma HLS INLINE
	if(addr >= (maxaddr_kvs * VECTOR_SIZE)){ addr = 0; } // FIXME. FORCEDFINISH
	batch_type idy = (addr / VECTOR_SIZE);
	vector_type idx = addr % VECTOR_SIZE;
	#ifdef _DEBUGMODE_CHECKS2
	checkoutofbounds("acts::setkeyvalue 35", idy, maxaddr_kvs, addr, NAp, NAp);
	#endif
	
	#ifdef _WIDEWORD
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else {%endif%}if(idx=={{v}}){	
		buffer[idy].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = keyvalue.key;
		buffer[idy].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = keyvalue.value;
	}
	{%endfor%}
	else {}
	#else
	buffer[idy].data[idx] = keyvalue;
	#endif
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}setkeyvalue(uint512_dt * Vtemp, batch_type idx, keyvalue_t keyvalue){
	#pragma HLS INLINE
	#ifdef _WIDEWORD
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else {%endif%}if(idx=={{v}}){	
		Vtemp->range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = keyvalue.key;
		Vtemp->range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = keyvalue.value;
	}
	{%endfor%}
	else {}
	#else
	Vtemp->data[idx] = keyvalue;
	#endif
	return;
}

void {%if(context['XWARE'] == "SW")%}acts::{%endif%}reset(keyvalue_t * buffer, unsigned int size){
	#pragma HLS INLINE
	RESETKEYVANDVALUES_LOOP: for(partition_type p=0; p<size; p++){ buffer[p].key = 0; buffer[p].value = 0; }
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}resetvalues(keyvalue_t * buffer, unsigned int size){
	#pragma HLS INLINE
	RESETVALUES_LOOP: for(partition_type p=0; p<size; p++){ buffer[p].value = 0; }
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}copykeys(keyvalue_t * buffer1, keyvalue_t * buffer2, unsigned int size){
	#pragma HLS INLINE
	COPYKEYS_LOOP: for(partition_type p=0; p<size; p++){ buffer2[p].key = buffer1[p].key; }
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}copy(keyvalue_t * buffer1, keyvalue_t * buffer2, unsigned int size){
	#pragma HLS INLINE
	COPYKEYS_LOOP: for(partition_type p=0; p<size; p++){ buffer2[p] = buffer1[p]; }
}

buffer_type {%if(context['XWARE'] == "SW")%}acts::{%endif%}getactivesize(buffer_type i, batch_type i_end, buffer_type buffersize){	
	#pragma HLS INLINE
	buffer_type activesize = 0;
	buffer_type next_i = i + buffersize;
	if(i >= i_end){ activesize = 0; }
	else if ((i < i_end) && (next_i < i_end)) { activesize = buffersize; }
	else if ((i < i_end) && (next_i >= i_end)) { activesize = i_end - i; }
	else {
		i = 0; 
		#ifdef _DEBUGMODE_CHECKS
		cout<<"getactivesize:: should NEVER get here: activesize: "<<activesize<<", i: "<<i<<", next_i: "<<next_i<<", i_end: "<<i_end<<endl;
		exit(EXIT_FAILURE);
		#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTSX
	print4("getactivesize: i", "i_end", "buffersize", "activesize", i, i_end, buffersize, activesize);
	#endif
	return activesize;
}
batch_type {%if(context['XWARE'] == "SW")%}acts::{%endif%}getAddr(batch_type addr){
	#pragma HLS INLINE
	return addr;
}
batch_type {%if(context['XWARE'] == "SW")%}acts::{%endif%}getstatsAddr(batch_type addr){
	#pragma HLS INLINE
	return BASEOFFSET_STATSDRAM + addr;
}
batch_type {%if(context['XWARE'] == "SW")%}acts::{%endif%}getmessagesAddr(batch_type addr){
	#pragma HLS INLINE
	return BASEOFFSET_MESSAGESDRAM + addr;
}
unsigned int {%if(context['XWARE'] == "SW")%}acts::{%endif%}getsourceskipsize(unsigned int currentLOP, unsigned int param){
	#pragma HLS INLINE
	unsigned int treedepth = TREE_DEPTH; // NB: for debugging purposes only
	unsigned int result = param;
	for(unsigned int i=0; i<(currentLOP-1); i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=treedepth avg=treedepth
		result = result / NUM_PARTITIONS;
	}
	return result;
}
unsigned int {%if(context['XWARE'] == "SW")%}acts::{%endif%}getdestskipsize(unsigned int currentLOP, unsigned int param){
	#pragma HLS INLINE
	unsigned int treedepthloop_tripcount = TREE_DEPTH; // NB: for debugging purposes only
	unsigned int result = param / NUM_PARTITIONS;
	for(unsigned int i=0; i<(currentLOP-1); i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=treedepthloop_tripcount avg=treedepthloop_tripcount
		result = result / NUM_PARTITIONS;
	}
	return result;
}
unsigned int {%if(context['XWARE'] == "SW")%}acts::{%endif%}get_num_source_partitions(unsigned int currentLOP){
	#pragma HLS INLINE
	unsigned int treedepth = TREE_DEPTH;
	unsigned int pow = 1;
	for(unsigned int i=0; i<(currentLOP-1); i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=treedepth avg=treedepth
		pow = pow * NUM_PARTITIONS;
	}
	return pow;
}

void {%if(context['XWARE'] == "SW")%}acts::{%endif%}calculateoffsets(keyvalue_t capsule[NUM_PARTITIONS]){
	#pragma HLS INLINE
	capsule[0].key = 0;
	PREPARECAPSULE_LOOP1: for (partition_type p = 1; p<NUM_PARTITIONS; p++){ capsule[p].key = capsule[p-1].key + capsule[p-1].value; }
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}calculateoffsets({%for v in context['VECTOR_SIZE_seq']%}keyvalue_t * capsule{{v}},{%endfor%} int size){
	#pragma HLS INLINE
	{%for v in context['VECTOR_SIZE_seq']%}
	capsule{{v}}[0].key = 0;
	{%endfor%}
	PREPARECAPSULE_LOOP1: for (partition_type p = 1; p<NUM_PARTITIONS; p++){
		{%for v in context['VECTOR_SIZE_seq']%}
		capsule{{v}}[p].key = capsule{{v}}[p-1].key + capsule{{v}}[p-1].value;
		{%endfor%}
	}
	#ifdef _DEBUGMODE_CHECKS2
	{%for v in context['VECTOR_SIZE_seq']%}
	checkoutofbounds("acts::calculateoffsets 34", capsule{{v}}[NUM_PARTITIONS-1].key + capsule{{v}}[NUM_PARTITIONS-1].value, (SRCBUFFER_SIZE * VECTOR_SIZE) + 1, capsule{{v}}[NUM_PARTITIONS-1].key, capsule{{v}}[NUM_PARTITIONS-1].value, PADDEDDESTBUFFER_SIZE);
	{%endfor%}
	#endif
	return;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}calculateoffsets(keyvalue_t capsule[NUM_PARTITIONS], unsigned int offset){
	#pragma HLS INLINE
	capsule[0].key = 0;
	PREPARECAPSULE_LOOP1: for (partition_type p = 1; p<NUM_PARTITIONS; p++){ capsule[p].key = capsule[p-1].key + capsule[p-1].value; }
	PREPARECAPSULE_LOOP2: for (partition_type p = 0; p<NUM_PARTITIONS; p++){ capsule[p].key += offset; }
	return;
}

void {%if(context['XWARE'] == "SW")%}acts::{%endif%}loadclopparams(globalparams_t globalparams, clopparams_t * llopparams, unsigned int currentLOP){
	#pragma HLS INLINE
	// if((currentLOP % 2) == 1){ llopparams->baseaddr_worksourcekvs_kvs = BASEOFFSET_KVDRAM_KVS; llopparams->baseaddr_workdestkvs_kvs = BASEOFFSET_KVDRAMWORKSPACE_KVS; }
	// else { llopparams->baseaddr_worksourcekvs_kvs = BASEOFFSET_KVDRAMWORKSPACE_KVS; llopparams->baseaddr_workdestkvs_kvs = BASEOFFSET_KVDRAM_KVS; }	
	llopparams->baseaddr_worksourcekvs_kvs = BASEOFFSET_KVDRAM_KVS; llopparams->baseaddr_workdestkvs_kvs = BASEOFFSET_KVDRAM_KVS; 
	llopparams->baseaddr_capsule_kvs = BASEOFFSET_CAPSULES_KVS;
	llopparams->baseaddr_stats = BASEOFFSET_STATSDRAM;
	llopparams->num_source_partitions = get_num_source_partitions(currentLOP);
	llopparams->nextsourceoffset_partition = 0;
	llopparams->nextdestoffset_partition = 0;
	llopparams->nextsourceoffset_kv = 0;
	llopparams->nextdestoffset_kv = 0;
	llopparams->sourceskipsize_partition = getsourceskipsize(currentLOP, globalparams.LLOPnumpartitions);
	llopparams->destskipsize_partition = getdestskipsize(currentLOP, globalparams.LLOPnumpartitions);
	llopparams->sourceskipsize_kv = getsourceskipsize(currentLOP, KVDATA_RANGE_PERSSDPARTITION);
	llopparams->destskipsize_kv = getdestskipsize(currentLOP, KVDATA_RANGE_PERSSDPARTITION);
	llopparams->destpartitionrange = (1 << (KVDATA_RANGE_PERSSDPARTITION_POW - (NUM_PARTITIONS_POW * currentLOP)));
	llopparams->currentLOP = currentLOP;
	llopparams->upperlimit = 0;
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	print1("loadclopparams:: llopparams->baseaddr_worksourcekvs_kvs", llopparams->baseaddr_worksourcekvs_kvs);
	print1("loadclopparams:: llopparams->baseaddr_workdestkvs_kvs", llopparams->baseaddr_workdestkvs_kvs);
	print1("loadclopparams:: llopparams->baseaddr_capsule_kvs", llopparams->baseaddr_capsule_kvs);
	print1("loadclopparams:: llopparams->baseaddr_stats", llopparams->baseaddr_stats);
	print1("loadclopparams:: llopparams->num_source_partitions", llopparams->num_source_partitions);
	print1("loadclopparams:: llopparams->nextsourceoffset_partition", llopparams->nextsourceoffset_partition);
	print1("loadclopparams:: llopparams->nextdestoffset_partition", llopparams->nextdestoffset_partition);
	print1("loadclopparams:: llopparams->nextsourceoffset_kv", llopparams->nextsourceoffset_kv);
	print1("loadclopparams:: llopparams->nextdestoffset_kv", llopparams->nextdestoffset_kv);
	print1("loadclopparams:: llopparams->sourceskipsize_partition", llopparams->sourceskipsize_partition);
	print1("loadclopparams:: llopparams->destskipsize_partition", llopparams->destskipsize_partition);
	print1("loadclopparams:: llopparams->sourceskipsize_kv", llopparams->sourceskipsize_kv);
	print1("loadclopparams:: llopparams->destskipsize_kv", llopparams->destskipsize_kv);
	print1("loadclopparams:: llopparams->destpartitionrange", llopparams->destpartitionrange);
	print1("loadclopparams:: llopparams->currentLOP", llopparams->currentLOP);
	print1("loadclopparams:: llopparams->upperlimit", llopparams->upperlimit);
	#endif
	return;
}
value_t {%if(context['XWARE'] == "SW")%}acts::{%endif%}reducefunc(keyy_t vid, value_t value, value_t edgeval, unsigned int GraphIter){
	#pragma HLS INLINE
	value_t ret = 0;
	#ifdef PR_ALGORITHM
	ret = value + edgeval;
	#elif defined(BFS_ALGORITHM)
	ret = min(value, GraphIter);
	#elif defined(BC_ALGORITHM)
	ret = min(value, GraphIter);
	#endif
	return ret;
}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}getchunksize(buffer_type * chunk_size, buffer_type buffer_size, travstate_t travstate, unsigned int localoffset_kvs){
	#pragma HLS INLINE
	*chunk_size = buffer_size;
	batch_type i = travstate.i_kvs + localoffset_kvs;
	if (i > travstate.end_kvs){ *chunk_size = 0; }
	else if ((i + buffer_size) > travstate.end_kvs){ *chunk_size = travstate.end_kvs - i; }
	else {}
	checkandforce(*chunk_size, buffer_size + 1, chunk_size, 0);
	checkandforce(i + *chunk_size, PADDEDKVSOURCEDRAMSZ_KVS, chunk_size, 0);
	checkandforce(i + *chunk_size, PADDEDKVSOURCEDRAMSZ_KVS, &i, 0);
	#ifdef _DEBUGMODE_CHECKS2
	checkoutofbounds("getchunksize 35", *chunk_size, buffer_size + 1, *chunk_size, buffer_size, NAp);
	checkoutofbounds("getchunksize 36", i + *chunk_size, PADDEDKVSOURCEDRAMSZ_KVS + 1, i, *chunk_size, PADDEDKVSOURCEDRAMSZ_KVS);
	#endif
	return;
}
int {%if(context['XWARE'] == "SW")%}acts::{%endif%}IsReducePhase(unsigned int currentLOP, unsigned int treedepth, globalparams_t globalparams){
	if((currentLOP == (treedepth + 1)) && (globalparams.reducecommand == ON)){ return 1; }
	return 0;
}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['NUMWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}readkeyvalues{{ddrs}}{{w}}(unsigned int workerID, uint512_dt * kvdram {%for v in context['VECTOR_SIZE_seq']%} ,keyvalue_t * buffer{{v}}{%endfor%} ,keyvalue_t* constrainer, batch_type baseaddress, batch_type offset_kvs, buffer_type size_kvs, batch_type maxaddress_kvs){			
	unsigned int analysis_buffersz = SRCBUFFER_SIZE;
	
	#ifdef _DEBUGMODE_CHECKS2
	checkoutofbounds("acts::readkeyvalues dram 36", baseaddress + offset_kvs + size_kvs, maxaddress_kvs, baseaddress, offset_kvs, size_kvs);
	#endif
	READBUFFER_LOOP1: for (buffer_type i=0; i<size_kvs; i++){
	#pragma HLS PIPELINE II=1
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_buffersz avg=analysis_buffersz
		{%for v in context['VECTOR_SIZE_seq']%}
		#ifdef _WIDEWORD
		buffer{{v}}[i].key = kvdram[baseaddress + offset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}});
		buffer{{v}}[i].value = kvdram[baseaddress + offset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}});
		#else 
		buffer{{v}}[i] = kvdram[baseaddress + offset_kvs + i].data[{{v}}];
		#endif 
		{%endfor%}
			
		#ifdef _DEBUGMODE_STATS
		globalstats_countkvsread(VECTOR_SIZE);
		#endif
	}
	#ifdef ADDCONSTRAINER
	constrainer[size_kvs] = buffer0[size_kvs]; // REMOVEME.
	#endif 
	return;
}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['NUMWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}extractcapsules{{ddrs}}{{w}}(unsigned int workerID {%for v in context['VECTOR_SIZE_seq']%}, keyvalue_t * sourcebuffer{{v}}{%endfor%} {%for v in context['VECTOR_SIZE_seq']%}, keyvalue_t * destbuffer{{v}}{%endfor%} {%for v in context['VECTOR_SIZE_seq']%}, keyvalue_t * capsule{{v}}{%endfor%}, clopparams_t llopparams, travstate_t travstate){
	
	{%for v in context['VECTOR_SIZE_seq']%}
	keyvalue_t sizes{{v}}[NUM_PARTITIONS];
	#pragma HLS ARRAY_PARTITION variable=sizes{{v}} complete
	{%endfor%}
	
	for(partition_type p=0; p<NUM_PARTITIONS; p++){ {%for v in context['VECTOR_SIZE_seq']%} sizes{{v}}[p].key = 0; sizes{{v}}[p].value = 0; {%endfor%} }
	EXTRACTCAPSULES{{ddrs}}_MAINLOOP: for(buffer_type i=0; i<SRCBUFFER_SIZE; i++){
	#pragma HLS PIPELINE II=1
		{%for v in context['VECTOR_SIZE_seq']%}
			keyvalue_t keyvalue{{v}} = sourcebuffer{{v}}[i];
		{%endfor%}
		
		{%for v in context['VECTOR_SIZE_seq']%}
			partition_type p{{v}} = getpartition(keyvalue{{v}}, llopparams.currentLOP, llopparams.upperlimit);
		{%endfor%}
		
		{%for v in context['VECTOR_SIZE_seq']%}
			sizes{{v}}[p{{v}}].value += 1;
		{%endfor%}
		
		{%for v in context['VECTOR_SIZE_seq']%}
			destbuffer{{v}}[i] = sourcebuffer{{v}}[i];
		{%endfor%}
		
		#ifdef _DEBUGMODE_STATS
		globalvar_countkvsread4statscollection(VECTOR_SIZE);
		#endif
	}
	for(partition_type p=0; p<NUM_PARTITIONS; p++){ {%for v in context['VECTOR_SIZE_seq']%} capsule{{v}}[p] = sizes{{v}}[p]; {%endfor%} }
	return;
}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['NUMWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}partition{{ddrs}}{{w}}(unsigned int workerID {%for v in context['VECTOR_SIZE_seq']%}, keyvalue_t * sourcebuffer{{v}}{%endfor%} {%for v in context['VECTOR_SIZE_seq']%}, keyvalue_t * destbuffer{{v}}{%endfor%} {%for v in context['VECTOR_SIZE_seq']%}, keyvalue_t * capsule{{v}}{%endfor%}, travstate_t travstate, clopparams_t llopparams){					
	unsigned int analysis_partition = SRCBUFFER_SIZE;
	
	{%for v in context['VECTOR_SIZE_seq']%}
	keyvalue_t sizes{{v}}[NUM_PARTITIONS];
	#pragma HLS ARRAY_PARTITION variable=sizes{{v}} complete 
	{%endfor%}
	
	for(partition_type p=0; p<NUM_PARTITIONS; p++){ {%for v in context['VECTOR_SIZE_seq']%} sizes{{v}}[p] = capsule{{v}}[p]; {%endfor%} }
	PARTITION_MAINLOOP: for(buffer_type i=0; i<SRCBUFFER_SIZE; i++){
	#pragma HLS PIPELINE II=1
		{%for v in context['VECTOR_SIZE_seq']%}
		keyvalue_t keyvalue{{v}} = sourcebuffer{{v}}[i];
		{%endfor%}

		{%for v in context['VECTOR_SIZE_seq']%}
		partition_type p{{v}} = getpartition(keyvalue{{v}}, llopparams.currentLOP, llopparams.upperlimit);
		{%endfor%}
		
		#ifdef _DEBUGMODE_CHECKS2
		{%for v in context['VECTOR_SIZE_seq']%}
		checkoutofbounds("enigma::partition{{ddrs}}{{v}} 34", sizes{{v}}[p{{v}}].key + sizes{{v}}[p{{v}}].value, PADDEDDESTBUFFER_SIZE, sizes{{v}}[p{{v}}].key, sizes{{v}}[p{{v}}].value, NAp);
		{%endfor%}
		#endif
		{%for v in context['VECTOR_SIZE_seq']%}
		destbuffer{{v}}[sizes{{v}}[p{{v}}].key + sizes{{v}}[p{{v}}].value] = keyvalue{{v}};
		{%endfor%}
		
		{%for v in context['VECTOR_SIZE_seq']%}
		sizes{{v}}[p{{v}}].value += 1;
		{%endfor%}
		
		#ifdef _DEBUGMODE_STATS
		globalstats_countkvspartitioned(VECTOR_SIZE);
		#endif
	}
	for(partition_type p=0; p<NUM_PARTITIONS; p++){ {%for v in context['VECTOR_SIZE_seq']%} capsule{{v}}[p] = sizes{{v}}[p]; {%endfor%} }
	return;
}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['NUMWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}combine{{ddrs}}{{w}}(unsigned int workerID {%for v in context['VECTOR_SIZE_seq']%}, keyvalue_t * sourcebuffer{{v}}{%endfor%} {%for v in context['VECTOR_SIZE_seq']%}, keyvalue_t * destbuffer{{v}}{%endfor%} ,keyvalue_t * capsule, travstate_t travstate, clopparams_t llopparams){					
	unsigned int analysis_partition = SRCBUFFER_SIZE;
	
	uint512_dt Vtemp[VECTOR_SIZE];
	#pragma HLS ARRAY_PARTITION variable=Vtemp complete
	
	/** COMBINE_MAINLOOP1: for(buffer_type i=0; i<SRCBUFFER_SIZE; i+=VECTOR_SIZE){
	#pragma HLS PIPELINE II=1
		COMBINE_MAINLOOP1B: for(buffer_type k = 0; k < VECTOR_SIZE; k++){
		#pragma HLS UNROLL
			#ifdef _WIDEWORD
			{%for vec in context['VECTOR_SIZE_seq']%}
			Vtemp[{{vec}}].range(32 * ((k * 2) + 1) - 1, (k * 2) * 32) = sourcebuffer{{vec}}[i+k].key;
			Vtemp[{{vec}}].range(32 * (((k * 2) + 1) + 1) - 1, (k * 2 + 1) * 32) = sourcebuffer{{vec}}[i+k].value;
			{%endfor%}
			#else 
			{%for vec in context['VECTOR_SIZE_seq']%}
			Vtemp[{{vec}}].data[k] = sourcebuffer{{vec}}[i+k];
			{%endfor%}
			#endif
		}
		COMBINE_MAINLOOP1C: for(buffer_type vec=0; vec<VECTOR_SIZE; vec++){
		#pragma HLS PIPELINE II=1
			#ifdef _WIDEWORD
			{%for v in context['VECTOR_SIZE_seq']%}
			destbuffer{{v}}[i+vec].key = Vtemp[vec].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}});
			destbuffer{{v}}[i+vec].value = Vtemp[vec].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}});
			{%endfor%}
			#else
			{%for v in context['VECTOR_SIZE_seq']%}
			destbuffer{{v}}[i+vec] = Vtemp[vec].data[{{v}}];
			{%endfor%}
			#endif 
		}
		#ifdef _DEBUGMODE_STATS
		globalstats_countkvscombined(VECTOR_SIZE * VECTOR_SIZE);
		#endif
	} */
	COMBINE_MAINLOOP1: for(buffer_type i=0; i<SRCBUFFER_SIZE; i++){
	// COMBINE_MAINLOOP1: for(buffer_type i=0; i<2048; i++){
	#pragma HLS PIPELINE II=1
		{%for v in context['VECTOR_SIZE_seq']%}
		destbuffer{{v}}[i] = sourcebuffer{{v}}[i];
		{%endfor%}
		
		#ifdef _DEBUGMODE_STATS
		globalstats_countkvscombined(VECTOR_SIZE);
		#endif
	}
	return;
}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['NUMWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}savepartitions{{ddrs}}{{w}}(unsigned int workerID, uint512_dt * kvdram {%for v in context['VECTOR_SIZE_seq']%}, keyvalue_t * buffer{{v}}{%endfor%} ,keyvalue_t * capsule ,keyvalue_t * kvdeststats_tmp, keyvalue_t* constrainer, batch_type kvdrambaseaddress){				
	int analysis_savebuffer = PADDEDBUFFER_SIZE / NUM_PARTITIONS;
	
	buffer_type size_kvs; // REMOVEME.
	SAVEPARTITIONS_MAINLOOP1A: for(partition_type p=0; p<NUM_PARTITIONS; p++){
		batch_type dramoffset_kvs = kvdrambaseaddress + ((kvdeststats_tmp[p].key + kvdeststats_tmp[p].value) / VECTOR_SIZE);
		buffer_type bramoffset_kvs = capsule[p].key / VECTOR_SIZE;
		#ifdef FPGA_IMPL
		 size_kvs = PADDEDDESTBUFFER_SIZE / NUM_PARTITIONS;
		#else 
		/// buffer_type size_kvs = capsule[p].value / VECTOR_SIZE;
		 size_kvs = PADDEDDESTBUFFER_SIZE / NUM_PARTITIONS;
		#endif
		#ifdef _DEBUGMODE_CHECKS2
		checkoutofbounds("acts::savepartitions dram 34", dramoffset_kvs + size_kvs, PADDEDKVSOURCEDRAMSZ_KVS, dramoffset_kvs, size_kvs, size_kvs);
		checkoutofbounds("acts::savepartitions bram 35", bramoffset_kvs + size_kvs, PADDEDBUFFER_SIZE, bramoffset_kvs, capsule[p].key, size_kvs);
		#endif

		SAVEPARTITIONS_MAINLOOP1B: for(buffer_type i=0; i<size_kvs; i++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_savebuffer avg=analysis_savebuffer
		#pragma HLS PIPELINE II=1
			#ifdef _WIDEWORD
			{%for v in context['VECTOR_SIZE_seq']%}
			kvdram[dramoffset_kvs + i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = buffer{{v}}[bramoffset_kvs + i].key;
			kvdram[dramoffset_kvs + i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = buffer{{v}}[bramoffset_kvs + i].value;
			{%endfor%}
			#else
			{%for v in context['VECTOR_SIZE_seq']%}
			kvdram[dramoffset_kvs + i].data[{{v}}] = buffer{{v}}[bramoffset_kvs + i];
			{%endfor%}
			#endif 
			
			#ifdef _DEBUGMODE_STATS
			globalstats_countkvspartitionswritten(VECTOR_SIZE);
			#endif
		}
	}
	UPDATEGLOBALSTATS_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){ kvdeststats_tmp[p].value += capsule[p].value; }
	#ifdef ADDCONSTRAINER
	constrainer[size_kvs] = buffer0[size_kvs]; // REMOVEME.
	#endif 
	return;
}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}storedeststats{{ddrs}}(keyvalue_t * kvstats, keyvalue_t buffer[NUM_PARTITIONS], unsigned int drambaseoffset, unsigned int dramloffset){
	#pragma HLS INLINE
	batch_type offset = drambaseoffset + dramloffset;
	
	STOREDESTSTATS_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE
		kvstats[getstatsAddr(offset + p)] = buffer[p];
	}
	return;
}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}partitionandreduce{{ddrs}}(uint512_dt * kvsource1dram, uint512_dt * kvsource2dram, uint512_dt * kvdestdram, keyvalue_t * kvstats, globalparams_t globalparams){
	int analysis_maxtreedepthsz = 1;
	int analysis_avgnumsourcepartitions = 1;
	int analysis_partitionphase = KVDRAMSZ_KVS / (NUMWORKERS * NUMSUBWORKERS * SRCBUFFER_SIZE);
	int analysis_reducephase = 1;
	int analysis_chunksize = SRCBUFFER_SIZE;
	int analysis_iterationcount = KVDATA_BATCHSIZE_KVS / SRCBUFFER_SIZE;
	
	{%for w in context['NUMWORKERS_seq']%}
	{%for v in context['VECTOR_SIZE_seq']%}
	keyvalue_t sourcebuffer{{w}}{{v}}[SRCBUFFER_SIZE];
	{%endfor%}
	{%for v in context['VECTOR_SIZE_seq']%}
	keyvalue_t interbuffer1{{w}}{{v}}[PADDEDDESTBUFFER_SIZE];
	{%endfor%}
	{%for v in context['VECTOR_SIZE_seq']%}
	keyvalue_t interbuffer2{{w}}{{v}}[PADDEDDESTBUFFER_SIZE];
	{%endfor%}
	{%for v in context['VECTOR_SIZE_seq']%}
	keyvalue_t destbuffer{{w}}{{v}}[PADDEDDESTBUFFER_SIZE];
	{%endfor%}
	{%for v in context['VECTOR_SIZE_seq']%}
	keyvalue_t minicapsule{{w}}{{v}}[NUM_PARTITIONS];
	{%endfor%}
	keyvalue_t capsule{{w}}[NUM_PARTITIONS];
	{%endfor%}
	
	keyvalue_t constrainer[NUM_PARTITIONS]; // REMOVEME
	
	{%for w in context['NUMWORKERS_seq']%}
	{%for v in context['VECTOR_SIZE_seq']%}
	reset(minicapsule{{w}}{{v}}, NUM_PARTITIONS);
	{%endfor%}
	reset(capsule{{w}}{{v}}, NUM_PARTITIONS);
	{%endfor%}
	
	unsigned int numLOPs = 0;
	if(globalparams.runkernelcommand == ON){
		if(globalparams.reducecommand == ON){ numLOPs = globalparams.treedepth + 1 + 1; }
		else { numLOPs = globalparams.treedepth + 1; }
	} else { numLOPs = 1; }
	unsigned int loadkvdramsize_kvs = 0;
	if(globalparams.runkernelcommand == ON){ loadkvdramsize_kvs = 0; }
	else { loadkvdramsize_kvs = KVDATA_BATCHSIZE_KVS; }
	unsigned int sourcestatsmarker = 0;
	unsigned int deststatsmarker = 1;
	
	// Partition Phase
	PARTITIONANDREDUCE_LOOP1: for(unsigned int currentLOP=1; currentLOP<numLOPs; currentLOP++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_maxtreedepthsz avg=analysis_maxtreedepthsz
		keyvalue_t kvdeststats_tmp[NUM_PARTITIONS];
		keyvalue_t kvdeststats_tmp2[NUM_PARTITIONS];
		
		clopparams_t llopparams;
		loadclopparams(globalparams, &llopparams, currentLOP);
		unsigned int num_source_partition_skipsize = 0;
		if(IsReducePhase(currentLOP, globalparams.treedepth, globalparams) == 1){ num_source_partition_skipsize = NUMSUBWORKERS; }
		else { num_source_partition_skipsize = 1; }
		#ifdef _DEBUGMODE_KERNELPRINTS2
		cout<<endl;
		print4("PartitionPhase{{ddrs}}:: num_source_partitions", "num_destpartitions", "sourceskipsize_kv", "NAp", llopparams.num_source_partitions, llopparams.num_source_partitions * NUM_PARTITIONS, llopparams.sourceskipsize_kv, NAp);
		#endif
		
		PARTITIONANDREDUCE_LOOP2: for(unsigned int source_partition=0; source_partition<llopparams.num_source_partitions; source_partition+=num_source_partition_skipsize){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_avgnumsourcepartitions avg=analysis_avgnumsourcepartitions
		
			partitionparams_t partitionparams;
			travstate_t travstate;
			travstate_t travstates[NUMSUBWORKERS];
			travoffsets_t travoffsets;
			#ifdef _DEBUGMODE_CHECKSM
			initializeDebuggers();
			#endif
			
			#ifdef _DEBUGMODE_CHECKS2
			checkoutofbounds("acts::partitionandreduce{{ddrs}} 22", getstatsAddr(sourcestatsmarker), KVSTATSDRAMSZ, NAp, NAp, NAp);
			#endif
			llopparams.upperlimit = globalparams.vbegin + llopparams.nextsourceoffset_kv;
			keyvalue_t sourcestat = kvstats[getstatsAddr(sourcestatsmarker)];
			partitionparams.begin_kvs = sourcestat.key / VECTOR_SIZE;
			partitionparams.size_kvs = (sourcestat.value + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
			partitionparams.step_kvs = NUMWORKERS * NUMSUBWORKERS * SRCBUFFER_SIZE;
			partitionparams.end_kvs = partitionparams.begin_kvs + partitionparams.size_kvs;
			if(IsReducePhase(currentLOP, globalparams.treedepth, globalparams) == 1){ partitionparams.begin_kvs = 0; partitionparams.size_kvs = 0; partitionparams.step_kvs = 0; partitionparams.end_kvs = 0; }
			travstate.begin_kvs = partitionparams.begin_kvs;
			travstate.end_kvs = partitionparams.end_kvs;
			travstate.skip_kvs = partitionparams.step_kvs;
			#ifdef _DEBUGMODE_KERNELPRINTS2
			if(IsReducePhase(currentLOP, globalparams.treedepth, globalparams) == 1){ print6("ReducePhase{{ddrs}}:: begin", "size", "step", "currentLOP", "range_per_destpartition", "source_partition", sourcestat.key, sourcestat.value, NUMSUBWORKERS * SRCBUFFER_SIZE * VECTOR_SIZE, llopparams.currentLOP, KVDATA_RANGE_PERSSDPARTITION / pow(NUM_PARTITIONS, llopparams.currentLOP), source_partition); } 
			else { print6("PartitionPhase{{ddrs}}:: begin", "size", "step", "currentLOP", "range_per_destpartition", "source_partition", sourcestat.key, sourcestat.value, NUMSUBWORKERS * SRCBUFFER_SIZE * VECTOR_SIZE, llopparams.currentLOP, KVDATA_RANGE_PERSSDPARTITION / pow(NUM_PARTITIONS, llopparams.currentLOP), source_partition); }
			#endif
			reset(kvdeststats_tmp, NUM_PARTITIONS);
			reset(kvdeststats_tmp2, NUM_PARTITIONS);
			
			// Partition phase
			PARTITIONPHASE_MAINLOOP1: for (int i = partitionparams.begin_kvs; i < partitionparams.end_kvs; i += partitionparams.step_kvs){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_partitionphase avg=analysis_partitionphase
				#ifdef _DEBUGMODE_KERNELPRINTS2
				print4("PartitionPhase{{ddrs}}:: i", "i_end", "step size", "NAp", i, partitionparams.end_kvs, partitionparams.step_kvs, NAp);
				#endif
				
				{%for sw in context['NUMSUBWORKERS_seq']%}
				{%for w in context['NUMWORKERS_seq']%}
				readkeyvalues{{ddrs}}{{w}}({{w}}, kvsource1dram {%for v in context['VECTOR_SIZE_seq']%} ,sourcebuffer{{w}}{{v}}{%endfor%} ,constrainer, llopparams.baseaddr_worksourcekvs_kvs, 0 + {{sw}} * SRCBUFFER_SIZE, SRCBUFFER_SIZE, PADDEDKVSOURCEDRAMSZ_KVS);
				{%endfor%}
				
				{%for w in context['NUMWORKERS_seq']%}
				extractcapsules{{ddrs}}{{w}}({{w}} {%for v in context['VECTOR_SIZE_seq']%} ,sourcebuffer{{w}}{{v}}{%endfor%} {%for v in context['VECTOR_SIZE_seq']%} ,interbuffer1{{w}}{{v}}{%endfor%} {%for v in context['VECTOR_SIZE_seq']%} ,minicapsule{{w}}{{v}}{%endfor%} ,llopparams, travstate);
				{%endfor%}
				
				{%for w in context['NUMWORKERS_seq']%}
				partition{{ddrs}}{{w}}({{w}} {%for v in context['VECTOR_SIZE_seq']%} ,interbuffer1{{w}}{{v}}{%endfor%} {%for v in context['VECTOR_SIZE_seq']%} ,interbuffer2{{w}}{{v}}{%endfor%} {%for v in context['VECTOR_SIZE_seq']%}, minicapsule{{w}}{{v}}{%endfor%} ,travstate, llopparams);
				{%endfor%}
				
				{%for w in context['NUMWORKERS_seq']%}
				combine{{ddrs}}{{w}}({{w}} {%for v in context['VECTOR_SIZE_seq']%} ,interbuffer2{{w}}{{v}}{%endfor%} {%for v in context['VECTOR_SIZE_seq']%} ,destbuffer{{w}}{{v}}{%endfor%} ,capsule{{w}}, travstate, llopparams);
				{%endfor%}
				
				{%for w in context['NUMWORKERS_seq']%}
				savepartitions{{ddrs}}{{w}}({{w}}, kvsource2dram {%for v in context['VECTOR_SIZE_seq']%} ,destbuffer{{w}}{{v}}{%endfor%} ,capsule{{w}}, kvdeststats_tmp, constrainer, llopparams.baseaddr_workdestkvs_kvs);
				{%endfor%}
				{%endfor%}
			}
		
			if(IsReducePhase(currentLOP, globalparams.treedepth, globalparams) == 0){ storedeststats{{ddrs}}(kvstats, kvdeststats_tmp, 0, deststatsmarker); deststatsmarker += NUM_PARTITIONS; }
			if(IsReducePhase(currentLOP, globalparams.treedepth, globalparams) == 1){ sourcestatsmarker += NUMSUBWORKERS; }
			else { sourcestatsmarker += 1; }
			
			if(IsReducePhase(currentLOP, globalparams.treedepth, globalparams) == 1){ llopparams.nextsourceoffset_kv += llopparams.sourceskipsize_kv * NUMSUBWORKERS; } 
			else { llopparams.nextsourceoffset_kv += llopparams.sourceskipsize_kv; }
		}
		#ifdef _DEBUGMODE_KERNELPRINTS2
		printglobalvars();
		clearglobalvars();
		#endif
	}
	return;
}
{%endfor%}

extern "C" {
void {%if(context['XWARE'] == "SW")%}acts::{%endif%}topkernel(
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		{%if(ddrs==0)%}{%else%},{%endif%}uint512_dt * kvsourcedram{{ddrs_}}
		{%endfor%}
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		,uint512_dt * kvdestdram{{ddrs_}}
		{%endfor%}
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		,keyvalue_t * kvstats{{ddrs_}}
		{%endfor%}
        ){
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE m_axi port=kvsourcedram{{ddrs_}} offset=slave bundle=gmem{{ddrs}} max_read_burst_length=64 max_write_burst_length=64
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE m_axi port=kvdestdram{{ddrs_}} offset=slave bundle=gmem{{context['NUMINSTANCES'] + ddrs}} max_read_burst_length=64 max_write_burst_length=64
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE m_axi port=kvstats{{ddrs_}} offset=slave bundle=gmem{{context['NUMINSTANCES'] + context['NUMINSTANCES'] + ddrs}}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE s_axilite port=kvsourcedram{{ddrs_}}  bundle=control
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE s_axilite port=kvdestdram{{ddrs_}}  bundle=control
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE s_axilite port=kvstats{{ddrs_}}  bundle=control
{%endfor%}

#pragma HLS INTERFACE s_axilite port=return bundle=control

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS DATA_PACK variable=kvstats{{ddrs_}}
{%endfor%}
	
	globalparams_t globalparams;
	globalparams.runkernelcommand = kvstatsA[getmessagesAddr(MESSAGES_RUNKERNELCOMMANDID)].key;
	globalparams.processcommand = kvstatsA[getmessagesAddr(MESSAGES_PROCESSCOMMANDID)].key;
	globalparams.partitioncommand = kvstatsA[getmessagesAddr(MESSAGES_PARTITIONCOMMANDID)].key;
	globalparams.reducecommand = kvstatsA[getmessagesAddr(MESSAGES_APPLYUPDATESCOMMANDID)].key;
	globalparams.vbegin = kvstatsA[getmessagesAddr(MESSAGES_VOFFSET)].key; 
	globalparams.vsize = kvstatsA[getmessagesAddr(MESSAGES_VSIZE)].key; 
	globalparams.treedepth = kvstatsA[getmessagesAddr(MESSAGES_TREEDEPTH)].key; 
	globalparams.LLOPnumpartitions = kvstatsA[getmessagesAddr(MESSAGES_FINALNUMPARTITIONS)].key;
	globalparams.GraphIter = kvstatsA[getmessagesAddr(MESSAGES_GRAPHITERATIONID)].key;
	globalparams.IterCount = kvstatsA[getmessagesAddr(MESSAGES_ITERATIONID)].key;
	globalparams.baseaddr_destkvs_kvs = 0;
	
	#ifdef _DEBUGMODE_KERNELPRINTS2
	std::cout<<std::endl;
	std::cout<<"Kernel Started: globalparams.runkernelcommand: "<<globalparams.runkernelcommand<<std::endl;
	std::cout<<"Kernel Started: globalparams.processcommand: "<<globalparams.processcommand<<std::endl;
	std::cout<<"Kernel Started: globalparams.partitioncommand: "<<globalparams.partitioncommand<<std::endl;
	std::cout<<"Kernel Started: globalparams.reducecommand: "<<globalparams.reducecommand<<std::endl;
	std::cout<<"Kernel Started: globalparams.vbegin: "<<globalparams.vbegin<<std::endl;
	std::cout<<"Kernel Started: globalparams.vsize: "<<globalparams.vsize<<std::endl;
	std::cout<<"Kernel Started: globalparams.treedepth: "<<globalparams.treedepth<<std::endl;
	std::cout<<"Kernel Started: globalparams.LLOPnumpartitions: "<<globalparams.LLOPnumpartitions<<std::endl;
	std::cout<<"Kernel Started: globalparams.GraphIter: "<<globalparams.GraphIter<<std::endl;
	std::cout<<"Kernel Started: globalparams.IterCount: "<<globalparams.IterCount<<std::endl;
	std::cout<<"Kernel Started: kvstatsA[BASEOFFSET_STATSDRAM + 0].value: "<<kvstatsA[BASEOFFSET_STATSDRAM + 0].value<<std::endl;
	#endif
	#ifdef _DEBUGMODE_CHECKSM
	createDebuggers();
	initializeDebuggers();
	#endif
	
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	partitionandreduce{{ddrs}}(kvsourcedram{{ddrs_}}, kvdestdram{{ddrs_}}, kvdestdram{{ddrs_}}, kvstats{{ddrs_}}, globalparams);
	{%endfor%}
	return;
}
}






