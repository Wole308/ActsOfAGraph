#include "{{context['PROJECT_BASEPATH']}}/src/common.h"
{%if(context['XWARE'] != "HW")%}
#include <string>
#include <string.h>
#include <iostream>
#include <vector>
#include <string.h>
#include <stdio.h>
#include <ctime>
#include <functional>
#include <sys/time.h>
#include <time.h>
#include <stdlib.h>
#include <iomanip>
#include <cmath>
#include <fstream>
{%endif%}
#include "{{context['PROJECT_BASEPATH']}}/kernels/enigma.h"
using namespace std;

#define DRAMLIMITSZ (1 << 26)
#define DRAMLIMITSZ_KVS (FORCDFINISH_DRAMSZ / VECTOR_SIZE)

#ifndef FPGA_IMPL
enigma::enigma(){}
enigma::~enigma(){}
#endif
#ifndef HW

unsigned int globalvar_totalkvstatsread;
unsigned int globalvar_totalkvsreadV;

unsigned int globalvar_totalkvstatscollected;
unsigned int globalvar_totalkvstatswritten;

unsigned int globalvar_totalkvsread;

unsigned int globalstats_totalkvspartitioned;
unsigned int globalstats_totalkvspartitionswritten;

unsigned int globalstats_totalkvsreduced;
unsigned int globalstats_totalkvsreducewritten;
#endif 
#ifdef _LDEBUGMODE_HEADER
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}checkoutofbounds(string message, unsigned int data, unsigned int upper_bound){
	if(data > upper_bound){ std::cout<<"enigma::checkoutofbounds: ERROR. out of bounds. message: "<<message<<", data: "<<data<<", upper_bound: "<<upper_bound<<std::endl; exit(EXIT_FAILURE); }
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}checkforequal(string message, unsigned int data1, unsigned int data2){
	if(data1 == data2){ cout<<"enigma::checkforequal: ERROR. data1 == data2. message: "<<message<<", data1: "<<data1<<", data2: "<<data2<<endl; exit(EXIT_FAILURE); }
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}print1(string messagea, unsigned int dataa){
	cout<<messagea<<": "<<dataa<<endl;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}print4(string messagea, string messageb, string messagec, string messaged, unsigned int dataa, unsigned int datab, unsigned int datac, unsigned int datad){
	cout<<messagea<<": "<<dataa<<", "<<messageb<<": "<<datab<<", "<<messagec<<": "<<datac<<", "<<messaged<<": "<<datad<<endl;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}print5(string messagea, string messageb, string messagec, string messaged, string messagee, unsigned int dataa, unsigned int datab, unsigned int datac, unsigned int datad, unsigned int datae){
	cout<<messagea<<": "<<dataa<<", "<<messageb<<": "<<datab<<", "<<messagec<<": "<<datac<<", "<<messaged<<": "<<datad<<", "<<messagee<<": "<<datae<<endl;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}print6(string messagea, string messageb, string messagec, string messaged, string messagee, string messagef, unsigned int dataa, unsigned int datab, unsigned int datac, unsigned int datad, unsigned int datae, unsigned int datef){
	cout<<messagea<<": "<<dataa<<", "<<messageb<<": "<<datab<<", "<<messagec<<": "<<datac<<", "<<messaged<<": "<<datad<<", "<<messagee<<": "<<datae<<", "<<messagef<<": "<<datef<<endl;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}printkeyvalues(string message, keyvalue_t * keyvalues, unsigned int size){
	cout<<endl<<"printkeyvalues:"<<message<<endl;
	for(unsigned int p=0; p<size; p++){ cout<<"keyvalues["<<p<<"].key: "<<keyvalues[p].key<<", keyvalues["<<p<<"].value: "<<keyvalues[p].value<<endl; }
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}printkeyvalues(string message, keyvalue_t * keyvalues1, keyvalue_t * keyvalues2, unsigned int size){
	cout<<endl<<"printkeyvalues:"<<message<<endl;
	for(unsigned int p=0; p<size; p++){ cout<<"["<<keyvalues1[p].key<<":"<<keyvalues1[p].value<<"]["<<keyvalues2[p].key<<":"<<keyvalues2[p].value<<"]"<<endl; }
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}printkeyvalues(string message, uint512_dt * keyvalues, unsigned int size_kvs){
	cout<<endl<<"printkeyvalues:"<<message<<endl;
	for(unsigned int i=0; i<size_kvs; i++){ 
		#ifdef _WIDEWORD
		{%for v in context['VECTOR_SIZE_seq']%}
			cout<<"keyvalues["<<i<<"].data[{{v}}].key: "<<(unsigned int)keyvalues[i].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}})<<", keyvalues["<<i<<"].data[{{v}}].value: "<<(unsigned int)keyvalues[i].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}})<<endl;
		{%endfor%}
		#else 
		for(unsigned int v=0; v<VECTOR_SIZE; v++){ cout<<"keyvalues["<<i<<"].data["<<v<<"].key: "<<keyvalues[i].data[v].key<<", keyvalues["<<i<<"].data["<<v<<"].value: "<<keyvalues[i].data[v].value<<endl; }
		#endif 
	}
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}getvaluecount(string message, keyvalue_t * keyvalues, unsigned int size){
	unsigned int totalnumkeyvalues = 0;
	for(unsigned int p=0; p<size; p++){ totalnumkeyvalues += keyvalues[p].value; }
	cout<<"total values counted: "<<totalnumkeyvalues<<endl;
}
void countkeyvalues(){

}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}printparameters(){
	cout<<endl<<"enigma::printparameters: test started."<<endl;
	cout<<"enigma::printparameters:: KVDATA_BATCHSIZE: "<<KVDATA_BATCHSIZE<<endl;
	cout<<"enigma::printparameters:: KVDATA_BATCHSIZE_KVS: "<<KVDATA_BATCHSIZE_KVS<<endl;
	
	cout<<"enigma::printparameters:: BUFFER_SIZE: "<<BUFFER_SIZE<<endl;
	cout<<"enigma::printparameters:: PADDEDBUFFER_SIZE: "<<PADDEDBUFFER_SIZE<<endl;
	
	cout<<"enigma::printparameters:: KVDRAMSZ: "<<KVDRAMSZ<<endl;
	cout<<"enigma::printparameters:: KVDRAMSZ_KVS: "<<KVDRAMSZ_KVS<<endl;
	
	cout<<"enigma::printparameters:: KVSOURCEDRAMSZ: "<<KVSOURCEDRAMSZ<<endl;
	cout<<"enigma::printparameters:: KVSOURCEDRAMSZ_KVS: "<<KVSOURCEDRAMSZ_KVS<<endl;
	
	cout<<"enigma::printparameters:: PADDEDKVSOURCEDRAMSZ: "<<PADDEDKVSOURCEDRAMSZ<<endl;
	cout<<"enigma::printparameters:: PADDEDKVSOURCEDRAMSZ_KVS: "<<PADDEDKVSOURCEDRAMSZ_KVS<<endl;
}
#endif
#ifdef _DEBUGMODE_STATS
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}printglobalvars(){
	cout<<"printglobalvars: "<<endl;
	cout<<"enigma::printglobalvars:: COLLECTSTATS & SPREAD & PARTITION:: globalvar_totalkvsread: "<<globalvar_totalkvsread<<endl;
	cout<<"enigma::printglobalvars:: COLLECTSTATS & SPREAD & PARTITION:: globalvar_totalkvsreadV: "<<globalvar_totalkvsreadV<<endl;
	
	cout<<"enigma::printglobalvars:: COLLECTSTATS:: globalvar_totalkvstatsread: "<<globalvar_totalkvstatsread<<endl;
	cout<<"enigma::printglobalvars:: COLLECTSTATS:: globalvar_totalkvstatscollected: "<<globalvar_totalkvstatscollected<<endl;
	cout<<"enigma::printglobalvars:: COLLECTSTATS:: globalvar_totalkvstatswritten: "<<globalvar_totalkvstatswritten<<endl;	

	cout<<"enigma::printglobalvars:: SPREAD:: globalstats_totalkvspartitioned: "<<globalstats_totalkvspartitioned<<endl;
	cout<<"enigma::printglobalvars:: SPREAD:: globalstats_totalkvspartitionswritten: "<<globalstats_totalkvspartitionswritten<<endl;
	
	cout<<"enigma::printglobalvars:: REDUCE:: globalstats_totalkvsreduced: "<<globalstats_totalkvsreduced<<endl;
	cout<<"enigma::printglobalvars:: REDUCE:: globalstats_totalkvsreducewritten: "<<globalstats_totalkvsreducewritten<<endl;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}clearglobalvars(){
	cout<<"clearglobalvars: "<<endl;
	globalvar_totalkvsread = 0;
	globalstats_totalkvspartitionswritten = 0;
	globalstats_totalkvspartitioned = 0;
	globalvar_totalkvstatsread = 0;
	globalvar_totalkvstatscollected = 0;
	globalvar_totalkvstatswritten = 0;
	globalstats_totalkvsreduced = 0;
	globalstats_totalkvsreducewritten = 0;
	globalvar_totalkvsreadV = 0;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}globalstats_countkvstatsread(unsigned int count){
	globalvar_totalkvstatsread += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}globalstats_countkvstatscollected(unsigned int count){
	globalvar_totalkvstatscollected += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}globalstats_countkvstatswritten(unsigned int count){
	globalvar_totalkvstatswritten += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}globalstats_countkvsread(unsigned int count){
	globalvar_totalkvsread += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}globalstats_countkvspartitionswritten(unsigned int count){
	globalstats_totalkvspartitionswritten += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}globalstats_countkvspartitioned(unsigned int count){
	globalstats_totalkvspartitioned += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}globalstats_countkvsreduced(unsigned int count){
	globalstats_totalkvsreduced += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}globalstats_countkvsreducewritten(unsigned int count){
	globalstats_totalkvsreducewritten += count;
	return;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}globalstats_countkvsreadV(unsigned int count){
	globalvar_totalkvsreadV += count;
	return;
}
#endif 

unsigned int {%if(context['XWARE'] == "SW")%}enigma::{%endif%}allignhigher_KV(unsigned int val){
	unsigned int fac = (val + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
	return (fac * VECTOR_SIZE);
}
unsigned int {%if(context['XWARE'] == "SW")%}enigma::{%endif%}allignlower_KV(unsigned int val){
	unsigned int fac = val / VECTOR_SIZE;
	return (fac * VECTOR_SIZE);
}
unsigned int {%if(context['XWARE'] == "SW")%}enigma::{%endif%}ceildiv(unsigned int val1, unsigned int val2){
	return (val1 + (val2 - 1)) / val2;
}	
unsigned int {%if(context['XWARE'] == "SW")%}enigma::{%endif%}max(unsigned int val1, unsigned int val2){
	if(val1 > val2){ return val1; }
	else { return val2; }
}
unsigned int {%if(context['XWARE'] == "SW")%}enigma::{%endif%}min(unsigned int A, unsigned int B){
	#pragma HLS INLINE
	if(A<B){ return A; }
	else { return B; }
}
unsigned int {%if(context['XWARE'] == "SW")%}enigma::{%endif%}hsub(unsigned int A, unsigned int B){
	#pragma HLS INLINE
	if(A < B){ return 0; }
	else { return A - B; }
}

unsigned int {%if(context['XWARE'] == "SW")%}enigma::{%endif%}getpartition(keyvalue_t keyvalue, unsigned int currentLOP, vertex_t upperlimit){
	// return 0;
	partition_type hashedval = 0;
	hashedval = ((keyvalue.key - upperlimit) >> (KVDATA_RANGE_PERSSDPARTITION_POW - (NUM_PARTITIONS_POW * currentLOP)));
	
	// int KKK = (((1 << NUM_PARTITIONS_POW) - 1) & (hashedval >> (1 - 1)));
	// if(KKK >= NUM_PARTITIONS){ cout<<"--- getpartition: KKK: "<<KKK<<endl; exit(EXIT_FAILURE); }
	
	
	// return (hashedval % NUM_PARTITIONS); // REMOVEME.
	return (((1 << NUM_PARTITIONS_POW) - 1) & (hashedval >> (1 - 1))); // REMOVEME.
	// if(hashedval >= NUM_PARTITIONS){ hashedval = 0; }
	return hashedval;
}
keyvalue_t {%if(context['XWARE'] == "SW")%}enigma::{%endif%}getkeyvalue(uint512_dt buffer[BUFFER_SIZE], batch_type addr, batch_type maxaddr_kvs){
	#pragma HLS INLINE
	keyvalue_t keyvalue;
	batch_type idy = addr / VECTOR_SIZE;
	vector_type idx = addr % VECTOR_SIZE;
	#ifdef _DEBUGMODE_CHECKS2
	if(idy >= maxaddr_kvs){ cout<<"getkeyvalue:: ERROR 45. addr: "<<addr<<", idy: "<<idy<<", idx: "<<idx<<endl; exit(EXIT_FAILURE); }
	checkoutofbounds("enigma::getkeyvalue 35", idy, maxaddr_kvs);
	#endif
	
	#ifdef _WIDEWORD
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else {%endif%}if(idx=={{v}}){	
		keyvalue.key = buffer[idy].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}});
		keyvalue.value = buffer[idy].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}});
	}
	{%endfor%}
	else {
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"getkeyvalue:: out-of-bounds 45. "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	#else
	keyvalue = buffer[idy].data[idx];
	#endif
	return keyvalue;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}setkeyvalue(uint512_dt buffer[BUFFER_SIZE], batch_type addr, keyvalue_t keyvalue, batch_type maxaddr_kvs){
	#pragma HLS INLINE
	batch_type idy = addr / VECTOR_SIZE;
	vector_type idx = addr % VECTOR_SIZE;
	#ifdef _DEBUGMODE_CHECKS2
	checkoutofbounds("enigma::setkeyvalue 35", idy, maxaddr_kvs);
	#endif
	
	#ifdef _WIDEWORD
	{%for v in context['VECTOR_SIZE_seq']%}
	{%if(v>0)%}else {%endif%}if(idx=={{v}}){	
		buffer[idy].range({{32 * ((v * 2) + 1) - 1}}, {{(v * 2) * 32}}) = keyvalue.key;
		buffer[idy].range({{32 * (((v * 2) + 1) + 1) - 1}}, {{(v * 2 + 1) * 32}}) = keyvalue.value;
	}
	{%endfor%}
	else {
		#ifdef _DEBUGMODE_CHECKS2
		std::cout<<"setkventryII:: out-of-bounds 45. "<<std::endl;
		exit(EXIT_FAILURE);
		#endif 
	}
	#else
	buffer[idy].data[idx] = keyvalue;
	#endif
	return;
}

buffer_type {%if(context['XWARE'] == "SW")%}enigma::{%endif%}getactivesize(buffer_type i, batch_type i_end, buffer_type buffersize){	
	#pragma HLS INLINE
	buffer_type activesize = 0;
	buffer_type next_i = i + buffersize;
	if(i >= i_end){ activesize = 0; }
	else if ((i < i_end) && (next_i < i_end)) { activesize = buffersize; }
	else if ((i < i_end) && (next_i >= i_end)) { activesize = i_end - i; }
	else {
		i = 0; 
		#ifdef _DEBUGMODE_CHECKS
		cout<<"getactivesize:: should NEVER get here: activesize: "<<activesize<<", i: "<<i<<", next_i: "<<next_i<<", i_end: "<<i_end<<endl;
		exit(EXIT_FAILURE);
		#endif
	}
	#ifdef _DEBUGMODE_KERNELPRINTS
	print4("getactivesize: i", "i_end", "buffersize", "activesize", i, i_end, buffersize, activesize);
	#endif
	return activesize;
}
batch_type {%if(context['XWARE'] == "SW")%}enigma::{%endif%}getAddr(batch_type addr){
	#pragma HLS INLINE
	return addr;
}
batch_type {%if(context['XWARE'] == "SW")%}enigma::{%endif%}getstatsAddr(batch_type addr){
	#pragma HLS INLINE
	return BASEOFFSET_STATSDRAM + addr;
}
batch_type {%if(context['XWARE'] == "SW")%}enigma::{%endif%}getmessagesAddr(batch_type addr){
	#pragma HLS INLINE
	return BASEOFFSET_MESSAGESDRAM + addr;
}

unsigned int {%if(context['XWARE'] == "SW")%}enigma::{%endif%}getsourceskipsize(unsigned int currentLOP, unsigned int param){
	#pragma HLS INLINE
	unsigned int treedepth = TREE_DEPTH; // NB: for debugging purposes only
	unsigned int result = param;
	for(unsigned int i=0; i<(currentLOP-1); i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=treedepth avg=treedepth
		result = result / NUM_PARTITIONS;
	}
	return result;
}
unsigned int {%if(context['XWARE'] == "SW")%}enigma::{%endif%}getdestskipsize(unsigned int currentLOP, unsigned int param){
	#pragma HLS INLINE
	unsigned int treedepthloop_tripcount = TREE_DEPTH; // NB: for debugging purposes only
	unsigned int result = param / NUM_PARTITIONS;
	for(unsigned int i=0; i<(currentLOP-1); i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=treedepthloop_tripcount avg=treedepthloop_tripcount
		result = result / NUM_PARTITIONS;
	}
	return result;
}

void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}loaddeststats(keyvalue_t * kvstats, keyvalue_t buffer[NUM_PARTITIONS], unsigned int partitionoffset, unsigned int currentLOP, vertex_t LLOPnumpartitions){
	#pragma HLS INLINE
	unsigned int skipsize = getdestskipsize(currentLOP, LLOPnumpartitions);
	unsigned int nxtpos = partitionoffset;
	
	LOADDESTSTATS_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE	
		buffer[p] = kvstats[getstatsAddr(nxtpos)]; 
		nxtpos += skipsize;
	}
	LOADDESTSTATS_LOOP2: for(partition_type p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		buffer[p].value = 0;
	}
	return;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}storedeststats(keyvalue_t * kvstats, keyvalue_t buffer[NUM_PARTITIONS], unsigned int partitionoffset, unsigned int currentLOP, vertex_t LLOPnumpartitions){
	#pragma HLS INLINE
	unsigned int skipsize = getdestskipsize(currentLOP, LLOPnumpartitions);
	unsigned int nxtpos = partitionoffset;
	
	STOREDESTSTATS_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){
	#pragma HLS PIPELINE
		kvstats[getstatsAddr(nxtpos)].value = buffer[p].value; 
		nxtpos += skipsize;
	}
	STOREDESTSTATS_LOOP2: for(partition_type p=0; p<NUM_PARTITIONS; p++){
		#pragma HLS PIPELINE
		buffer[p].value = 0;
	}
	return;
}

unsigned int {%if(context['XWARE'] == "SW")%}enigma::{%endif%}get_num_source_partitions(unsigned int currentLOP){
	#pragma HLS INLINE
	unsigned int treedepth = TREE_DEPTH;
	unsigned int pow = 1;
	for(unsigned int i=0; i<(currentLOP-1); i++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=treedepth avg=treedepth
		pow = pow * NUM_PARTITIONS;
	}
	return pow;
}

void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}prepareoffsets(buffer_type sizes[NUM_PARTITIONS], buffer_type offsets[NUM_PARTITIONS]){
	#pragma HLS INLINE	
	// PREPAREOFFSETS{{v}}_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){ sizes[p] = 0; }
	offsets[0] = 0;
	for (partition_type p = 1; p<NUM_PARTITIONS; p++){ offsets[p] = offsets[p-1] + sizes[p-1]; }
	return;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}preparecapsule(keyvalue_t capsule[NUM_PARTITIONS]){
	#pragma HLS INLINE
	capsule[0].key = 0;
	PREPARECAPSULE_LOOP1: for (partition_type p = 1; p<NUM_PARTITIONS; p++){ capsule[p].key = capsule[p-1].key + capsule[p-1].value; }
	return;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}preparecapsules({%for sw in context['NUMSUBWORKERS_seq']%}{%if(sw>0)%},{%endif%} keyvalue_t capsule{{sw}}[NUM_PARTITIONS]{%endfor%}){
	#pragma HLS INLINE
	{%for sw in context['NUMSUBWORKERS_seq']%}
	capsule{{sw}}[0].key = 0;
	{%endfor%}
	PREPARECAPSULE_LOOP1: for (partition_type p = 1; p<NUM_PARTITIONS; p++){
		{%for sw in context['NUMSUBWORKERS_seq']%}
		capsule{{sw}}[p].key = capsule{{sw}}[p-1].key + capsule{{sw}}[p-1].value;
		{%endfor%}
	}
	return;
}

void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}loadclopparams(globalparams_t globalparams, clopparams_t * llopparams, unsigned int currentLOP){
	#pragma HLS INLINE
	if((currentLOP % 2) == 1){ llopparams->baseaddr_worksourcekvs_kvs = BASEOFFSET_KVDRAM_KVS; llopparams->baseaddr_workdestkvs_kvs = BASEOFFSET_KVDRAMWORKSPACE_KVS; }
	else { llopparams->baseaddr_worksourcekvs_kvs = BASEOFFSET_KVDRAMWORKSPACE_KVS; llopparams->baseaddr_workdestkvs_kvs = BASEOFFSET_KVDRAM_KVS; }	
	llopparams->baseaddr_capsule_kvs = NAp;
	llopparams->baseaddr_stats = BASEOFFSET_STATSDRAM;
	llopparams->num_source_partitions = get_num_source_partitions(currentLOP);
	llopparams->nextsourceoffset_partition = 0;
	llopparams->nextdestoffset_partition = 0;
	llopparams->nextsourceoffset_kv = 0;
	llopparams->nextdestoffset_kv = 0;
	llopparams->sourceskipsize_partition = getsourceskipsize(currentLOP, globalparams.LLOPnumpartitions);
	llopparams->destskipsize_partition = getdestskipsize(currentLOP, globalparams.LLOPnumpartitions);
	llopparams->sourceskipsize_kv = getsourceskipsize(currentLOP, KVDATA_RANGE_PERSSDPARTITION);
	llopparams->destskipsize_kv = getdestskipsize(currentLOP, KVDATA_RANGE_PERSSDPARTITION);
	llopparams->destpartitionrange = (1 << (KVDATA_RANGE_PERSSDPARTITION_POW - (NUM_PARTITIONS_POW * currentLOP)));
	llopparams->currentLOP = currentLOP;
	llopparams->upperlimit = 0;
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	print1("loadclopparams:: llopparams->baseaddr_worksourcekvs_kvs", llopparams->baseaddr_worksourcekvs_kvs);
	print1("loadclopparams:: llopparams->baseaddr_workdestkvs_kvs", llopparams->baseaddr_workdestkvs_kvs);
	print1("loadclopparams:: llopparams->baseaddr_capsule_kvs", llopparams->baseaddr_capsule_kvs);
	print1("loadclopparams:: llopparams->baseaddr_stats", llopparams->baseaddr_stats);
	print1("loadclopparams:: llopparams->num_source_partitions", llopparams->num_source_partitions);
	print1("loadclopparams:: llopparams->nextsourceoffset_partition", llopparams->nextsourceoffset_partition);
	print1("loadclopparams:: llopparams->nextdestoffset_partition", llopparams->nextdestoffset_partition);
	print1("loadclopparams:: llopparams->nextsourceoffset_kv", llopparams->nextsourceoffset_kv);
	print1("loadclopparams:: llopparams->nextdestoffset_kv", llopparams->nextdestoffset_kv);
	print1("loadclopparams:: llopparams->sourceskipsize_partition", llopparams->sourceskipsize_partition);
	print1("loadclopparams:: llopparams->destskipsize_partition", llopparams->destskipsize_partition);
	print1("loadclopparams:: llopparams->sourceskipsize_kv", llopparams->sourceskipsize_kv);
	print1("loadclopparams:: llopparams->destskipsize_kv", llopparams->destskipsize_kv);
	print1("loadclopparams:: llopparams->destpartitionrange", llopparams->destpartitionrange);
	print1("loadclopparams:: llopparams->currentLOP", llopparams->currentLOP);
	print1("loadclopparams:: llopparams->upperlimit", llopparams->upperlimit);
	#endif
	return;
}
value_t {%if(context['XWARE'] == "SW")%}enigma::{%endif%}reducefunc(keyy_t vid, value_t value, value_t edgeval, unsigned int GraphIter){
	#pragma HLS INLINE
	value_t ret = 0;
	#ifdef PR_ALGORITHM
	ret = value + edgeval;
	#elif defined(BFS_ALGORITHM)
	ret = min(value, GraphIter);
	#elif defined(BC_ALGORITHM)
	ret = min(value, GraphIter);
	#endif
	return ret;
}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}getchunksizes(unsigned int workerID {%for sw in context['NUMSUBWORKERS_seq']%}, buffer_type * chunk{{sw}}_size{%endfor%}, travstate_t travstate){
	#pragma HLS INLINE
	{%for sw in context['NUMSUBWORKERS_seq']%}
	*chunk{{sw}}_size = BUFFER_SIZE;
	batch_type i{{sw}} = travstate.i_kvs + (((workerID * NUMSUBWORKERS) + {{sw}}) * BUFFER_SIZE);
	if (i{{sw}} > travstate.end_kvs){ *chunk{{sw}}_size = 0; }
	else if ((i{{sw}} + BUFFER_SIZE) > travstate.end_kvs){ *chunk{{sw}}_size = travstate.end_kvs - i{{sw}}; }
	else {}
	#ifdef _DEBUGMODE_CHECKS2
	checkoutofbounds("getchunksizes35", *chunk{{sw}}_size, BUFFER_SIZE);
	checkoutofbounds("getchunksizes 35", i{{sw}} + *chunk{{sw}}_size, PADDEDKVSOURCEDRAMSZ_KVS);
	#endif
	{%endfor%}
	return;
}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}readkeyvalues{{ddrs}}(unsigned int workerID, uint512_dt * kvdram {%for sw in context['NUMSUBWORKERS_seq']%}, uint512_dt buffer{{sw}}[PADDEDBUFFER_SIZE]{%endfor%} ,batch_type baseaddress, travstate_t travstate){			
	unsigned int analysis_buffersz = BUFFER_SIZE;
	
	//boundary checks
	{%for sw in context['NUMSUBWORKERS_seq']%}
	buffer_type chunk{{sw}}_size = BUFFER_SIZE;
	{%endfor%}
	getchunksizes(workerID {%for sw in context['NUMSUBWORKERS_seq']%}, &chunk{{sw}}_size{%endfor%}, travstate);
	
	batch_type readoffset_kvs = 0;
	{%for sw in context['NUMSUBWORKERS_seq']%}
	readoffset_kvs = baseaddress + travstate.i_kvs + (((workerID * NUMSUBWORKERS) + {{sw}}) * BUFFER_SIZE); // i{{sw}};
	#ifdef _DEBUGMODE_CHECKS2
	checkoutofbounds("enigma::partitionphase_v1_rd dram 35", readoffset_kvs + chunk{{sw}}_size, PADDEDKVSOURCEDRAMSZ_KVS);
	checkoutofbounds("enigma::partitionphase_v1_rd bram 35", chunk{{sw}}_size, BUFFER_SIZE);
	#endif
	READBUFFER{{sw}}_LOOP1: for (buffer_type j=0; j<chunk{{sw}}_size; j++){
	   #pragma HLS PIPELINE II=1
	   #pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_buffersz avg=analysis_buffersz					
		buffer{{sw}}[j] = kvdram[readoffset_kvs + j];
		
		#ifdef _DEBUGMODE_STATS
		globalstats_countkvsread(VECTOR_SIZE);
		#endif
	}
	{%endfor%}
}
{%endfor%}

/** {%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['NUMWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}partitionkeyvalues{{ddrs}}{{w}}(unsigned int workerID {%for sw in context['NUMSUBWORKERS_seq']%},uint512_dt v1_local{{sw}}[PADDEDBUFFER_SIZE]{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%},uint512_dt result_local{{sw}}[PADDEDBUFFER_SIZE]{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%},keyvalue_t capsule{{sw}}[NUM_PARTITIONS]{%endfor%}, travstate_t travstate, clopparams_t llopparams){					
	unsigned int analysis_partition = BUFFER_SIZE * VECTOR_SIZE;
	
	{%for sw in context['NUMSUBWORKERS_seq']%}
	spartition_type sizes{{sw}}[NUM_PARTITIONS];
	#pragma HLS ARRAY_PARTITION variable=sizes{{sw}} complete 
	{%endfor%}
	
	//boundary checks
	{%for sw in context['NUMSUBWORKERS_seq']%}
	buffer_type chunk{{sw}}_size = BUFFER_SIZE;
	{%endfor%}
	getchunksizes(workerID {%for sw in context['NUMSUBWORKERS_seq']%}, &chunk{{sw}}_size{%endfor%}, travstate);
	
	// extract capsule
	PARTITIONPHASE_RESETCAPSULEA_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){ {%for sw in context['NUMSUBWORKERS_seq']%} capsule{{sw}}[p].value = 0; {%endfor%} }
				
	PARTITIONPHASE_EXTRACTCAPSULES{{sw}}_LOOP2: for(buffer_type k=0; k<BUFFER_SIZE * VECTOR_SIZE; k++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_partition avg=analysis_partition
	#pragma HLS PIPELINE II=1
		{%for sw in context['NUMSUBWORKERS_seq']%}
		keyvalue_t keyvalue{{sw}} = getkeyvalue(v1_local{{sw}}, k, BUFFER_SIZE);
		{%endfor%}
		
		{%for sw in context['NUMSUBWORKERS_seq']%}
		partition_type p{{sw}} = getpartition(keyvalue{{sw}}, llopparams.currentLOP, llopparams.upperlimit);
		{%endfor%}
		
		{%for sw in context['NUMSUBWORKERS_seq']%}
		if(k < chunk{{sw}}_size * VECTOR_SIZE){ capsule{{sw}}[p{{sw}}].value += 1; }
		{%endfor%}
		
		#ifdef _DEBUGMODE_STATS
		{%for sw in context['NUMSUBWORKERS_seq']%}
		if(k < chunk{{sw}}_size * VECTOR_SIZE){ globalstats_countkvstatscollected(1); }
		{%endfor%}
		#endif
	}
	
	// partition
	preparecapsules({%for sw in context['NUMSUBWORKERS_seq']%}{%if(sw>0)%},{%endif%} capsule{{sw}} {%endfor%});				
	PARTITIONPHASE_RESETCAPSULEB{{sw}}_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){ {%for sw in context['NUMSUBWORKERS_seq']%} capsule{{sw}}[p].value = 0; {%endfor%} }
	
	PARTITIONPHASE_PARTITION{{sw}}_LOOP1: for(buffer_type k=0; k<BUFFER_SIZE * VECTOR_SIZE; k++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_partition avg=analysis_partition
	#pragma HLS PIPELINE II=1
		{%for sw in context['NUMSUBWORKERS_seq']%}
		keyvalue_t keyvalue{{sw}} = getkeyvalue(v1_local{{sw}}, k, BUFFER_SIZE);
		{%endfor%}
		
		{%for sw in context['NUMSUBWORKERS_seq']%}
		partition_type p{{sw}} = getpartition(keyvalue{{sw}}, llopparams.currentLOP, llopparams.upperlimit);
		{%endfor%}
		#ifdef _DEBUGMODE_CHECKS2
		{%for sw in context['NUMSUBWORKERS_seq']%}
		checkoutofbounds("enigma::partition_ddr{{ddrs}}_v{{v}} 34", capsule{{sw}}[p{{sw}}].key + capsule{{sw}}[p{{sw}}].value, BUFFER_SIZE * VECTOR_SIZE);
		{%endfor%}
		#endif
		
		{%for sw in context['NUMSUBWORKERS_seq']%}
		setkeyvalue(result_local{{sw}}, capsule{{sw}}[p{{sw}}].key + capsule{{sw}}[p{{sw}}].value, keyvalue{{sw}}, BUFFER_SIZE);
		{%endfor%}
		
		{%for sw in context['NUMSUBWORKERS_seq']%}
		if(k < chunk{{sw}}_size * VECTOR_SIZE){ capsule{{sw}}[p{{sw}}].value += 1; }
		{%endfor%}
		
		#ifdef _DEBUGMODE_STATS
		{%for sw in context['NUMSUBWORKERS_seq']%}
		if(k < chunk{{sw}}_size * VECTOR_SIZE){ globalstats_countkvspartitioned(1); }
		{%endfor%}
		#endif
	}
}
{%endfor%}
{%endfor%} */
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
{%for w in context['NUMWORKERS_seq']%}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}partitionkeyvalues{{ddrs}}{{w}}(unsigned int workerID {%for sw in context['NUMSUBWORKERS_seq']%},uint512_dt v1_local{{sw}}[PADDEDBUFFER_SIZE]{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%},uint512_dt result_local{{sw}}[PADDEDBUFFER_SIZE]{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%},keyvalue_t capsule{{sw}}[NUM_PARTITIONS]{%endfor%}, travstate_t travstate, clopparams_t llopparams){					
	unsigned int analysis_partition = BUFFER_SIZE * VECTOR_SIZE;
	
	{%for sw in context['NUMSUBWORKERS_seq']%}
	keyvalue_t sizes{{sw}}[NUM_PARTITIONS];
	#pragma HLS ARRAY_PARTITION variable=sizes{{sw}} complete 
	{%endfor%}
	
	//boundary checks
	{%for sw in context['NUMSUBWORKERS_seq']%}
	buffer_type chunk{{sw}}_size = BUFFER_SIZE;
	{%endfor%}
	getchunksizes(workerID {%for sw in context['NUMSUBWORKERS_seq']%}, &chunk{{sw}}_size{%endfor%}, travstate);
	
	// extract capsule
	PARTITIONPHASE_RESETCAPSULEA_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){ {%for sw in context['NUMSUBWORKERS_seq']%} sizes{{sw}}[p].value = 0; {%endfor%} }
				
	PARTITIONPHASE_EXTRACTCAPSULES{{sw}}_MAIN: for(buffer_type k=0; k<BUFFER_SIZE * VECTOR_SIZE; k++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_partition avg=analysis_partition
	#pragma HLS PIPELINE II=1
		{%for sw in context['NUMSUBWORKERS_seq']%}
		keyvalue_t keyvalue{{sw}} = getkeyvalue(v1_local{{sw}}, k, BUFFER_SIZE);
		{%endfor%}
		
		{%for sw in context['NUMSUBWORKERS_seq']%}
		partition_type p{{sw}} = getpartition(keyvalue{{sw}}, llopparams.currentLOP, llopparams.upperlimit);
		{%endfor%}
		
		{%for sw in context['NUMSUBWORKERS_seq']%}
		if(k < chunk{{sw}}_size * VECTOR_SIZE){ sizes{{sw}}[p{{sw}}].value += 1; }
		{%endfor%}
		
		#ifdef _DEBUGMODE_STATS
		{%for sw in context['NUMSUBWORKERS_seq']%}
		if(k < chunk{{sw}}_size * VECTOR_SIZE){ globalstats_countkvstatscollected(1); }
		{%endfor%}
		#endif
	}
	
	// partition
	preparecapsules({%for sw in context['NUMSUBWORKERS_seq']%}{%if(sw>0)%},{%endif%} sizes{{sw}} {%endfor%});				
	PARTITIONPHASE_RESETCAPSULEB{{sw}}_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){ {%for sw in context['NUMSUBWORKERS_seq']%} sizes{{sw}}[p].value = 0; {%endfor%} }
	
	PARTITIONPHASE_PARTITION{{sw}}_MAIN: for(buffer_type k=0; k<BUFFER_SIZE * VECTOR_SIZE; k++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_partition avg=analysis_partition
	#pragma HLS PIPELINE II=1
		{%for sw in context['NUMSUBWORKERS_seq']%}
		keyvalue_t keyvalue{{sw}} = getkeyvalue(v1_local{{sw}}, k, BUFFER_SIZE);
		{%endfor%}
		
		{%for sw in context['NUMSUBWORKERS_seq']%}
		partition_type p{{sw}} = getpartition(keyvalue{{sw}}, llopparams.currentLOP, llopparams.upperlimit);
		{%endfor%}
		#ifdef _DEBUGMODE_CHECKS2
		{%for sw in context['NUMSUBWORKERS_seq']%}
		checkoutofbounds("enigma::partition_ddr{{ddrs}}_v{{v}} 34", sizes{{sw}}[p{{sw}}].key + sizes{{sw}}[p{{sw}}].value, BUFFER_SIZE * VECTOR_SIZE);
		{%endfor%}
		#endif
		
		{%for sw in context['NUMSUBWORKERS_seq']%}
		setkeyvalue(result_local{{sw}}, sizes{{sw}}[p{{sw}}].key + sizes{{sw}}[p{{sw}}].value, keyvalue{{sw}}, BUFFER_SIZE);
		{%endfor%}
		
		{%for sw in context['NUMSUBWORKERS_seq']%}
		if(k < chunk{{sw}}_size * VECTOR_SIZE){ sizes{{sw}}[p{{sw}}].value += 1; }
		{%endfor%}
		
		#ifdef _DEBUGMODE_STATS
		{%for sw in context['NUMSUBWORKERS_seq']%}
		if(k < chunk{{sw}}_size * VECTOR_SIZE){ globalstats_countkvspartitioned(1); }
		{%endfor%}
		#endif
	}
	
	for(partition_type p=0; p<NUM_PARTITIONS; p++){ {%for sw in context['NUMSUBWORKERS_seq']%} capsule{{sw}}[p] = sizes{{sw}}[p]; {%endfor%} }
}
{%endfor%}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}savepartitions{{ddrs}}(uint512_dt * kvdram {%for sw in context['NUMSUBWORKERS_seq']%}, uint512_dt result_local{{sw}}[PADDEDBUFFER_SIZE]{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%}, keyvalue_t capsule{{sw}}[NUM_PARTITIONS]{%endfor%} ,keyvalue_t kvdeststats_tmp[NUM_PARTITIONS], batch_type kvdrambaseaddress){				
	#ifdef BUFFERB4WRITE
	int analysis_tempsavebuffer = BUFFER_SIZE / NUM_PARTITIONS;
	int analysis_savebuffer = TEMPBUFFER_SIZE;
	
	uint512_dt tempbuffer[TEMPBUFFER_SIZE];
	unsigned int tempoffset;
	unsigned int travP;
	
	TEMPSAVEPARTITIONS{{sw}}_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){
	tempoffset = 0;
	travP = NOTFINISHED;
		/// for(int it=0; it<(PADDEDBUFFER_SIZE * NUMSUBWORKERS / TEMPBUFFER_SIZE); it++){ // worst case scenario
		for(int it=0; it<1; it++){
		#pragma HLS LOOP_TRIPCOUNT min=1 max=1 avg=1
			{%for sw in context['NUMSUBWORKERS_seq']%}
			buffer_type bramoffset{{sw}}_kvs = (capsule{{sw}}[p].key + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
			buffer_type size{{sw}}_kvs = (capsule{{sw}}[p].value + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
			if(tempoffset + size{{sw}}_kvs >= TEMPBUFFER_SIZE){ size{{sw}}_kvs = TEMPBUFFER_SIZE - tempoffset; travP = NOTFINISHED; }
			else { travP = FINISHED; }
			
			#ifdef _DEBUGMODE_CHECKS
			checkoutofbounds("enigma::savepartitions{{sw}} tempbram 35", tempoffset + size{{sw}}_kvs, TEMPBUFFER_SIZE);
			checkoutofbounds("enigma::savepartitions{{sw}} bram 35", bramoffset{{sw}}_kvs + size{{sw}}_kvs, PADDEDBUFFER_SIZE);
			#endif
			for(buffer_type i=0; i<size{{sw}}_kvs; i++){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_tempsavebuffer avg=analysis_tempsavebuffer
			#pragma HLS PIPELINE II=1
				tempbuffer[tempoffset + i] = result_local{{sw}}[bramoffset{{sw}}_kvs + i];
			}
			tempoffset += size{{sw}}_kvs;
			capsule{{sw}}[p].value = hsub(capsule{{sw}}[p].value, size{{sw}}_kvs * VECTOR_SIZE);
			{%endfor%}
		
			batch_type dramoffset_kvs = kvdrambaseaddress + ((kvdeststats_tmp[p].key + kvdeststats_tmp[p].value) / VECTOR_SIZE);
			#ifdef XILINXLOCKERROR
			SAVEPARTITIONS{{sw}}_MAINA: for (int j=0; j<size{{sw}}_kvs; j++){ // TEMP2BUFFER_SIZE, size{{sw}}_kvs
			#pragma HLS PIPELINE II=1
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_savebuffer avg=analysis_savebuffer
				kvdram[dramoffset_kvs + j] = tempbuffer[j];
				
				#ifdef _DEBUGMODE_STATS
				globalstats_countkvspartitionswritten(VECTOR_SIZE);
				#endif
			}
			#endif 
			#ifndef XILINXLOCKERROR
			if(tempoffset >= 0 && tempoffset < TEMP1BUFFER_SIZE){
				SAVEPARTITIONS{{sw}}_MAINA: for (int j=0; j<TEMP1BUFFER_SIZE; j++){
				#pragma HLS PIPELINE II=1
				#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_savebuffer avg=analysis_savebuffer
					kvdram[dramoffset_kvs + j] = tempbuffer[j];
					
					#ifdef _DEBUGMODE_STATS
					globalstats_countkvspartitionswritten(VECTOR_SIZE);
					#endif
				}
			} else if (tempoffset >= TEMP1BUFFER_SIZE && tempoffset < TEMP2BUFFER_SIZE) {
				SAVEPARTITIONS{{sw}}_MAINB: for (int j=0; j<TEMP2BUFFER_SIZE; j++){
				#pragma HLS PIPELINE II=1
				#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_savebuffer avg=analysis_savebuffer
					kvdram[dramoffset_kvs + j] = tempbuffer[j];
					
					#ifdef _DEBUGMODE_STATS
					globalstats_countkvspartitionswritten(VECTOR_SIZE);
					#endif
				}
			} else if (tempoffset >= TEMP2BUFFER_SIZE && tempoffset < TEMP3BUFFER_SIZE) {
				SAVEPARTITIONS{{sw}}_MAINC: for (int j=0; j<TEMP3BUFFER_SIZE; j++){
				#pragma HLS PIPELINE II=1
				#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_savebuffer avg=analysis_savebuffer
					kvdram[dramoffset_kvs + j] = tempbuffer[j];
					
					#ifdef _DEBUGMODE_STATS
					globalstats_countkvspartitionswritten(VECTOR_SIZE);
					#endif
				}
			} else {
				SAVEPARTITIONS{{sw}}_MAIND: for (int j=0; j<TEMPBUFFER_SIZE; j++){
				#pragma HLS PIPELINE II=1
				#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_savebuffer avg=analysis_savebuffer
					kvdram[dramoffset_kvs + j] = tempbuffer[j];
					
					#ifdef _DEBUGMODE_STATS
					globalstats_countkvspartitionswritten(VECTOR_SIZE);
					#endif
				}
			}
			#endif 
			{%for sw in context['NUMSUBWORKERS_seq']%}
			UPDATEGLOBALSTATS{{sw}}_LOOP1: kvdeststats_tmp[p].value += size{{sw}}_kvs * VECTOR_SIZE;
			{%endfor%}
			/// if(travP == FINISHED){ break; }
		}
	}
	#endif 
	#ifndef BUFFERB4WRITE
	{%for sw in context['NUMSUBWORKERS_seq']%}
		SAVEPARTITIONS{{sw}}_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){
			batch_type dramoffset_kvs = kvdrambaseaddress + ((kvdeststats_tmp[p].key + kvdeststats_tmp[p].value) / VECTOR_SIZE);
			buffer_type bramoffset_kvs = (capsule{{sw}}[p].key + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
			buffer_type size_kvs = (capsule{{sw}}[p].value + (VECTOR_SIZE - 1)) / VECTOR_SIZE;					
			
			#ifdef _DEBUGMODE_CHECKS2
			checkoutofbounds("enigma::savepartitions{{sw}} dram 35", dramoffset_kvs + (BUFFER_SIZE / NUM_PARTITIONS), PADDEDKVSOURCEDRAMSZ_KVS);
			checkoutofbounds("enigma::savepartitions{{sw}} bram 35", bramoffset_kvs + (BUFFER_SIZE / NUM_PARTITIONS), PADDEDBUFFER_SIZE);
			#endif
			#ifdef XILINXLOCKERROR
			for(buffer_type i=0; i<BUFFER_SIZE / NUM_PARTITIONS; i++){ // size_kvs, (BUFFER_SIZE / NUM_PARTITIONS)
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_savepartition avg=analysis_savepartition
			#pragma HLS PIPELINE II=1
				kvdram[dramoffset_kvs + i] = result_local{{sw}}[bramoffset_kvs + i];
				
				#ifdef _DEBUGMODE_STATS
				globalstats_countkvspartitionswritten(VECTOR_SIZE);
				#endif
			}
			#endif 
			#ifndef XILINXLOCKERROR
			if(size_kvs >= 0 && size_kvs < BUFFER1_SIZE){
				#ifdef _DEBUGMODE_CHECKS
				checkoutofbounds("enigma::savepartitions{{sw}} dram 35", dramoffset_kvs + BUFFER1_SIZE + 1, PADDEDKVSOURCEDRAMSZ_KVS);
				checkoutofbounds("enigma::savepartitions{{sw}} dram 135", bramoffset_kvs + BUFFER1_SIZE + 1, PADDEDBUFFER_SIZE);
				#endif
				SAVEPARTITIONS{{sw}}_MAINA: for (buffer_type i=0; i<BUFFER1_SIZE; i++){
				#pragma HLS PIPELINE II=1
				#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_savebuffer avg=analysis_savebuffer
					kvdram[dramoffset_kvs + i] = result_local{{sw}}[(bramoffset_kvs + i) % PADDEDBUFFER_SIZE];
				
					#ifdef _DEBUGMODE_STATS
					globalstats_countkvspartitionswritten(VECTOR_SIZE);
					#endif
				}
			} else if (size_kvs >= BUFFER1_SIZE && size_kvs < BUFFER2_SIZE) {
				#ifdef _DEBUGMODE_CHECKS
				checkoutofbounds("enigma::savepartitions{{sw}} dram 36", dramoffset_kvs + BUFFER2_SIZE + 1, PADDEDKVSOURCEDRAMSZ_KVS);
				checkoutofbounds("enigma::savepartitions{{sw}} dram 136", bramoffset_kvs + BUFFER2_SIZE + 1, PADDEDBUFFER_SIZE);
				#endif
				SAVEPARTITIONS{{sw}}_MAINB: for (buffer_type i=0; i<BUFFER2_SIZE; i++){
				#pragma HLS PIPELINE II=1
				#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_savebuffer avg=analysis_savebuffer
					kvdram[dramoffset_kvs + i] = result_local{{sw}}[(bramoffset_kvs + i) % PADDEDBUFFER_SIZE];
				
					#ifdef _DEBUGMODE_STATS
					globalstats_countkvspartitionswritten(VECTOR_SIZE);
					#endif
				}
			} else if (size_kvs >= BUFFER2_SIZE && size_kvs < BUFFER3_SIZE) {
				#ifdef _DEBUGMODE_CHECKS
				checkoutofbounds("enigma::savepartitions{{sw}} dram 37", dramoffset_kvs + BUFFER3_SIZE + 1, PADDEDKVSOURCEDRAMSZ_KVS);
				checkoutofbounds("enigma::savepartitions{{sw}} dram 137", bramoffset_kvs + BUFFER3_SIZE + 1, PADDEDBUFFER_SIZE);
				#endif
				SAVEPARTITIONS{{sw}}_MAINC: for (buffer_type i=0; i<BUFFER3_SIZE; i++){
				#pragma HLS PIPELINE II=1
				#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_savebuffer avg=analysis_savebuffer
					kvdram[dramoffset_kvs + i] = result_local{{sw}}[(bramoffset_kvs + i) % PADDEDBUFFER_SIZE];
				
					#ifdef _DEBUGMODE_STATS
					globalstats_countkvspartitionswritten(VECTOR_SIZE);
					#endif
				}
			} else {
				#ifdef _DEBUGMODE_CHECKS
				/* if(bramoffset_kvs + PADDEDBUFFER_SIZE - 1 > PADDEDBUFFER_SIZE){
					cout<<"LAST CASE: bramoffset_kvs: "<<bramoffset_kvs<<endl;
					cout<<"LAST CASE: size_kvs: "<<size_kvs<<endl;
					cout<<"LAST CASE: BUFFER1_SIZE: "<<BUFFER1_SIZE<<endl;
					cout<<"LAST CASE: BUFFER2_SIZE: "<<BUFFER2_SIZE<<endl;
					cout<<"LAST CASE: BUFFER3_SIZE: "<<BUFFER3_SIZE<<endl;
					exit(EXIT_FAILURE);
				} */
				checkoutofbounds("enigma::savepartitions{{sw}} dram 38", dramoffset_kvs + PADDEDBUFFER_SIZE - 1, PADDEDKVSOURCEDRAMSZ_KVS);
				checkoutofbounds("enigma::savepartitions{{sw}} dram 138", bramoffset_kvs + PADDEDBUFFER_SIZE - 1, PADDEDBUFFER_SIZE);
				#endif
				SAVEPARTITIONS{{sw}}_MAIND: for (buffer_type i=0; i<PADDEDBUFFER_SIZE-1; i++){
				#pragma HLS PIPELINE II=1
				#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_savebuffer avg=analysis_savebuffer
					kvdram[dramoffset_kvs + i] = result_local{{sw}}[(bramoffset_kvs + i) % PADDEDBUFFER_SIZE];
				
					#ifdef _DEBUGMODE_STATS
					globalstats_countkvspartitionswritten(VECTOR_SIZE);
					#endif
				}
			}
			#endif 
		}
		UPDATEGLOBALSTATS{{sw}}_LOOP1: for(partition_type p=0; p<NUM_PARTITIONS; p++){ kvdeststats_tmp[p].value += allignhigher_KV(capsule{{sw}}[p].value); }
	{%endfor%}
	#endif 
	return;
}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}loadKvDRAM{{ddrs}}(uint512_dt * kvdram, batch_type sourceoffset_kvs, batch_type destoffset_kvs, batch_type size_kvs){
	int analysis_chunksize = BUFFER_SIZE;
	int analysis_iterationcount = KVDATA_BATCHSIZE_KVS / BUFFER_SIZE;
	#ifdef _DEBUGMODE_KERNELPRINTS3
	print4("### loadKvDRAM{{ddrs}}:: sourceoffset_kvs", "destoffset_kvs", "size_kvs", "NAp", sourceoffset_kvs, destoffset_kvs, size_kvs, NAp);
	#endif
	
	uint512_dt v1_local[BUFFER_SIZE];
	
	#ifdef _DEBUGMODE_CHECKS2
	checkoutofbounds("loadKvDRAM{{ddrs}} 35", destoffset_kvs + size_kvs, KVSOURCEDRAMSZ_KVS);
	#endif
	int i;
    for ( i = 0; i < size_kvs; i += BUFFER_SIZE) {
	#pragma HLS LOOP_TRIPCOUNT min=analysis_iterationcount max=analysis_iterationcount
		
		//boundary checks
		int chunk_size = BUFFER_SIZE;
        if ((i + BUFFER_SIZE) > size_kvs)
            chunk_size = size_kvs - i;
	
		v1_rd:
			for (int j = 0; j < chunk_size; j++) {
			   #pragma HLS PIPELINE II=1
			   #pragma HLS LOOP_TRIPCOUNT min=analysis_chunksize max=analysis_chunksize
				v1_local[j] = kvdram[sourceoffset_kvs + i + j];
			}
		out_write:
			for (int j = 0; j < chunk_size; j++) {
			   #pragma HLS PIPELINE II=1
			   #pragma HLS LOOP_TRIPCOUNT min=analysis_chunksize max=analysis_chunksize
				kvdram[destoffset_kvs + i + j] = v1_local[j];
			}
    }
	return;
}
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}generatepartitions{{ddrs}}(uint512_dt * kvsourcedram, uint512_dt * kvdestdram, keyvalue_t * kvstats, globalparams_t globalparams){
	unsigned int analysis_maxtreedepthsz = 1;
	unsigned int analysis_avgnumsourcepartitions = 1;
	unsigned int analysis_avgtripcnt = KVSOURCEDRAMSZ_KVS / (NUMWORKERS * NUMSUBWORKERS * BUFFER_SIZE);
	unsigned int analysis_buffersz = BUFFER_SIZE;
	
	{%for w in context['NUMWORKERS_seq']%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	uint512_dt v1_local{{w}}{{sw}}[PADDEDBUFFER_SIZE];
	uint512_dt result_local{{w}}{{sw}}[PADDEDBUFFER_SIZE];
	keyvalue_t capsule{{w}}{{sw}}[NUM_PARTITIONS];
	{%endfor%}
	{%endfor%}

	// Partition Phase
	PARTITIONPHASE_LOOP1: for(unsigned int currentLOP=1; currentLOP<(globalparams.treedepth + 1); currentLOP++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_maxtreedepthsz avg=analysis_maxtreedepthsz
		keyvalue_t kvdeststats_tmp[NUM_PARTITIONS];
		
		clopparams_t llopparams;
		loadclopparams(globalparams, &llopparams, currentLOP);
		#ifdef _DEBUGMODE_KERNELPRINTS3
		cout<<endl;
		print4("PartitionPhase{{ddrs}}:: num_source_partitions", "num_destpartitions", "sourceskipsize_kv", "NAp", llopparams.num_source_partitions, llopparams.num_source_partitions * NUM_PARTITIONS, llopparams.sourceskipsize_kv, NAp);
		#endif
		
		PARTITIONPHASE_LOOP2: for(unsigned int source_partition=0; source_partition<llopparams.num_source_partitions; source_partition++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_avgnumsourcepartitions avg=analysis_avgnumsourcepartitions		
		
			partitionparams_t partitionparams;
			travstate_t travstate;
			llopparams.upperlimit = globalparams.vbegin + llopparams.nextsourceoffset_kv;
			
			loaddeststats(kvstats, kvdeststats_tmp, llopparams.nextdestoffset_partition, llopparams.currentLOP, globalparams.LLOPnumpartitions);			
			GENERATEPARTITIONS_INITKVDRAMREACKER_LOOP2: for(partition_type p=0; p<NUM_PARTITIONS; p++){ kvdeststats_tmp[p].value = 0; }
			
			keyvalue_t sourcestat = kvstats[getstatsAddr(llopparams.nextsourceoffset_partition)];
			partitionparams.begin_kvs = sourcestat.key / VECTOR_SIZE;
			partitionparams.size_kvs = (sourcestat.value + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
			partitionparams.step_kvs = NUMWORKERS * NUMSUBWORKERS * BUFFER_SIZE;
			partitionparams.end_kvs = partitionparams.begin_kvs + partitionparams.size_kvs;
			travstate.begin_kvs = partitionparams.begin_kvs;
			travstate.end_kvs = partitionparams.end_kvs;
			travstate.skip_kvs = partitionparams.step_kvs;
			#ifdef _DEBUGMODE_KERNELPRINTS2
			print6("PartitionPhase{{ddrs}}:: begin", "size", "step", "currentLOP", "range_per_destpartition", "source_partition", sourcestat.key, sourcestat.value, NUMSUBWORKERS * BUFFER_SIZE * VECTOR_SIZE, llopparams.currentLOP, KVDATA_RANGE_PERSSDPARTITION / pow(NUM_PARTITIONS, llopparams.currentLOP), source_partition);
			#endif
			
			// Partition phase 
			PARTITIONPHASE_MAINLOOP: for (int i = partitionparams.begin_kvs; i < partitionparams.end_kvs; i += BUFFER_SIZE * NUMWORKERS * NUMSUBWORKERS){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_avgtripcnt avg=analysis_avgtripcnt
				#ifdef _DEBUGMODE_KERNELPRINTS
				print5("PartitionPhase{{ddrs}}:: i", "i_end", "NAp", "NAp", "skip size", i, partitionparams.end_kvs, NAp, NAp, BUFFER_SIZE * NUMWORKERS * NUMSUBWORKERS);
				#endif
				travstate.i_kvs = i;
				
				{%for w in context['NUMWORKERS_seq']%}
				{%for sw in context['NUMSUBWORKERS_seq']%}
				buffer_type chunk{{w}}{{sw}}_size = BUFFER_SIZE;
				{%endfor%}
				{%endfor%}
				
				//boundary checks
				{%for w in context['NUMWORKERS_seq']%}
				{%for sw in context['NUMSUBWORKERS_seq']%}
				batch_type i{{w}}{{sw}} = i + ((({{w}} * NUMSUBWORKERS) + {{sw}}) * BUFFER_SIZE);
				if (i{{w}}{{sw}} > partitionparams.end_kvs){ chunk{{w}}{{sw}}_size = 0; }
				else if ((i{{w}}{{sw}} + BUFFER_SIZE) > partitionparams.end_kvs){ chunk{{w}}{{sw}}_size = partitionparams.end_kvs - i{{w}}{{sw}}; }
				else {}
				#ifdef _DEBUGMODE_CHECKS2
				checkoutofbounds("generatepartitions{{ddrs}} 35", chunk{{w}}{{sw}}_size, BUFFER_SIZE);
				checkoutofbounds("generatepartitions{{ddrs}} 35", i{{w}}{{sw}} + chunk{{w}}{{sw}}_size, PADDEDKVSOURCEDRAMSZ_KVS);
				#endif
				{%endfor%}
				{%endfor%}

				// burst read
				{%for w in context['NUMWORKERS_seq']%}
				readkeyvalues{{ddrs}}({{w}}, kvsourcedram {%for sw in context['NUMSUBWORKERS_seq']%}, v1_local{{w}}{{sw}}{%endfor%}, llopparams.baseaddr_worksourcekvs_kvs, travstate);
				{%endfor%}
				
				{%for w in context['NUMWORKERS_seq']%}
				partitionkeyvalues{{ddrs}}{{w}}({{w}} {%for sw in context['NUMSUBWORKERS_seq']%},v1_local{{w}}{{sw}}{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%},result_local{{w}}{{sw}}{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%},capsule{{w}}{{sw}}{%endfor%}, travstate, llopparams);
				{%endfor%}
				
				//burst write the result
				{%for w in context['NUMWORKERS_seq']%}
				savepartitions{{ddrs}}(kvsourcedram {%for sw in context['NUMSUBWORKERS_seq']%}, result_local{{w}}{{sw}}{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%}, capsule{{w}}{{sw}}{%endfor%}, kvdeststats_tmp, llopparams.baseaddr_workdestkvs_kvs);
				{%endfor%}
				
				// break;
			}
			
			storedeststats(kvstats, kvdeststats_tmp, llopparams.nextdestoffset_partition, llopparams.currentLOP, globalparams.LLOPnumpartitions); 
			llopparams.nextsourceoffset_partition += llopparams.sourceskipsize_partition;
			llopparams.nextdestoffset_partition += (llopparams.destskipsize_partition * NUM_PARTITIONS);
			llopparams.nextsourceoffset_kv += llopparams.sourceskipsize_kv;
			llopparams.nextdestoffset_kv += llopparams.destskipsize_kv;
		}
		#ifdef _DEBUGMODE_KERNELPRINTS3
		printglobalvars();
		clearglobalvars();
		#endif
	}

	// Reduce Phase
	#ifdef ENABLEREDUCEPHASE
	if(globalparams.reducecommand == ON){
		unsigned int currentLOP = globalparams.treedepth + 1;
		keyvalue_t kvdeststats_tmp[NUM_PARTITIONS];
		
		clopparams_t llopparams;
		loadclopparams(globalparams, &llopparams, currentLOP);		
		#ifdef _DEBUGMODE_KERNELPRINTS3
		cout<<endl;
		print4("ReducePhase{{ddrs}}:: num_source_partitions", "num_destpartitions", "sourceskipsize_kv", "NAp", llopparams.num_source_partitions, llopparams.num_source_partitions * NUM_PARTITIONS, llopparams.sourceskipsize_kv, NAp);
		#endif
		
		REDUCEPHASE_LOOP1: for(unsigned int source_partition=0; source_partition<llopparams.num_source_partitions; source_partition+=NUMSUBWORKERS){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_avgnumsourcepartitions avg=analysis_avgnumsourcepartitions		
		
			{%for sw in context['NUMSUBWORKERS_seq']%}
			partitionparams_t partition{{sw}}params;
			{%endfor%}
			llopparams.upperlimit = globalparams.vbegin + llopparams.nextsourceoffset_kv;
		
			keyvalue_t sourcestats[NUMSUBWORKERS];
			unsigned int maxsz = 0;
			for(unsigned int i=0; i<NUMSUBWORKERS; i++){ sourcestats[i] = kvstats[source_partition + i]; }
			for(unsigned int sw=0; sw<NUMSUBWORKERS; sw++){ maxsz = max(sourcestats[sw].value, maxsz); }
			unsigned int maxsz_kvs = (maxsz + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
			
			keyvalue_t sourcestat;
			{%for sw in context['NUMSUBWORKERS_seq']%}
			sourcestat = sourcestats[{{sw}}];
			partition{{sw}}params.begin_kvs = sourcestat.key / VECTOR_SIZE;
			partition{{sw}}params.size_kvs = (sourcestat.value + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
			partition{{sw}}params.step_kvs = NUMSUBWORKERS * BUFFER_SIZE;
			partition{{sw}}params.end_kvs = partition{{sw}}params.begin_kvs + partition{{sw}}params.size_kvs;
			{%endfor%}
			
			#ifdef _DEBUGMODE_KERNELPRINTS2
			{%for sw in context['NUMSUBWORKERS_seq']%}
			print6("ReducePhase{{ddrs}}:: begin", "size", "step", "currentLOP", "range_per_destpartition", "source_partition", sourcestats[{{sw}}].key, sourcestats[{{sw}}].value, BUFFER_SIZE * VECTOR_SIZE, llopparams.currentLOP, KVDATA_RANGE_PERSSDPARTITION / pow(NUM_PARTITIONS, llopparams.currentLOP), source_partition);			
			{%endfor%}
			#endif 
			#ifdef _DEBUGMODE_KERNELPRINTS
			print4("ReducePhase{{ddrs}}:: maxsz", "maxsz_kvs", "NAp", "NAp", maxsz, maxsz_kvs, NAp, NAp);
			#endif
			
			// burst read first vector from global memory to local memory
			reducephase_v1_rdv:
			{%for sw in context['NUMSUBWORKERS_seq']%}
				batch_type readdramoffset{{sw}}_kvs = globalparams.baseaddr_destkvs_kvs + (llopparams.nextsourceoffset_kv / VECTOR_SIZE);					
				#ifdef _DEBUGMODE_CHECKS2
				checkoutofbounds("enigma::readphase_v1_rd{{sw}} dram 35", readdramoffset{{sw}}_kvs + APPLYVERTEXBUFFERSZ_KVS, PADDEDKVSOURCEDRAMSZ_KVS);
				#endif
				REDUCEPHASE_READVBUFFER{{sw}}_LOOP1: for (buffer_type j=0; j<APPLYVERTEXBUFFERSZ_KVS; j++){
				   #pragma HLS PIPELINE II=1
				   #pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_buffersz avg=analysis_buffersz					
					v1_local{{sw}}[j] = kvsourcedram[readdramoffset{{sw}}_kvs + j];
					
					#ifdef _DEBUGMODE_STATS
					globalstats_countkvsreadV(VECTOR_SIZE);
					#endif
				}
			{%endfor%}
			
			// Reduce phase
			REDUCEPHASE_REDUCEPARTITION_LOOP: for (int i = 0; i < maxsz_kvs; i += BUFFER_SIZE){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_avgtripcnt avg=analysis_avgtripcnt
				#ifdef _DEBUGMODE_KERNELPRINTS
				print5("ReducePhase{{ddrs}}:: i", "i_end", "NAp", "NAp", "skip size", i, maxsz_kvs, NAp, NAp, BUFFER_SIZE);
				#endif
				
				{%for sw in context['NUMSUBWORKERS_seq']%}
				buffer_type chunk{{sw}}_size = BUFFER_SIZE;
				{%endfor%}
				
				//boundary checks
				{%for sw in context['NUMSUBWORKERS_seq']%}
				batch_type i{{sw}} = i;
				if (i{{sw}} > partition{{sw}}params.size_kvs){ chunk{{sw}}_size = 0; }
				else if ((i{{sw}} + BUFFER_SIZE) > partition{{sw}}params.size_kvs){ chunk{{sw}}_size = partition{{sw}}params.size_kvs - i{{sw}}; }
				else {}
				#ifdef _DEBUGMODE_CHECKS2
				checkoutofbounds("reducepartitions{{ddrs}} 35", chunk{{sw}}_size, BUFFER_SIZE);
				checkoutofbounds("reducepartitions{{ddrs}} 35", i{{sw}} + chunk{{sw}}_size, PADDEDKVSOURCEDRAMSZ_KVS);
				#endif
				{%endfor%}

				// burst read
				reducephase_v1_rd:
				{%for sw in context['NUMSUBWORKERS_seq']%}				
					batch_type readdramoffset{{sw}}_kvs = llopparams.baseaddr_worksourcekvs_kvs + i;									
					#ifdef _DEBUGMODE_CHECKS2
					checkoutofbounds("enigma::reducephase_v1_rd{{sw}} dram 35", readdramoffset{{sw}}_kvs + chunk{{sw}}_size, PADDEDKVSOURCEDRAMSZ_KVS);
					checkoutofbounds("enigma::reducephase_v1_rd{{sw}} bram 35", chunk{{sw}}_size, BUFFER_SIZE + 1);
					#endif
					REDUCEPHASE_READBUFFER{{sw}}_LOOP1: for (buffer_type j=0; j<chunk{{sw}}_size; j++){
					   #pragma HLS PIPELINE II=1
					   #pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_buffersz avg=analysis_buffersz					
						v1_local{{sw}}[j] = kvsourcedram[readdramoffset{{sw}}_kvs + j];
						
						#ifdef _DEBUGMODE_STATS
						globalstats_countkvsread(VECTOR_SIZE);
						#endif
					}
				{%endfor%}
				
				// reduce 
				REDUCEPHASE_REDUCE{{v}}_LOOP2: for(buffer_type k=0; k<BUFFER_SIZE * VECTOR_SIZE; k++){
				#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_buffersz avg=analysis_buffersz
				#pragma HLS PIPELINE II=1					
					{%for sw in context['NUMSUBWORKERS_seq']%}
					keyvalue_t keyvalue{{sw}} = getkeyvalue(v1_local{{sw}}, k, BUFFER_SIZE);
					{%endfor%}
					
					{%for sw in context['NUMSUBWORKERS_seq']%}
					vertex_t loc{{sw}} = keyvalue{{sw}}.key - globalparams.vbegin;
					{%endfor%}
					
					{%for sw in context['NUMSUBWORKERS_seq']%}
					if(loc{{sw}} >= BUFFER_SIZE * VECTOR_SIZE){ loc{{sw}} = 0; } // REMOVEME.
					{%endfor%}
					
					#ifdef _DEBUGMODE_CHECKS2
					{%for sw in context['NUMSUBWORKERS_seq']%}
					checkoutofbounds("legion::reduce_ddr{{ddrs}}_v{{v}} 34", loc{{sw}}, BUFFER_SIZE * VECTOR_SIZE);
					{%endfor%}
					#endif
					
					{%for sw in context['NUMSUBWORKERS_seq']%}
					keyvalue_t vprop{{sw}} = getkeyvalue(result_local{{sw}}, loc{{sw}}, BUFFER_SIZE);
					{%endfor%}
					
					{%for sw in context['NUMSUBWORKERS_seq']%}
					value_t temp{{sw}} = reducefunc(vprop{{sw}}.key, vprop{{sw}}.value, keyvalue{{sw}}.value, globalparams.GraphIter);
					{%endfor%}
					
					{%for sw in context['NUMSUBWORKERS_seq']%}
					vprop{{sw}}.value = temp{{sw}};
					{%endfor%}
					
					{%for sw in context['NUMSUBWORKERS_seq']%}
					setkeyvalue(result_local{{sw}}, loc{{sw}}, vprop{{sw}}, BUFFER_SIZE);	
					{%endfor%}
					
					#ifdef _DEBUGMODE_STATS
					{%for sw in context['NUMSUBWORKERS_seq']%}
					if(k < chunk{{sw}}_size * VECTOR_SIZE){ globalstats_countkvsreduced(1); }
					{%endfor%}
					#endif
				}
			}
			
			//burst write the result
			reducephase_out_write:
			{%for sw in context['NUMSUBWORKERS_seq']%}
				batch_type dramsaveoffset{{sw}}_kvs = globalparams.baseaddr_destkvs_kvs + (llopparams.nextsourceoffset_kv / VECTOR_SIZE);					
				#ifdef _DEBUGMODE_CHECKS2
				checkoutofbounds("enigma::reducephase_out_write{{sw}} dram 35", dramsaveoffset{{sw}}_kvs + APPLYVERTEXBUFFERSZ_KVS, KVDATA_RANGE_PERSSDPARTITION_KVS);
				#endif
				REDUCEPHASE_SAVEVBUFFER{{sw}}_LOOP1: for (buffer_type j=0; j<APPLYVERTEXBUFFERSZ_KVS; j++){
				   #pragma HLS PIPELINE II=1
				   #pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_buffersz avg=analysis_buffersz
					kvdestdram[dramsaveoffset{{sw}}_kvs + j] = result_local{{sw}}[j];
					
					#ifdef _DEBUGMODE_STATS
					globalstats_countkvsreducewritten(VECTOR_SIZE);
					#endif
				}
			{%endfor%}

			llopparams.nextsourceoffset_partition += NUMSUBWORKERS;
			llopparams.nextsourceoffset_kv += llopparams.sourceskipsize_kv;
		}
		#ifdef _DEBUGMODE_KERNELPRINTS2
		printglobalvars();
		printparameters();
		clearglobalvars();
		#endif
	}
	#endif
	return;
}
{%endfor%}
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}generatepartitions(
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}uint512_dt * kvsourcedram{{ddrs_}},{%endfor%} 
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}keyvalue_t * kvstats{{ddrs_}},{%endfor%} 
	globalparams_t globalparams){
	#pragma HLS INLINE

	unsigned int analysis_maxtreedepthsz = 1;
	unsigned int analysis_avgnumsourcepartitions = 1;
	unsigned int analysis_avgtripcnt = KVSOURCEDRAMSZ_KVS / (NUMWORKERS * NUMSUBWORKERS * BUFFER_SIZE);
	unsigned int analysis_buffersz = BUFFER_SIZE;
	
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	{%for w in context['NUMWORKERS_seq']%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	uint512_dt v1_local{{ddrs_}}{{w}}{{sw}}[PADDEDBUFFER_SIZE];
	uint512_dt result_local{{ddrs_}}{{w}}{{sw}}[PADDEDBUFFER_SIZE];
	keyvalue_t capsule{{ddrs_}}{{w}}{{sw}}[NUM_PARTITIONS];
	{%endfor%}
	{%endfor%}
	{%endfor%}

	// Partition Phase
	PARTITIONPHASE_LOOP1: for(unsigned int currentLOP=1; currentLOP<(globalparams.treedepth + 1); currentLOP++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_maxtreedepthsz avg=analysis_maxtreedepthsz
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		keyvalue_t kvdeststats{{ddrs_}}_tmp[NUM_PARTITIONS];
		{%endfor%}
		
		clopparams_t llopparams;
		loadclopparams(globalparams, &llopparams, currentLOP);
		#ifdef _DEBUGMODE_KERNELPRINTS3
		cout<<endl;
		print4("PartitionPhase{{ddrs_}}:: num_source_partitions", "num_destpartitions", "sourceskipsize_kv", "NAp", llopparams.num_source_partitions, llopparams.num_source_partitions * NUM_PARTITIONS, llopparams.sourceskipsize_kv, NAp);
		#endif
		
		PARTITIONPHASE_LOOP2: for(unsigned int source_partition=0; source_partition<llopparams.num_source_partitions; source_partition++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_avgnumsourcepartitions avg=analysis_avgnumsourcepartitions		
		
			travstate_t travstate;
			llopparams.upperlimit = globalparams.vbegin + llopparams.nextsourceoffset_kv;
			
			{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
			partitionparams_t partitionparams{{ddrs_}};
			
			loaddeststats(kvstats{{ddrs_}}, kvdeststats{{ddrs_}}_tmp, llopparams.nextdestoffset_partition, llopparams.currentLOP, globalparams.LLOPnumpartitions);			
			GENERATEPARTITIONS{{ddrs_}}_INITKVDRAMREACKER_LOOP2: for(partition_type p=0; p<NUM_PARTITIONS; p++){ kvdeststats{{ddrs_}}_tmp[p].value = 0; }
			
			keyvalue_t sourcestat{{ddrs_}} = kvstats{{ddrs_}}[getstatsAddr(llopparams.nextsourceoffset_partition)];
			partitionparams{{ddrs_}}.begin_kvs = sourcestat{{ddrs_}}.key / VECTOR_SIZE;
			partitionparams{{ddrs_}}.size_kvs = (sourcestat{{ddrs_}}.value + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
			partitionparams{{ddrs_}}.step_kvs = NUMWORKERS * NUMSUBWORKERS * BUFFER_SIZE;
			partitionparams{{ddrs_}}.end_kvs = partitionparams{{ddrs_}}.begin_kvs + partitionparams{{ddrs_}}.size_kvs;
			{%endfor%}
			
			
			travstate.begin_kvs = partitionparamsA.begin_kvs;
			travstate.end_kvs = partitionparamsA.end_kvs;
			travstate.skip_kvs = partitionparamsA.step_kvs;
			#ifdef _DEBUGMODE_KERNELPRINTS2
			{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
			print6("PartitionPhase{{ddrs_}}:: begin", "size", "step", "currentLOP", "range_per_destpartition", "source_partition", sourcestat{{ddrs_}}.key, sourcestat{{ddrs_}}.value, NUMSUBWORKERS * BUFFER_SIZE * VECTOR_SIZE, llopparams.currentLOP, KVDATA_RANGE_PERSSDPARTITION / pow(NUM_PARTITIONS, llopparams.currentLOP), source_partition);
			{%endfor%}
			#endif
			
			// Partition phase 
			PARTITIONPHASE_MAINLOOP: for (int i = partitionparamsA.begin_kvs; i < partitionparamsA.end_kvs; i += BUFFER_SIZE * NUMWORKERS * NUMSUBWORKERS){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_avgtripcnt avg=analysis_avgtripcnt
				#ifdef _DEBUGMODE_KERNELPRINTS
				print5("PartitionPhase{{ddrs}}:: i", "i_end", "NAp", "NAp", "skip size", i, partitionparamsA.end_kvs, NAp, NAp, BUFFER_SIZE * NUMWORKERS * NUMSUBWORKERS);
				#endif
				travstate.i_kvs = i;
				
				{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
				{%for w in context['NUMWORKERS_seq']%}
				{%for sw in context['NUMSUBWORKERS_seq']%}
				buffer_type chunk{{ddrs_}}{{w}}{{sw}}_size = BUFFER_SIZE;
				{%endfor%}
				{%endfor%}
				{%endfor%}
				
				//boundary checks
				{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
				{%for w in context['NUMWORKERS_seq']%}
				{%for sw in context['NUMSUBWORKERS_seq']%}
				batch_type i{{ddrs_}}{{w}}{{sw}} = i + ((({{w}} * NUMSUBWORKERS) + {{sw}}) * BUFFER_SIZE);
				if (i{{ddrs_}}{{w}}{{sw}} > partitionparams{{ddrs_}}.end_kvs){ chunk{{ddrs_}}{{w}}{{sw}}_size = 0; }
				else if ((i{{ddrs_}}{{w}}{{sw}} + BUFFER_SIZE) > partitionparams{{ddrs_}}.end_kvs){ chunk{{ddrs_}}{{w}}{{sw}}_size = partitionparams{{ddrs_}}.end_kvs - i{{ddrs_}}{{w}}{{sw}}; }
				else {}
				#ifdef _DEBUGMODE_CHECKS2
				checkoutofbounds("generatepartitions{{ddrs_}} 35", chunk{{ddrs_}}{{w}}{{sw}}_size, BUFFER_SIZE);
				checkoutofbounds("generatepartitions{{ddrs_}} 35", i{{ddrs_}}{{w}}{{sw}} + chunk{{ddrs_}}{{w}}{{sw}}_size, PADDEDKVSOURCEDRAMSZ_KVS);
				#endif
				{%endfor%}
				{%endfor%}
				{%endfor%}

				// burst read
				{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
				{%for w in context['NUMWORKERS_seq']%}
				readkeyvalues{{ddrs}}({{w}}, kvsourcedram{{ddrs_}} {%for sw in context['NUMSUBWORKERS_seq']%}, v1_local{{ddrs_}}{{w}}{{sw}}{%endfor%}, llopparams.baseaddr_worksourcekvs_kvs, travstate);
				{%endfor%}
				{%endfor%}
				
				{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
				{%for w in context['NUMWORKERS_seq']%}
				partitionkeyvalues{{ddrs}}{{w}}({{w}} {%for sw in context['NUMSUBWORKERS_seq']%},v1_local{{ddrs_}}{{w}}{{sw}}{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%},result_local{{ddrs_}}{{w}}{{sw}}{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%},capsule{{ddrs_}}{{w}}{{sw}}{%endfor%}, travstate, llopparams);
				{%endfor%}
				{%endfor%}
				
				//burst write the result
				{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
				{%for w in context['NUMWORKERS_seq']%}
				savepartitions{{ddrs}}(kvsourcedram{{ddrs_}} {%for sw in context['NUMSUBWORKERS_seq']%}, result_local{{ddrs_}}{{w}}{{sw}}{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%}, capsule{{ddrs_}}{{w}}{{sw}}{%endfor%}, kvdeststats{{ddrs_}}_tmp, llopparams.baseaddr_workdestkvs_kvs);
				{%endfor%}
				{%endfor%}
			}
			
			{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
			storedeststats(kvstats{{ddrs_}}, kvdeststats{{ddrs_}}_tmp, llopparams.nextdestoffset_partition, llopparams.currentLOP, globalparams.LLOPnumpartitions); 
			{%endfor%}
			llopparams.nextsourceoffset_partition += llopparams.sourceskipsize_partition;
			llopparams.nextdestoffset_partition += (llopparams.destskipsize_partition * NUM_PARTITIONS);
			llopparams.nextsourceoffset_kv += llopparams.sourceskipsize_kv;
			llopparams.nextdestoffset_kv += llopparams.destskipsize_kv;
		}
		#ifdef _DEBUGMODE_KERNELPRINTS3
		printglobalvars();
		clearglobalvars();
		#endif
	}
	return;
}

extern "C" {
void {%if(context['XWARE'] == "SW")%}enigma::{%endif%}topkernel(
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		{%if(ddrs==0)%}{%else%},{%endif%}uint512_dt * kvsourcedram{{ddrs_}}
		{%endfor%}
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		,uint512_dt * kvdestdram{{ddrs_}}
		{%endfor%}
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		,keyvalue_t * kvstats{{ddrs_}}
		{%endfor%}
        ){
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE m_axi port=kvsourcedram{{ddrs_}}  offset=slave bundle=gmem{{ddrs}} max_read_burst_length=256 max_write_burst_length=256
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE m_axi port=kvdestdram{{ddrs_}}  offset=slave bundle=gmem{{context['NUMINSTANCES'] + ddrs}} max_read_burst_length=64 max_write_burst_length=64
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE m_axi port=kvstats{{ddrs_}}  offset=slave bundle=gmem{{context['NUMINSTANCES'] + context['NUMINSTANCES'] + ddrs}}
{%endfor%}

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE s_axilite port=kvsourcedram{{ddrs_}}  bundle=control
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE s_axilite port=kvdestdram{{ddrs_}}  bundle=control
{%endfor%}
{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS INTERFACE s_axilite port=kvstats{{ddrs_}}  bundle=control
{%endfor%}

#pragma HLS INTERFACE s_axilite port=return bundle=control

{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
#pragma HLS DATA_PACK variable=kvstats{{ddrs_}}
{%endfor%}
	
	globalparams_t globalparams;
	globalparams.runkernelcommand = kvstatsA[getmessagesAddr(MESSAGES_RUNKERNELCOMMANDID)].key;
	globalparams.processcommand = kvstatsA[getmessagesAddr(MESSAGES_PROCESSCOMMANDID)].key;
	globalparams.partitioncommand = kvstatsA[getmessagesAddr(MESSAGES_PARTITIONCOMMANDID)].key;
	globalparams.reducecommand = kvstatsA[getmessagesAddr(MESSAGES_APPLYUPDATESCOMMANDID)].key;
	globalparams.vbegin = kvstatsA[getmessagesAddr(MESSAGES_VOFFSET)].key; 
	globalparams.vsize = kvstatsA[getmessagesAddr(MESSAGES_VSIZE)].key; 
	globalparams.treedepth = kvstatsA[getmessagesAddr(MESSAGES_TREEDEPTH)].key; 
	globalparams.LLOPnumpartitions = kvstatsA[getmessagesAddr(MESSAGES_FINALNUMPARTITIONS)].key;
	globalparams.GraphIter = kvstatsA[getmessagesAddr(MESSAGES_GRAPHITERATIONID)].key;
	globalparams.IterCount = kvstatsA[getmessagesAddr(MESSAGES_ITERATIONID)].key;
	globalparams.baseaddr_destkvs_kvs = 0;
	
	#ifdef _DEBUGMODE_KERNELPRINTS
	std::cout<<std::endl;
	std::cout<<"Kernel Started: globalparams.runkernelcommand: "<<globalparams.runkernelcommand<<std::endl;
	std::cout<<"Kernel Started: globalparams.processcommand: "<<globalparams.processcommand<<std::endl;
	std::cout<<"Kernel Started: globalparams.partitioncommand: "<<globalparams.partitioncommand<<std::endl;
	std::cout<<"Kernel Started: globalparams.reducecommand: "<<globalparams.reducecommand<<std::endl;
	std::cout<<"Kernel Started: globalparams.vbegin: "<<globalparams.vbegin<<std::endl;
	std::cout<<"Kernel Started: globalparams.vsize: "<<globalparams.vsize<<std::endl;
	std::cout<<"Kernel Started: globalparams.treedepth: "<<globalparams.treedepth<<std::endl;
	std::cout<<"Kernel Started: globalparams.LLOPnumpartitions: "<<globalparams.LLOPnumpartitions<<std::endl;
	std::cout<<"Kernel Started: globalparams.GraphIter: "<<globalparams.GraphIter<<std::endl;
	std::cout<<"Kernel Started: globalparams.IterCount: "<<globalparams.IterCount<<std::endl;
	#endif
	
	if(globalparams.runkernelcommand == OFF){
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		loadKvDRAM{{ddrs}}(kvsourcedram{{ddrs_}}, 0, ((globalparams.IterCount % DRAMBATCHFACTOR) + 1) * KVDATA_BATCHSIZE_KVS, KVDATA_BATCHSIZE_KVS);
		{%endfor%}
		return;
	}
	
	#ifdef _DEBUGMODE_KERNELPRINTS3
	cout<<"...running Acts..."<<endl;
	#endif 
	
	#ifndef GROUPALLINSTANCES
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	generatepartitions{{ddrs}}(kvsourcedram{{ddrs_}}, kvdestdram{{ddrs_}}, kvstats{{ddrs_}}, globalparams);
	{%endfor%}
	#endif 
	#ifdef GROUPALLINSTANCES
	/** generatepartitions(
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%} kvsourcedram{{ddrs_}},{%endfor%} 
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%} kvstats{{ddrs_}},{%endfor%} 
		globalparams); */
	unsigned int analysis_maxtreedepthsz = 1;
	unsigned int analysis_avgnumsourcepartitions = 1;
	unsigned int analysis_avgtripcnt = KVSOURCEDRAMSZ_KVS / (NUMWORKERS * NUMSUBWORKERS * BUFFER_SIZE);
	unsigned int analysis_buffersz = BUFFER_SIZE;
	
	{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
	{%for w in context['NUMWORKERS_seq']%}
	{%for sw in context['NUMSUBWORKERS_seq']%}
	uint512_dt v1_local{{ddrs_}}{{w}}{{sw}}[PADDEDBUFFER_SIZE];
	uint512_dt result_local{{ddrs_}}{{w}}{{sw}}[PADDEDBUFFER_SIZE];
	keyvalue_t capsule{{ddrs_}}{{w}}{{sw}}[NUM_PARTITIONS];
	{%endfor%}
	{%endfor%}
	{%endfor%}

	// Partition Phase
	PARTITIONPHASE_LOOP1: for(unsigned int currentLOP=1; currentLOP<(globalparams.treedepth + 1); currentLOP++){
	#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_maxtreedepthsz avg=analysis_maxtreedepthsz
		{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
		keyvalue_t kvdeststats{{ddrs_}}_tmp[NUM_PARTITIONS];
		{%endfor%}
		
		clopparams_t llopparams;
		loadclopparams(globalparams, &llopparams, currentLOP);
		#ifdef _DEBUGMODE_KERNELPRINTS3
		cout<<endl;
		print4("PartitionPhase{{ddrs_}}:: num_source_partitions", "num_destpartitions", "sourceskipsize_kv", "NAp", llopparams.num_source_partitions, llopparams.num_source_partitions * NUM_PARTITIONS, llopparams.sourceskipsize_kv, NAp);
		#endif
		
		PARTITIONPHASE_LOOP2: for(unsigned int source_partition=0; source_partition<llopparams.num_source_partitions; source_partition++){
		#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_avgnumsourcepartitions avg=analysis_avgnumsourcepartitions		
		
			travstate_t travstate;
			llopparams.upperlimit = globalparams.vbegin + llopparams.nextsourceoffset_kv;
			
			{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
			partitionparams_t partitionparams{{ddrs_}};
			
			loaddeststats(kvstats{{ddrs_}}, kvdeststats{{ddrs_}}_tmp, llopparams.nextdestoffset_partition, llopparams.currentLOP, globalparams.LLOPnumpartitions);			
			GENERATEPARTITIONS{{ddrs_}}_INITKVDRAMREACKER_LOOP2: for(partition_type p=0; p<NUM_PARTITIONS; p++){ kvdeststats{{ddrs_}}_tmp[p].value = 0; }
			
			keyvalue_t sourcestat{{ddrs_}} = kvstats{{ddrs_}}[getstatsAddr(llopparams.nextsourceoffset_partition)];
			partitionparams{{ddrs_}}.begin_kvs = sourcestat{{ddrs_}}.key / VECTOR_SIZE;
			partitionparams{{ddrs_}}.size_kvs = (sourcestat{{ddrs_}}.value + (VECTOR_SIZE - 1)) / VECTOR_SIZE;
			partitionparams{{ddrs_}}.step_kvs = NUMWORKERS * NUMSUBWORKERS * BUFFER_SIZE;
			partitionparams{{ddrs_}}.end_kvs = partitionparams{{ddrs_}}.begin_kvs + partitionparams{{ddrs_}}.size_kvs;
			{%endfor%}
			
			
			travstate.begin_kvs = partitionparamsA.begin_kvs;
			travstate.end_kvs = partitionparamsA.end_kvs;
			travstate.skip_kvs = partitionparamsA.step_kvs;
			#ifdef _DEBUGMODE_KERNELPRINTS2
			{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
			print6("PartitionPhase{{ddrs_}}:: begin", "size", "step", "currentLOP", "range_per_destpartition", "source_partition", sourcestat{{ddrs_}}.key, sourcestat{{ddrs_}}.value, NUMSUBWORKERS * BUFFER_SIZE * VECTOR_SIZE, llopparams.currentLOP, KVDATA_RANGE_PERSSDPARTITION / pow(NUM_PARTITIONS, llopparams.currentLOP), source_partition);
			{%endfor%}
			#endif
			
			// Partition phase 
			PARTITIONPHASE_MAINLOOP: for (int i = partitionparamsA.begin_kvs; i < partitionparamsA.end_kvs; i += BUFFER_SIZE * NUMWORKERS * NUMSUBWORKERS){
			#pragma HLS LOOP_TRIPCOUNT min=0 max=analysis_avgtripcnt avg=analysis_avgtripcnt
				#ifdef _DEBUGMODE_KERNELPRINTS
				print5("PartitionPhase{{ddrs}}:: i", "i_end", "NAp", "NAp", "skip size", i, partitionparamsA.end_kvs, NAp, NAp, BUFFER_SIZE * NUMWORKERS * NUMSUBWORKERS);
				#endif
				travstate.i_kvs = i;
				
				{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
				{%for w in context['NUMWORKERS_seq']%}
				{%for sw in context['NUMSUBWORKERS_seq']%}
				buffer_type chunk{{ddrs_}}{{w}}{{sw}}_size = BUFFER_SIZE;
				{%endfor%}
				{%endfor%}
				{%endfor%}
				
				//boundary checks
				{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
				{%for w in context['NUMWORKERS_seq']%}
				{%for sw in context['NUMSUBWORKERS_seq']%}
				batch_type i{{ddrs_}}{{w}}{{sw}} = i + ((({{w}} * NUMSUBWORKERS) + {{sw}}) * BUFFER_SIZE);
				if (i{{ddrs_}}{{w}}{{sw}} > partitionparams{{ddrs_}}.end_kvs){ chunk{{ddrs_}}{{w}}{{sw}}_size = 0; }
				else if ((i{{ddrs_}}{{w}}{{sw}} + BUFFER_SIZE) > partitionparams{{ddrs_}}.end_kvs){ chunk{{ddrs_}}{{w}}{{sw}}_size = partitionparams{{ddrs_}}.end_kvs - i{{ddrs_}}{{w}}{{sw}}; }
				else {}
				#ifdef _DEBUGMODE_CHECKS2
				checkoutofbounds("generatepartitions{{ddrs_}} 35", chunk{{ddrs_}}{{w}}{{sw}}_size, BUFFER_SIZE);
				checkoutofbounds("generatepartitions{{ddrs_}} 35", i{{ddrs_}}{{w}}{{sw}} + chunk{{ddrs_}}{{w}}{{sw}}_size, PADDEDKVSOURCEDRAMSZ_KVS);
				#endif
				{%endfor%}
				{%endfor%}
				{%endfor%}

				// burst read
				{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
				{%for w in context['NUMWORKERS_seq']%}
				readkeyvalues{{ddrs}}({{w}}, kvsourcedram{{ddrs_}} {%for sw in context['NUMSUBWORKERS_seq']%}, v1_local{{ddrs_}}{{w}}{{sw}}{%endfor%}, llopparams.baseaddr_worksourcekvs_kvs, travstate);
				{%endfor%}
				{%endfor%}
				
				{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
				{%for w in context['NUMWORKERS_seq']%}
				partitionkeyvalues{{ddrs}}{{w}}({{w}} {%for sw in context['NUMSUBWORKERS_seq']%},v1_local{{ddrs_}}{{w}}{{sw}}{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%},result_local{{ddrs_}}{{w}}{{sw}}{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%},capsule{{ddrs_}}{{w}}{{sw}}{%endfor%}, travstate, llopparams);
				{%endfor%}
				{%endfor%}
				
				//burst write the result
				{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
				{%for w in context['NUMWORKERS_seq']%}
				savepartitions{{ddrs}}(kvsourcedram{{ddrs_}} {%for sw in context['NUMSUBWORKERS_seq']%}, result_local{{ddrs_}}{{w}}{{sw}}{%endfor%} {%for sw in context['NUMSUBWORKERS_seq']%}, capsule{{ddrs_}}{{w}}{{sw}}{%endfor%}, kvdeststats{{ddrs_}}_tmp, llopparams.baseaddr_workdestkvs_kvs);
				{%endfor%}
				{%endfor%}
			}
			
			{%for ddrs, ddrs_ in zip(context['NUMINSTANCES_seq'], context['INSTANCES_charseq'])%}
			storedeststats(kvstats{{ddrs_}}, kvdeststats{{ddrs_}}_tmp, llopparams.nextdestoffset_partition, llopparams.currentLOP, globalparams.LLOPnumpartitions); 
			{%endfor%}
			llopparams.nextsourceoffset_partition += llopparams.sourceskipsize_partition;
			llopparams.nextdestoffset_partition += (llopparams.destskipsize_partition * NUM_PARTITIONS);
			llopparams.nextsourceoffset_kv += llopparams.sourceskipsize_kv;
			llopparams.nextdestoffset_kv += llopparams.destskipsize_kv;
		}
		#ifdef _DEBUGMODE_KERNELPRINTS3
		printglobalvars();
		clearglobalvars();
		#endif
	}
	#endif 
	return;
}
}






